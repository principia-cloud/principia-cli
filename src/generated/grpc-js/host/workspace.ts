// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: host/workspace.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
	type CallOptions,
	type ChannelCredentials,
	Client,
	type ClientOptions,
	type ClientUnaryCall,
	type handleUnaryCall,
	makeGenericClientConstructor,
	type Metadata,
	type ServiceError,
	type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { FileDiagnostics, Metadata as Metadata1 } from "../cline/common";

export interface GetWorkspacePathsRequest {
	/**
	 * The unique ID for the workspace/project.
	 * This is currently optional in vscode. It is required in other environments where cline is running at
	 * the application level, and the user can open multiple projects.
	 */
	id?: string | undefined;
}

export interface GetWorkspacePathsResponse {
	/** The unique ID for the workspace/project. */
	id?: string | undefined;
	paths: string[];
}

export interface SaveOpenDocumentIfDirtyRequest {
	filePath?: string | undefined;
}

export interface SaveOpenDocumentIfDirtyResponse {
	/** Returns true if the document was saved. */
	wasSaved?: boolean | undefined;
}

export interface GetDiagnosticsRequest {
	metadata?: Metadata1 | undefined;
}

export interface GetDiagnosticsResponse {
	fileDiagnostics: FileDiagnostics[];
}

/** Request for host-side workspace search (files/folders) used by mentions autocomplete */
export interface SearchWorkspaceItemsRequest {
	/** Search query string */
	query: string;
	/** Optional limit for results (default decided by host) */
	limit?: number | undefined;
	selectedType?: SearchWorkspaceItemsRequest_SearchItemType | undefined;
}

/** Optional selected type filter */
export enum SearchWorkspaceItemsRequest_SearchItemType {
	FILE = 0,
	FOLDER = 1,
	UNRECOGNIZED = -1,
}

export function searchWorkspaceItemsRequest_SearchItemTypeFromJSON(
	object: any,
): SearchWorkspaceItemsRequest_SearchItemType {
	switch (object) {
		case 0:
		case "FILE":
			return SearchWorkspaceItemsRequest_SearchItemType.FILE;
		case 1:
		case "FOLDER":
			return SearchWorkspaceItemsRequest_SearchItemType.FOLDER;
		case -1:
		case "UNRECOGNIZED":
		default:
			return SearchWorkspaceItemsRequest_SearchItemType.UNRECOGNIZED;
	}
}

export function searchWorkspaceItemsRequest_SearchItemTypeToJSON(
	object: SearchWorkspaceItemsRequest_SearchItemType,
): string {
	switch (object) {
		case SearchWorkspaceItemsRequest_SearchItemType.FILE:
			return "FILE";
		case SearchWorkspaceItemsRequest_SearchItemType.FOLDER:
			return "FOLDER";
		case SearchWorkspaceItemsRequest_SearchItemType.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED";
	}
}

/** Response for host-side workspace search */
export interface SearchWorkspaceItemsResponse {
	items: SearchWorkspaceItemsResponse_SearchItem[];
}

export interface SearchWorkspaceItemsResponse_SearchItem {
	/** Workspace-relative path using platform separators */
	path: string;
	type: SearchWorkspaceItemsRequest_SearchItemType;
	/** Optional display label (e.g., basename) */
	label?: string | undefined;
}

export interface OpenProblemsPanelRequest {}

export interface OpenProblemsPanelResponse {}

export interface OpenInFileExplorerPanelRequest {
	path: string;
}

export interface OpenInFileExplorerPanelResponse {}

export interface OpenClineSidebarPanelRequest {}

export interface OpenClineSidebarPanelResponse {}

export interface OpenTerminalRequest {}

export interface OpenTerminalResponse {}

/** Execute a command in the terminal */
export interface ExecuteCommandInTerminalRequest {
	/** The command to execute */
	command: string;
}

export interface ExecuteCommandInTerminalResponse {
	/** Whether the command was successfully sent to the terminal */
	success: boolean;
}

/** Request to open a folder/workspace */
export interface OpenFolderRequest {
	/** The path to the folder to open */
	path: string;
	/** Whether to open in a new window */
	newWindow: boolean;
}

export interface OpenFolderResponse {
	success: boolean;
}

function createBaseGetWorkspacePathsRequest(): GetWorkspacePathsRequest {
	return { id: undefined };
}

export const GetWorkspacePathsRequest: MessageFns<GetWorkspacePathsRequest> = {
	encode(
		message: GetWorkspacePathsRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.id !== undefined) {
			writer.uint32(10).string(message.id);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): GetWorkspacePathsRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseGetWorkspacePathsRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.id = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): GetWorkspacePathsRequest {
		return { id: isSet(object.id) ? globalThis.String(object.id) : undefined };
	},

	toJSON(message: GetWorkspacePathsRequest): unknown {
		const obj: any = {};
		if (message.id !== undefined) {
			obj.id = message.id;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<GetWorkspacePathsRequest>, I>>(
		base?: I,
	): GetWorkspacePathsRequest {
		return GetWorkspacePathsRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<GetWorkspacePathsRequest>, I>>(
		object: I,
	): GetWorkspacePathsRequest {
		const message = createBaseGetWorkspacePathsRequest();
		message.id = object.id ?? undefined;
		return message;
	},
};

function createBaseGetWorkspacePathsResponse(): GetWorkspacePathsResponse {
	return { id: undefined, paths: [] };
}

export const GetWorkspacePathsResponse: MessageFns<GetWorkspacePathsResponse> =
	{
		encode(
			message: GetWorkspacePathsResponse,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.id !== undefined) {
				writer.uint32(10).string(message.id);
			}
			for (const v of message.paths) {
				writer.uint32(18).string(v!);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): GetWorkspacePathsResponse {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseGetWorkspacePathsResponse();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.id = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 18) {
							break;
						}

						message.paths.push(reader.string());
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): GetWorkspacePathsResponse {
			return {
				id: isSet(object.id) ? globalThis.String(object.id) : undefined,
				paths: globalThis.Array.isArray(object?.paths)
					? object.paths.map((e: any) => globalThis.String(e))
					: [],
			};
		},

		toJSON(message: GetWorkspacePathsResponse): unknown {
			const obj: any = {};
			if (message.id !== undefined) {
				obj.id = message.id;
			}
			if (message.paths?.length) {
				obj.paths = message.paths;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<GetWorkspacePathsResponse>, I>>(
			base?: I,
		): GetWorkspacePathsResponse {
			return GetWorkspacePathsResponse.fromPartial(base ?? ({} as any));
		},
		fromPartial<I extends Exact<DeepPartial<GetWorkspacePathsResponse>, I>>(
			object: I,
		): GetWorkspacePathsResponse {
			const message = createBaseGetWorkspacePathsResponse();
			message.id = object.id ?? undefined;
			message.paths = object.paths?.map((e) => e) || [];
			return message;
		},
	};

function createBaseSaveOpenDocumentIfDirtyRequest(): SaveOpenDocumentIfDirtyRequest {
	return { filePath: undefined };
}

export const SaveOpenDocumentIfDirtyRequest: MessageFns<SaveOpenDocumentIfDirtyRequest> =
	{
		encode(
			message: SaveOpenDocumentIfDirtyRequest,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.filePath !== undefined) {
				writer.uint32(18).string(message.filePath);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): SaveOpenDocumentIfDirtyRequest {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseSaveOpenDocumentIfDirtyRequest();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 2: {
						if (tag !== 18) {
							break;
						}

						message.filePath = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): SaveOpenDocumentIfDirtyRequest {
			return {
				filePath: isSet(object.filePath)
					? globalThis.String(object.filePath)
					: isSet(object.file_path)
						? globalThis.String(object.file_path)
						: undefined,
			};
		},

		toJSON(message: SaveOpenDocumentIfDirtyRequest): unknown {
			const obj: any = {};
			if (message.filePath !== undefined) {
				obj.filePath = message.filePath;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<SaveOpenDocumentIfDirtyRequest>, I>>(
			base?: I,
		): SaveOpenDocumentIfDirtyRequest {
			return SaveOpenDocumentIfDirtyRequest.fromPartial(base ?? ({} as any));
		},
		fromPartial<
			I extends Exact<DeepPartial<SaveOpenDocumentIfDirtyRequest>, I>,
		>(object: I): SaveOpenDocumentIfDirtyRequest {
			const message = createBaseSaveOpenDocumentIfDirtyRequest();
			message.filePath = object.filePath ?? undefined;
			return message;
		},
	};

function createBaseSaveOpenDocumentIfDirtyResponse(): SaveOpenDocumentIfDirtyResponse {
	return { wasSaved: undefined };
}

export const SaveOpenDocumentIfDirtyResponse: MessageFns<SaveOpenDocumentIfDirtyResponse> =
	{
		encode(
			message: SaveOpenDocumentIfDirtyResponse,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.wasSaved !== undefined) {
				writer.uint32(8).bool(message.wasSaved);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): SaveOpenDocumentIfDirtyResponse {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseSaveOpenDocumentIfDirtyResponse();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 8) {
							break;
						}

						message.wasSaved = reader.bool();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): SaveOpenDocumentIfDirtyResponse {
			return {
				wasSaved: isSet(object.wasSaved)
					? globalThis.Boolean(object.wasSaved)
					: isSet(object.was_saved)
						? globalThis.Boolean(object.was_saved)
						: undefined,
			};
		},

		toJSON(message: SaveOpenDocumentIfDirtyResponse): unknown {
			const obj: any = {};
			if (message.wasSaved !== undefined) {
				obj.wasSaved = message.wasSaved;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<SaveOpenDocumentIfDirtyResponse>, I>>(
			base?: I,
		): SaveOpenDocumentIfDirtyResponse {
			return SaveOpenDocumentIfDirtyResponse.fromPartial(base ?? ({} as any));
		},
		fromPartial<
			I extends Exact<DeepPartial<SaveOpenDocumentIfDirtyResponse>, I>,
		>(object: I): SaveOpenDocumentIfDirtyResponse {
			const message = createBaseSaveOpenDocumentIfDirtyResponse();
			message.wasSaved = object.wasSaved ?? undefined;
			return message;
		},
	};

function createBaseGetDiagnosticsRequest(): GetDiagnosticsRequest {
	return { metadata: undefined };
}

export const GetDiagnosticsRequest: MessageFns<GetDiagnosticsRequest> = {
	encode(
		message: GetDiagnosticsRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata1.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): GetDiagnosticsRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseGetDiagnosticsRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata1.decode(reader, reader.uint32());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): GetDiagnosticsRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata1.fromJSON(object.metadata)
				: undefined,
		};
	},

	toJSON(message: GetDiagnosticsRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata1.toJSON(message.metadata);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<GetDiagnosticsRequest>, I>>(
		base?: I,
	): GetDiagnosticsRequest {
		return GetDiagnosticsRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<GetDiagnosticsRequest>, I>>(
		object: I,
	): GetDiagnosticsRequest {
		const message = createBaseGetDiagnosticsRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata1.fromPartial(object.metadata)
				: undefined;
		return message;
	},
};

function createBaseGetDiagnosticsResponse(): GetDiagnosticsResponse {
	return { fileDiagnostics: [] };
}

export const GetDiagnosticsResponse: MessageFns<GetDiagnosticsResponse> = {
	encode(
		message: GetDiagnosticsResponse,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		for (const v of message.fileDiagnostics) {
			FileDiagnostics.encode(v!, writer.uint32(10).fork()).join();
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): GetDiagnosticsResponse {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseGetDiagnosticsResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.fileDiagnostics.push(
						FileDiagnostics.decode(reader, reader.uint32()),
					);
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): GetDiagnosticsResponse {
		return {
			fileDiagnostics: globalThis.Array.isArray(object?.fileDiagnostics)
				? object.fileDiagnostics.map((e: any) => FileDiagnostics.fromJSON(e))
				: globalThis.Array.isArray(object?.file_diagnostics)
					? object.file_diagnostics.map((e: any) => FileDiagnostics.fromJSON(e))
					: [],
		};
	},

	toJSON(message: GetDiagnosticsResponse): unknown {
		const obj: any = {};
		if (message.fileDiagnostics?.length) {
			obj.fileDiagnostics = message.fileDiagnostics.map((e) =>
				FileDiagnostics.toJSON(e),
			);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<GetDiagnosticsResponse>, I>>(
		base?: I,
	): GetDiagnosticsResponse {
		return GetDiagnosticsResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<GetDiagnosticsResponse>, I>>(
		object: I,
	): GetDiagnosticsResponse {
		const message = createBaseGetDiagnosticsResponse();
		message.fileDiagnostics =
			object.fileDiagnostics?.map((e) => FileDiagnostics.fromPartial(e)) || [];
		return message;
	},
};

function createBaseSearchWorkspaceItemsRequest(): SearchWorkspaceItemsRequest {
	return { query: "", limit: undefined, selectedType: undefined };
}

export const SearchWorkspaceItemsRequest: MessageFns<SearchWorkspaceItemsRequest> =
	{
		encode(
			message: SearchWorkspaceItemsRequest,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.query !== "") {
				writer.uint32(10).string(message.query);
			}
			if (message.limit !== undefined) {
				writer.uint32(16).int32(message.limit);
			}
			if (message.selectedType !== undefined) {
				writer.uint32(24).int32(message.selectedType);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): SearchWorkspaceItemsRequest {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseSearchWorkspaceItemsRequest();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.query = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 16) {
							break;
						}

						message.limit = reader.int32();
						continue;
					}
					case 3: {
						if (tag !== 24) {
							break;
						}

						message.selectedType = reader.int32() as any;
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): SearchWorkspaceItemsRequest {
			return {
				query: isSet(object.query) ? globalThis.String(object.query) : "",
				limit: isSet(object.limit)
					? globalThis.Number(object.limit)
					: undefined,
				selectedType: isSet(object.selectedType)
					? searchWorkspaceItemsRequest_SearchItemTypeFromJSON(
							object.selectedType,
						)
					: isSet(object.selected_type)
						? searchWorkspaceItemsRequest_SearchItemTypeFromJSON(
								object.selected_type,
							)
						: undefined,
			};
		},

		toJSON(message: SearchWorkspaceItemsRequest): unknown {
			const obj: any = {};
			if (message.query !== "") {
				obj.query = message.query;
			}
			if (message.limit !== undefined) {
				obj.limit = Math.round(message.limit);
			}
			if (message.selectedType !== undefined) {
				obj.selectedType = searchWorkspaceItemsRequest_SearchItemTypeToJSON(
					message.selectedType,
				);
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<SearchWorkspaceItemsRequest>, I>>(
			base?: I,
		): SearchWorkspaceItemsRequest {
			return SearchWorkspaceItemsRequest.fromPartial(base ?? ({} as any));
		},
		fromPartial<I extends Exact<DeepPartial<SearchWorkspaceItemsRequest>, I>>(
			object: I,
		): SearchWorkspaceItemsRequest {
			const message = createBaseSearchWorkspaceItemsRequest();
			message.query = object.query ?? "";
			message.limit = object.limit ?? undefined;
			message.selectedType = object.selectedType ?? undefined;
			return message;
		},
	};

function createBaseSearchWorkspaceItemsResponse(): SearchWorkspaceItemsResponse {
	return { items: [] };
}

export const SearchWorkspaceItemsResponse: MessageFns<SearchWorkspaceItemsResponse> =
	{
		encode(
			message: SearchWorkspaceItemsResponse,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			for (const v of message.items) {
				SearchWorkspaceItemsResponse_SearchItem.encode(
					v!,
					writer.uint32(10).fork(),
				).join();
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): SearchWorkspaceItemsResponse {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseSearchWorkspaceItemsResponse();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.items.push(
							SearchWorkspaceItemsResponse_SearchItem.decode(
								reader,
								reader.uint32(),
							),
						);
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): SearchWorkspaceItemsResponse {
			return {
				items: globalThis.Array.isArray(object?.items)
					? object.items.map((e: any) =>
							SearchWorkspaceItemsResponse_SearchItem.fromJSON(e),
						)
					: [],
			};
		},

		toJSON(message: SearchWorkspaceItemsResponse): unknown {
			const obj: any = {};
			if (message.items?.length) {
				obj.items = message.items.map((e) =>
					SearchWorkspaceItemsResponse_SearchItem.toJSON(e),
				);
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<SearchWorkspaceItemsResponse>, I>>(
			base?: I,
		): SearchWorkspaceItemsResponse {
			return SearchWorkspaceItemsResponse.fromPartial(base ?? ({} as any));
		},
		fromPartial<I extends Exact<DeepPartial<SearchWorkspaceItemsResponse>, I>>(
			object: I,
		): SearchWorkspaceItemsResponse {
			const message = createBaseSearchWorkspaceItemsResponse();
			message.items =
				object.items?.map((e) =>
					SearchWorkspaceItemsResponse_SearchItem.fromPartial(e),
				) || [];
			return message;
		},
	};

function createBaseSearchWorkspaceItemsResponse_SearchItem(): SearchWorkspaceItemsResponse_SearchItem {
	return { path: "", type: 0, label: undefined };
}

export const SearchWorkspaceItemsResponse_SearchItem: MessageFns<SearchWorkspaceItemsResponse_SearchItem> =
	{
		encode(
			message: SearchWorkspaceItemsResponse_SearchItem,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.path !== "") {
				writer.uint32(10).string(message.path);
			}
			if (message.type !== 0) {
				writer.uint32(16).int32(message.type);
			}
			if (message.label !== undefined) {
				writer.uint32(26).string(message.label);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): SearchWorkspaceItemsResponse_SearchItem {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseSearchWorkspaceItemsResponse_SearchItem();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.path = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 16) {
							break;
						}

						message.type = reader.int32() as any;
						continue;
					}
					case 3: {
						if (tag !== 26) {
							break;
						}

						message.label = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): SearchWorkspaceItemsResponse_SearchItem {
			return {
				path: isSet(object.path) ? globalThis.String(object.path) : "",
				type: isSet(object.type)
					? searchWorkspaceItemsRequest_SearchItemTypeFromJSON(object.type)
					: 0,
				label: isSet(object.label)
					? globalThis.String(object.label)
					: undefined,
			};
		},

		toJSON(message: SearchWorkspaceItemsResponse_SearchItem): unknown {
			const obj: any = {};
			if (message.path !== "") {
				obj.path = message.path;
			}
			if (message.type !== 0) {
				obj.type = searchWorkspaceItemsRequest_SearchItemTypeToJSON(
					message.type,
				);
			}
			if (message.label !== undefined) {
				obj.label = message.label;
			}
			return obj;
		},

		create<
			I extends Exact<DeepPartial<SearchWorkspaceItemsResponse_SearchItem>, I>,
		>(base?: I): SearchWorkspaceItemsResponse_SearchItem {
			return SearchWorkspaceItemsResponse_SearchItem.fromPartial(
				base ?? ({} as any),
			);
		},
		fromPartial<
			I extends Exact<DeepPartial<SearchWorkspaceItemsResponse_SearchItem>, I>,
		>(object: I): SearchWorkspaceItemsResponse_SearchItem {
			const message = createBaseSearchWorkspaceItemsResponse_SearchItem();
			message.path = object.path ?? "";
			message.type = object.type ?? 0;
			message.label = object.label ?? undefined;
			return message;
		},
	};

function createBaseOpenProblemsPanelRequest(): OpenProblemsPanelRequest {
	return {};
}

export const OpenProblemsPanelRequest: MessageFns<OpenProblemsPanelRequest> = {
	encode(
		_: OpenProblemsPanelRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): OpenProblemsPanelRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseOpenProblemsPanelRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(_: any): OpenProblemsPanelRequest {
		return {};
	},

	toJSON(_: OpenProblemsPanelRequest): unknown {
		const obj: any = {};
		return obj;
	},

	create<I extends Exact<DeepPartial<OpenProblemsPanelRequest>, I>>(
		base?: I,
	): OpenProblemsPanelRequest {
		return OpenProblemsPanelRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<OpenProblemsPanelRequest>, I>>(
		_: I,
	): OpenProblemsPanelRequest {
		const message = createBaseOpenProblemsPanelRequest();
		return message;
	},
};

function createBaseOpenProblemsPanelResponse(): OpenProblemsPanelResponse {
	return {};
}

export const OpenProblemsPanelResponse: MessageFns<OpenProblemsPanelResponse> =
	{
		encode(
			_: OpenProblemsPanelResponse,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): OpenProblemsPanelResponse {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseOpenProblemsPanelResponse();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(_: any): OpenProblemsPanelResponse {
			return {};
		},

		toJSON(_: OpenProblemsPanelResponse): unknown {
			const obj: any = {};
			return obj;
		},

		create<I extends Exact<DeepPartial<OpenProblemsPanelResponse>, I>>(
			base?: I,
		): OpenProblemsPanelResponse {
			return OpenProblemsPanelResponse.fromPartial(base ?? ({} as any));
		},
		fromPartial<I extends Exact<DeepPartial<OpenProblemsPanelResponse>, I>>(
			_: I,
		): OpenProblemsPanelResponse {
			const message = createBaseOpenProblemsPanelResponse();
			return message;
		},
	};

function createBaseOpenInFileExplorerPanelRequest(): OpenInFileExplorerPanelRequest {
	return { path: "" };
}

export const OpenInFileExplorerPanelRequest: MessageFns<OpenInFileExplorerPanelRequest> =
	{
		encode(
			message: OpenInFileExplorerPanelRequest,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.path !== "") {
				writer.uint32(10).string(message.path);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): OpenInFileExplorerPanelRequest {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseOpenInFileExplorerPanelRequest();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.path = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): OpenInFileExplorerPanelRequest {
			return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
		},

		toJSON(message: OpenInFileExplorerPanelRequest): unknown {
			const obj: any = {};
			if (message.path !== "") {
				obj.path = message.path;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<OpenInFileExplorerPanelRequest>, I>>(
			base?: I,
		): OpenInFileExplorerPanelRequest {
			return OpenInFileExplorerPanelRequest.fromPartial(base ?? ({} as any));
		},
		fromPartial<
			I extends Exact<DeepPartial<OpenInFileExplorerPanelRequest>, I>,
		>(object: I): OpenInFileExplorerPanelRequest {
			const message = createBaseOpenInFileExplorerPanelRequest();
			message.path = object.path ?? "";
			return message;
		},
	};

function createBaseOpenInFileExplorerPanelResponse(): OpenInFileExplorerPanelResponse {
	return {};
}

export const OpenInFileExplorerPanelResponse: MessageFns<OpenInFileExplorerPanelResponse> =
	{
		encode(
			_: OpenInFileExplorerPanelResponse,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): OpenInFileExplorerPanelResponse {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseOpenInFileExplorerPanelResponse();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(_: any): OpenInFileExplorerPanelResponse {
			return {};
		},

		toJSON(_: OpenInFileExplorerPanelResponse): unknown {
			const obj: any = {};
			return obj;
		},

		create<I extends Exact<DeepPartial<OpenInFileExplorerPanelResponse>, I>>(
			base?: I,
		): OpenInFileExplorerPanelResponse {
			return OpenInFileExplorerPanelResponse.fromPartial(base ?? ({} as any));
		},
		fromPartial<
			I extends Exact<DeepPartial<OpenInFileExplorerPanelResponse>, I>,
		>(_: I): OpenInFileExplorerPanelResponse {
			const message = createBaseOpenInFileExplorerPanelResponse();
			return message;
		},
	};

function createBaseOpenClineSidebarPanelRequest(): OpenClineSidebarPanelRequest {
	return {};
}

export const OpenClineSidebarPanelRequest: MessageFns<OpenClineSidebarPanelRequest> =
	{
		encode(
			_: OpenClineSidebarPanelRequest,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): OpenClineSidebarPanelRequest {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseOpenClineSidebarPanelRequest();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(_: any): OpenClineSidebarPanelRequest {
			return {};
		},

		toJSON(_: OpenClineSidebarPanelRequest): unknown {
			const obj: any = {};
			return obj;
		},

		create<I extends Exact<DeepPartial<OpenClineSidebarPanelRequest>, I>>(
			base?: I,
		): OpenClineSidebarPanelRequest {
			return OpenClineSidebarPanelRequest.fromPartial(base ?? ({} as any));
		},
		fromPartial<I extends Exact<DeepPartial<OpenClineSidebarPanelRequest>, I>>(
			_: I,
		): OpenClineSidebarPanelRequest {
			const message = createBaseOpenClineSidebarPanelRequest();
			return message;
		},
	};

function createBaseOpenClineSidebarPanelResponse(): OpenClineSidebarPanelResponse {
	return {};
}

export const OpenClineSidebarPanelResponse: MessageFns<OpenClineSidebarPanelResponse> =
	{
		encode(
			_: OpenClineSidebarPanelResponse,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): OpenClineSidebarPanelResponse {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseOpenClineSidebarPanelResponse();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(_: any): OpenClineSidebarPanelResponse {
			return {};
		},

		toJSON(_: OpenClineSidebarPanelResponse): unknown {
			const obj: any = {};
			return obj;
		},

		create<I extends Exact<DeepPartial<OpenClineSidebarPanelResponse>, I>>(
			base?: I,
		): OpenClineSidebarPanelResponse {
			return OpenClineSidebarPanelResponse.fromPartial(base ?? ({} as any));
		},
		fromPartial<I extends Exact<DeepPartial<OpenClineSidebarPanelResponse>, I>>(
			_: I,
		): OpenClineSidebarPanelResponse {
			const message = createBaseOpenClineSidebarPanelResponse();
			return message;
		},
	};

function createBaseOpenTerminalRequest(): OpenTerminalRequest {
	return {};
}

export const OpenTerminalRequest: MessageFns<OpenTerminalRequest> = {
	encode(
		_: OpenTerminalRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): OpenTerminalRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseOpenTerminalRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(_: any): OpenTerminalRequest {
		return {};
	},

	toJSON(_: OpenTerminalRequest): unknown {
		const obj: any = {};
		return obj;
	},

	create<I extends Exact<DeepPartial<OpenTerminalRequest>, I>>(
		base?: I,
	): OpenTerminalRequest {
		return OpenTerminalRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<OpenTerminalRequest>, I>>(
		_: I,
	): OpenTerminalRequest {
		const message = createBaseOpenTerminalRequest();
		return message;
	},
};

function createBaseOpenTerminalResponse(): OpenTerminalResponse {
	return {};
}

export const OpenTerminalResponse: MessageFns<OpenTerminalResponse> = {
	encode(
		_: OpenTerminalResponse,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): OpenTerminalResponse {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseOpenTerminalResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(_: any): OpenTerminalResponse {
		return {};
	},

	toJSON(_: OpenTerminalResponse): unknown {
		const obj: any = {};
		return obj;
	},

	create<I extends Exact<DeepPartial<OpenTerminalResponse>, I>>(
		base?: I,
	): OpenTerminalResponse {
		return OpenTerminalResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<OpenTerminalResponse>, I>>(
		_: I,
	): OpenTerminalResponse {
		const message = createBaseOpenTerminalResponse();
		return message;
	},
};

function createBaseExecuteCommandInTerminalRequest(): ExecuteCommandInTerminalRequest {
	return { command: "" };
}

export const ExecuteCommandInTerminalRequest: MessageFns<ExecuteCommandInTerminalRequest> =
	{
		encode(
			message: ExecuteCommandInTerminalRequest,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.command !== "") {
				writer.uint32(10).string(message.command);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): ExecuteCommandInTerminalRequest {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseExecuteCommandInTerminalRequest();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.command = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): ExecuteCommandInTerminalRequest {
			return {
				command: isSet(object.command) ? globalThis.String(object.command) : "",
			};
		},

		toJSON(message: ExecuteCommandInTerminalRequest): unknown {
			const obj: any = {};
			if (message.command !== "") {
				obj.command = message.command;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<ExecuteCommandInTerminalRequest>, I>>(
			base?: I,
		): ExecuteCommandInTerminalRequest {
			return ExecuteCommandInTerminalRequest.fromPartial(base ?? ({} as any));
		},
		fromPartial<
			I extends Exact<DeepPartial<ExecuteCommandInTerminalRequest>, I>,
		>(object: I): ExecuteCommandInTerminalRequest {
			const message = createBaseExecuteCommandInTerminalRequest();
			message.command = object.command ?? "";
			return message;
		},
	};

function createBaseExecuteCommandInTerminalResponse(): ExecuteCommandInTerminalResponse {
	return { success: false };
}

export const ExecuteCommandInTerminalResponse: MessageFns<ExecuteCommandInTerminalResponse> =
	{
		encode(
			message: ExecuteCommandInTerminalResponse,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.success !== false) {
				writer.uint32(8).bool(message.success);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): ExecuteCommandInTerminalResponse {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseExecuteCommandInTerminalResponse();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 8) {
							break;
						}

						message.success = reader.bool();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): ExecuteCommandInTerminalResponse {
			return {
				success: isSet(object.success)
					? globalThis.Boolean(object.success)
					: false,
			};
		},

		toJSON(message: ExecuteCommandInTerminalResponse): unknown {
			const obj: any = {};
			if (message.success !== false) {
				obj.success = message.success;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<ExecuteCommandInTerminalResponse>, I>>(
			base?: I,
		): ExecuteCommandInTerminalResponse {
			return ExecuteCommandInTerminalResponse.fromPartial(base ?? ({} as any));
		},
		fromPartial<
			I extends Exact<DeepPartial<ExecuteCommandInTerminalResponse>, I>,
		>(object: I): ExecuteCommandInTerminalResponse {
			const message = createBaseExecuteCommandInTerminalResponse();
			message.success = object.success ?? false;
			return message;
		},
	};

function createBaseOpenFolderRequest(): OpenFolderRequest {
	return { path: "", newWindow: false };
}

export const OpenFolderRequest: MessageFns<OpenFolderRequest> = {
	encode(
		message: OpenFolderRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.path !== "") {
			writer.uint32(10).string(message.path);
		}
		if (message.newWindow !== false) {
			writer.uint32(16).bool(message.newWindow);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): OpenFolderRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseOpenFolderRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.path = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 16) {
						break;
					}

					message.newWindow = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): OpenFolderRequest {
		return {
			path: isSet(object.path) ? globalThis.String(object.path) : "",
			newWindow: isSet(object.newWindow)
				? globalThis.Boolean(object.newWindow)
				: isSet(object.new_window)
					? globalThis.Boolean(object.new_window)
					: false,
		};
	},

	toJSON(message: OpenFolderRequest): unknown {
		const obj: any = {};
		if (message.path !== "") {
			obj.path = message.path;
		}
		if (message.newWindow !== false) {
			obj.newWindow = message.newWindow;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<OpenFolderRequest>, I>>(
		base?: I,
	): OpenFolderRequest {
		return OpenFolderRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<OpenFolderRequest>, I>>(
		object: I,
	): OpenFolderRequest {
		const message = createBaseOpenFolderRequest();
		message.path = object.path ?? "";
		message.newWindow = object.newWindow ?? false;
		return message;
	},
};

function createBaseOpenFolderResponse(): OpenFolderResponse {
	return { success: false };
}

export const OpenFolderResponse: MessageFns<OpenFolderResponse> = {
	encode(
		message: OpenFolderResponse,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.success !== false) {
			writer.uint32(8).bool(message.success);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): OpenFolderResponse {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseOpenFolderResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.success = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): OpenFolderResponse {
		return {
			success: isSet(object.success)
				? globalThis.Boolean(object.success)
				: false,
		};
	},

	toJSON(message: OpenFolderResponse): unknown {
		const obj: any = {};
		if (message.success !== false) {
			obj.success = message.success;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<OpenFolderResponse>, I>>(
		base?: I,
	): OpenFolderResponse {
		return OpenFolderResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<OpenFolderResponse>, I>>(
		object: I,
	): OpenFolderResponse {
		const message = createBaseOpenFolderResponse();
		message.success = object.success ?? false;
		return message;
	},
};

/** Provides methods for working with workspaces/projects. */
export type WorkspaceServiceDefinition = typeof WorkspaceServiceDefinition;
export const WorkspaceServiceDefinition = {
	name: "WorkspaceService",
	fullName: "host.WorkspaceService",
	methods: {
		/** Returns a list of the top level directories of the workspace. */
		getWorkspacePaths: {
			name: "getWorkspacePaths",
			requestType: GetWorkspacePathsRequest,
			requestStream: false,
			responseType: GetWorkspacePathsResponse,
			responseStream: false,
			options: {},
		},
		/**
		 * Saves an open document if it's open in the editor and has unsaved changes.
		 * Returns true if the document was saved, returns false if the document was not found, or did not
		 * need to be saved.
		 */
		saveOpenDocumentIfDirty: {
			name: "saveOpenDocumentIfDirty",
			requestType: SaveOpenDocumentIfDirtyRequest,
			requestStream: false,
			responseType: SaveOpenDocumentIfDirtyResponse,
			responseStream: false,
			options: {},
		},
		/** Get diagnostics from the workspace. */
		getDiagnostics: {
			name: "getDiagnostics",
			requestType: GetDiagnosticsRequest,
			requestStream: false,
			responseType: GetDiagnosticsResponse,
			responseStream: false,
			options: {},
		},
		/** Makes the problems panel/pane visible in the IDE and focuses it. */
		openProblemsPanel: {
			name: "openProblemsPanel",
			requestType: OpenProblemsPanelRequest,
			requestStream: false,
			responseType: OpenProblemsPanelResponse,
			responseStream: false,
			options: {},
		},
		/** Opens the IDE file explorer panel and selects a file or directory. */
		openInFileExplorerPanel: {
			name: "openInFileExplorerPanel",
			requestType: OpenInFileExplorerPanelRequest,
			requestStream: false,
			responseType: OpenInFileExplorerPanelResponse,
			responseStream: false,
			options: {},
		},
		/** Opens and focuses the Cline sidebar panel in the host IDE. */
		openClineSidebarPanel: {
			name: "openClineSidebarPanel",
			requestType: OpenClineSidebarPanelRequest,
			requestStream: false,
			responseType: OpenClineSidebarPanelResponse,
			responseStream: false,
			options: {},
		},
		/** Opens and focuses the terminal panel. */
		openTerminalPanel: {
			name: "openTerminalPanel",
			requestType: OpenTerminalRequest,
			requestStream: false,
			responseType: OpenTerminalResponse,
			responseStream: false,
			options: {},
		},
		/** Executes a command in a new terminal */
		executeCommandInTerminal: {
			name: "executeCommandInTerminal",
			requestType: ExecuteCommandInTerminalRequest,
			requestStream: false,
			responseType: ExecuteCommandInTerminalResponse,
			responseStream: false,
			options: {},
		},
		/** Opens a folder/workspace in the IDE */
		openFolder: {
			name: "openFolder",
			requestType: OpenFolderRequest,
			requestStream: false,
			responseType: OpenFolderResponse,
			responseStream: false,
			options: {},
		},
	},
} as const;

/** Provides methods for working with workspaces/projects. */
export type WorkspaceServiceService = typeof WorkspaceServiceService;
export const WorkspaceServiceService = {
	/** Returns a list of the top level directories of the workspace. */
	getWorkspacePaths: {
		path: "/host.WorkspaceService/getWorkspacePaths",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: GetWorkspacePathsRequest): Buffer =>
			Buffer.from(GetWorkspacePathsRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): GetWorkspacePathsRequest =>
			GetWorkspacePathsRequest.decode(value),
		responseSerialize: (value: GetWorkspacePathsResponse): Buffer =>
			Buffer.from(GetWorkspacePathsResponse.encode(value).finish()),
		responseDeserialize: (value: Buffer): GetWorkspacePathsResponse =>
			GetWorkspacePathsResponse.decode(value),
	},
	/**
	 * Saves an open document if it's open in the editor and has unsaved changes.
	 * Returns true if the document was saved, returns false if the document was not found, or did not
	 * need to be saved.
	 */
	saveOpenDocumentIfDirty: {
		path: "/host.WorkspaceService/saveOpenDocumentIfDirty",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: SaveOpenDocumentIfDirtyRequest): Buffer =>
			Buffer.from(SaveOpenDocumentIfDirtyRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): SaveOpenDocumentIfDirtyRequest =>
			SaveOpenDocumentIfDirtyRequest.decode(value),
		responseSerialize: (value: SaveOpenDocumentIfDirtyResponse): Buffer =>
			Buffer.from(SaveOpenDocumentIfDirtyResponse.encode(value).finish()),
		responseDeserialize: (value: Buffer): SaveOpenDocumentIfDirtyResponse =>
			SaveOpenDocumentIfDirtyResponse.decode(value),
	},
	/** Get diagnostics from the workspace. */
	getDiagnostics: {
		path: "/host.WorkspaceService/getDiagnostics",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: GetDiagnosticsRequest): Buffer =>
			Buffer.from(GetDiagnosticsRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): GetDiagnosticsRequest =>
			GetDiagnosticsRequest.decode(value),
		responseSerialize: (value: GetDiagnosticsResponse): Buffer =>
			Buffer.from(GetDiagnosticsResponse.encode(value).finish()),
		responseDeserialize: (value: Buffer): GetDiagnosticsResponse =>
			GetDiagnosticsResponse.decode(value),
	},
	/** Makes the problems panel/pane visible in the IDE and focuses it. */
	openProblemsPanel: {
		path: "/host.WorkspaceService/openProblemsPanel",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: OpenProblemsPanelRequest): Buffer =>
			Buffer.from(OpenProblemsPanelRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): OpenProblemsPanelRequest =>
			OpenProblemsPanelRequest.decode(value),
		responseSerialize: (value: OpenProblemsPanelResponse): Buffer =>
			Buffer.from(OpenProblemsPanelResponse.encode(value).finish()),
		responseDeserialize: (value: Buffer): OpenProblemsPanelResponse =>
			OpenProblemsPanelResponse.decode(value),
	},
	/** Opens the IDE file explorer panel and selects a file or directory. */
	openInFileExplorerPanel: {
		path: "/host.WorkspaceService/openInFileExplorerPanel",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: OpenInFileExplorerPanelRequest): Buffer =>
			Buffer.from(OpenInFileExplorerPanelRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): OpenInFileExplorerPanelRequest =>
			OpenInFileExplorerPanelRequest.decode(value),
		responseSerialize: (value: OpenInFileExplorerPanelResponse): Buffer =>
			Buffer.from(OpenInFileExplorerPanelResponse.encode(value).finish()),
		responseDeserialize: (value: Buffer): OpenInFileExplorerPanelResponse =>
			OpenInFileExplorerPanelResponse.decode(value),
	},
	/** Opens and focuses the Cline sidebar panel in the host IDE. */
	openClineSidebarPanel: {
		path: "/host.WorkspaceService/openClineSidebarPanel",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: OpenClineSidebarPanelRequest): Buffer =>
			Buffer.from(OpenClineSidebarPanelRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): OpenClineSidebarPanelRequest =>
			OpenClineSidebarPanelRequest.decode(value),
		responseSerialize: (value: OpenClineSidebarPanelResponse): Buffer =>
			Buffer.from(OpenClineSidebarPanelResponse.encode(value).finish()),
		responseDeserialize: (value: Buffer): OpenClineSidebarPanelResponse =>
			OpenClineSidebarPanelResponse.decode(value),
	},
	/** Opens and focuses the terminal panel. */
	openTerminalPanel: {
		path: "/host.WorkspaceService/openTerminalPanel",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: OpenTerminalRequest): Buffer =>
			Buffer.from(OpenTerminalRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): OpenTerminalRequest =>
			OpenTerminalRequest.decode(value),
		responseSerialize: (value: OpenTerminalResponse): Buffer =>
			Buffer.from(OpenTerminalResponse.encode(value).finish()),
		responseDeserialize: (value: Buffer): OpenTerminalResponse =>
			OpenTerminalResponse.decode(value),
	},
	/** Executes a command in a new terminal */
	executeCommandInTerminal: {
		path: "/host.WorkspaceService/executeCommandInTerminal",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: ExecuteCommandInTerminalRequest): Buffer =>
			Buffer.from(ExecuteCommandInTerminalRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): ExecuteCommandInTerminalRequest =>
			ExecuteCommandInTerminalRequest.decode(value),
		responseSerialize: (value: ExecuteCommandInTerminalResponse): Buffer =>
			Buffer.from(ExecuteCommandInTerminalResponse.encode(value).finish()),
		responseDeserialize: (value: Buffer): ExecuteCommandInTerminalResponse =>
			ExecuteCommandInTerminalResponse.decode(value),
	},
	/** Opens a folder/workspace in the IDE */
	openFolder: {
		path: "/host.WorkspaceService/openFolder",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: OpenFolderRequest): Buffer =>
			Buffer.from(OpenFolderRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): OpenFolderRequest =>
			OpenFolderRequest.decode(value),
		responseSerialize: (value: OpenFolderResponse): Buffer =>
			Buffer.from(OpenFolderResponse.encode(value).finish()),
		responseDeserialize: (value: Buffer): OpenFolderResponse =>
			OpenFolderResponse.decode(value),
	},
} as const;

export interface WorkspaceServiceServer extends UntypedServiceImplementation {
	/** Returns a list of the top level directories of the workspace. */
	getWorkspacePaths: handleUnaryCall<
		GetWorkspacePathsRequest,
		GetWorkspacePathsResponse
	>;
	/**
	 * Saves an open document if it's open in the editor and has unsaved changes.
	 * Returns true if the document was saved, returns false if the document was not found, or did not
	 * need to be saved.
	 */
	saveOpenDocumentIfDirty: handleUnaryCall<
		SaveOpenDocumentIfDirtyRequest,
		SaveOpenDocumentIfDirtyResponse
	>;
	/** Get diagnostics from the workspace. */
	getDiagnostics: handleUnaryCall<
		GetDiagnosticsRequest,
		GetDiagnosticsResponse
	>;
	/** Makes the problems panel/pane visible in the IDE and focuses it. */
	openProblemsPanel: handleUnaryCall<
		OpenProblemsPanelRequest,
		OpenProblemsPanelResponse
	>;
	/** Opens the IDE file explorer panel and selects a file or directory. */
	openInFileExplorerPanel: handleUnaryCall<
		OpenInFileExplorerPanelRequest,
		OpenInFileExplorerPanelResponse
	>;
	/** Opens and focuses the Cline sidebar panel in the host IDE. */
	openClineSidebarPanel: handleUnaryCall<
		OpenClineSidebarPanelRequest,
		OpenClineSidebarPanelResponse
	>;
	/** Opens and focuses the terminal panel. */
	openTerminalPanel: handleUnaryCall<OpenTerminalRequest, OpenTerminalResponse>;
	/** Executes a command in a new terminal */
	executeCommandInTerminal: handleUnaryCall<
		ExecuteCommandInTerminalRequest,
		ExecuteCommandInTerminalResponse
	>;
	/** Opens a folder/workspace in the IDE */
	openFolder: handleUnaryCall<OpenFolderRequest, OpenFolderResponse>;
}

export interface WorkspaceServiceClient extends Client {
	/** Returns a list of the top level directories of the workspace. */
	getWorkspacePaths(
		request: GetWorkspacePathsRequest,
		callback: (
			error: ServiceError | null,
			response: GetWorkspacePathsResponse,
		) => void,
	): ClientUnaryCall;
	getWorkspacePaths(
		request: GetWorkspacePathsRequest,
		metadata: Metadata,
		callback: (
			error: ServiceError | null,
			response: GetWorkspacePathsResponse,
		) => void,
	): ClientUnaryCall;
	getWorkspacePaths(
		request: GetWorkspacePathsRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (
			error: ServiceError | null,
			response: GetWorkspacePathsResponse,
		) => void,
	): ClientUnaryCall;
	/**
	 * Saves an open document if it's open in the editor and has unsaved changes.
	 * Returns true if the document was saved, returns false if the document was not found, or did not
	 * need to be saved.
	 */
	saveOpenDocumentIfDirty(
		request: SaveOpenDocumentIfDirtyRequest,
		callback: (
			error: ServiceError | null,
			response: SaveOpenDocumentIfDirtyResponse,
		) => void,
	): ClientUnaryCall;
	saveOpenDocumentIfDirty(
		request: SaveOpenDocumentIfDirtyRequest,
		metadata: Metadata,
		callback: (
			error: ServiceError | null,
			response: SaveOpenDocumentIfDirtyResponse,
		) => void,
	): ClientUnaryCall;
	saveOpenDocumentIfDirty(
		request: SaveOpenDocumentIfDirtyRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (
			error: ServiceError | null,
			response: SaveOpenDocumentIfDirtyResponse,
		) => void,
	): ClientUnaryCall;
	/** Get diagnostics from the workspace. */
	getDiagnostics(
		request: GetDiagnosticsRequest,
		callback: (
			error: ServiceError | null,
			response: GetDiagnosticsResponse,
		) => void,
	): ClientUnaryCall;
	getDiagnostics(
		request: GetDiagnosticsRequest,
		metadata: Metadata,
		callback: (
			error: ServiceError | null,
			response: GetDiagnosticsResponse,
		) => void,
	): ClientUnaryCall;
	getDiagnostics(
		request: GetDiagnosticsRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (
			error: ServiceError | null,
			response: GetDiagnosticsResponse,
		) => void,
	): ClientUnaryCall;
	/** Makes the problems panel/pane visible in the IDE and focuses it. */
	openProblemsPanel(
		request: OpenProblemsPanelRequest,
		callback: (
			error: ServiceError | null,
			response: OpenProblemsPanelResponse,
		) => void,
	): ClientUnaryCall;
	openProblemsPanel(
		request: OpenProblemsPanelRequest,
		metadata: Metadata,
		callback: (
			error: ServiceError | null,
			response: OpenProblemsPanelResponse,
		) => void,
	): ClientUnaryCall;
	openProblemsPanel(
		request: OpenProblemsPanelRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (
			error: ServiceError | null,
			response: OpenProblemsPanelResponse,
		) => void,
	): ClientUnaryCall;
	/** Opens the IDE file explorer panel and selects a file or directory. */
	openInFileExplorerPanel(
		request: OpenInFileExplorerPanelRequest,
		callback: (
			error: ServiceError | null,
			response: OpenInFileExplorerPanelResponse,
		) => void,
	): ClientUnaryCall;
	openInFileExplorerPanel(
		request: OpenInFileExplorerPanelRequest,
		metadata: Metadata,
		callback: (
			error: ServiceError | null,
			response: OpenInFileExplorerPanelResponse,
		) => void,
	): ClientUnaryCall;
	openInFileExplorerPanel(
		request: OpenInFileExplorerPanelRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (
			error: ServiceError | null,
			response: OpenInFileExplorerPanelResponse,
		) => void,
	): ClientUnaryCall;
	/** Opens and focuses the Cline sidebar panel in the host IDE. */
	openClineSidebarPanel(
		request: OpenClineSidebarPanelRequest,
		callback: (
			error: ServiceError | null,
			response: OpenClineSidebarPanelResponse,
		) => void,
	): ClientUnaryCall;
	openClineSidebarPanel(
		request: OpenClineSidebarPanelRequest,
		metadata: Metadata,
		callback: (
			error: ServiceError | null,
			response: OpenClineSidebarPanelResponse,
		) => void,
	): ClientUnaryCall;
	openClineSidebarPanel(
		request: OpenClineSidebarPanelRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (
			error: ServiceError | null,
			response: OpenClineSidebarPanelResponse,
		) => void,
	): ClientUnaryCall;
	/** Opens and focuses the terminal panel. */
	openTerminalPanel(
		request: OpenTerminalRequest,
		callback: (
			error: ServiceError | null,
			response: OpenTerminalResponse,
		) => void,
	): ClientUnaryCall;
	openTerminalPanel(
		request: OpenTerminalRequest,
		metadata: Metadata,
		callback: (
			error: ServiceError | null,
			response: OpenTerminalResponse,
		) => void,
	): ClientUnaryCall;
	openTerminalPanel(
		request: OpenTerminalRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (
			error: ServiceError | null,
			response: OpenTerminalResponse,
		) => void,
	): ClientUnaryCall;
	/** Executes a command in a new terminal */
	executeCommandInTerminal(
		request: ExecuteCommandInTerminalRequest,
		callback: (
			error: ServiceError | null,
			response: ExecuteCommandInTerminalResponse,
		) => void,
	): ClientUnaryCall;
	executeCommandInTerminal(
		request: ExecuteCommandInTerminalRequest,
		metadata: Metadata,
		callback: (
			error: ServiceError | null,
			response: ExecuteCommandInTerminalResponse,
		) => void,
	): ClientUnaryCall;
	executeCommandInTerminal(
		request: ExecuteCommandInTerminalRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (
			error: ServiceError | null,
			response: ExecuteCommandInTerminalResponse,
		) => void,
	): ClientUnaryCall;
	/** Opens a folder/workspace in the IDE */
	openFolder(
		request: OpenFolderRequest,
		callback: (
			error: ServiceError | null,
			response: OpenFolderResponse,
		) => void,
	): ClientUnaryCall;
	openFolder(
		request: OpenFolderRequest,
		metadata: Metadata,
		callback: (
			error: ServiceError | null,
			response: OpenFolderResponse,
		) => void,
	): ClientUnaryCall;
	openFolder(
		request: OpenFolderRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (
			error: ServiceError | null,
			response: OpenFolderResponse,
		) => void,
	): ClientUnaryCall;
}

export const WorkspaceServiceClient = makeGenericClientConstructor(
	WorkspaceServiceService,
	"host.WorkspaceService",
) as unknown as {
	new (
		address: string,
		credentials: ChannelCredentials,
		options?: Partial<ClientOptions>,
	): WorkspaceServiceClient;
	service: typeof WorkspaceServiceService;
	serviceName: string;
};

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & {
			[K in Exclude<keyof I, KeysOfUnion<P>>]: never;
		};

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

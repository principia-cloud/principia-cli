// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: host/testing.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
	type CallOptions,
	type ChannelCredentials,
	Client,
	type ClientOptions,
	type ClientUnaryCall,
	type handleUnaryCall,
	makeGenericClientConstructor,
	type Metadata,
	type ServiceError,
	type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export interface GetWebviewHtmlRequest {}

export interface GetWebviewHtmlResponse {
	html?: string | undefined;
}

function createBaseGetWebviewHtmlRequest(): GetWebviewHtmlRequest {
	return {};
}

export const GetWebviewHtmlRequest: MessageFns<GetWebviewHtmlRequest> = {
	encode(
		_: GetWebviewHtmlRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): GetWebviewHtmlRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseGetWebviewHtmlRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(_: any): GetWebviewHtmlRequest {
		return {};
	},

	toJSON(_: GetWebviewHtmlRequest): unknown {
		const obj: any = {};
		return obj;
	},

	create<I extends Exact<DeepPartial<GetWebviewHtmlRequest>, I>>(
		base?: I,
	): GetWebviewHtmlRequest {
		return GetWebviewHtmlRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<GetWebviewHtmlRequest>, I>>(
		_: I,
	): GetWebviewHtmlRequest {
		const message = createBaseGetWebviewHtmlRequest();
		return message;
	},
};

function createBaseGetWebviewHtmlResponse(): GetWebviewHtmlResponse {
	return { html: undefined };
}

export const GetWebviewHtmlResponse: MessageFns<GetWebviewHtmlResponse> = {
	encode(
		message: GetWebviewHtmlResponse,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.html !== undefined) {
			writer.uint32(10).string(message.html);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): GetWebviewHtmlResponse {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseGetWebviewHtmlResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.html = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): GetWebviewHtmlResponse {
		return {
			html: isSet(object.html) ? globalThis.String(object.html) : undefined,
		};
	},

	toJSON(message: GetWebviewHtmlResponse): unknown {
		const obj: any = {};
		if (message.html !== undefined) {
			obj.html = message.html;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<GetWebviewHtmlResponse>, I>>(
		base?: I,
	): GetWebviewHtmlResponse {
		return GetWebviewHtmlResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<GetWebviewHtmlResponse>, I>>(
		object: I,
	): GetWebviewHtmlResponse {
		const message = createBaseGetWebviewHtmlResponse();
		message.html = object.html ?? undefined;
		return message;
	},
};

/** This is for use in integration tests to get the contents of the webview. */
export type TestingServiceDefinition = typeof TestingServiceDefinition;
export const TestingServiceDefinition = {
	name: "TestingService",
	fullName: "host.TestingService",
	methods: {
		getWebviewHtml: {
			name: "getWebviewHtml",
			requestType: GetWebviewHtmlRequest,
			requestStream: false,
			responseType: GetWebviewHtmlResponse,
			responseStream: false,
			options: {},
		},
	},
} as const;

/** This is for use in integration tests to get the contents of the webview. */
export type TestingServiceService = typeof TestingServiceService;
export const TestingServiceService = {
	getWebviewHtml: {
		path: "/host.TestingService/getWebviewHtml",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: GetWebviewHtmlRequest): Buffer =>
			Buffer.from(GetWebviewHtmlRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): GetWebviewHtmlRequest =>
			GetWebviewHtmlRequest.decode(value),
		responseSerialize: (value: GetWebviewHtmlResponse): Buffer =>
			Buffer.from(GetWebviewHtmlResponse.encode(value).finish()),
		responseDeserialize: (value: Buffer): GetWebviewHtmlResponse =>
			GetWebviewHtmlResponse.decode(value),
	},
} as const;

export interface TestingServiceServer extends UntypedServiceImplementation {
	getWebviewHtml: handleUnaryCall<
		GetWebviewHtmlRequest,
		GetWebviewHtmlResponse
	>;
}

export interface TestingServiceClient extends Client {
	getWebviewHtml(
		request: GetWebviewHtmlRequest,
		callback: (
			error: ServiceError | null,
			response: GetWebviewHtmlResponse,
		) => void,
	): ClientUnaryCall;
	getWebviewHtml(
		request: GetWebviewHtmlRequest,
		metadata: Metadata,
		callback: (
			error: ServiceError | null,
			response: GetWebviewHtmlResponse,
		) => void,
	): ClientUnaryCall;
	getWebviewHtml(
		request: GetWebviewHtmlRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (
			error: ServiceError | null,
			response: GetWebviewHtmlResponse,
		) => void,
	): ClientUnaryCall;
}

export const TestingServiceClient = makeGenericClientConstructor(
	TestingServiceService,
	"host.TestingService",
) as unknown as {
	new (
		address: string,
		credentials: ChannelCredentials,
		options?: Partial<ClientOptions>,
	): TestingServiceClient;
	service: typeof TestingServiceService;
	serviceName: string;
};

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & {
			[K in Exclude<keyof I, KeysOfUnion<P>>]: never;
		};

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

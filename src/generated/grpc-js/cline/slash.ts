// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: cline/slash.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
	type CallOptions,
	type ChannelCredentials,
	Client,
	type ClientOptions,
	type ClientUnaryCall,
	type handleUnaryCall,
	makeGenericClientConstructor,
	type Metadata,
	type ServiceError,
	type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty, EmptyRequest, StringRequest } from "./common";

/** Slash command definition for autocomplete */
export interface SlashCommandInfo {
	/** Command name without slash, e.g., "newtask", "smol" */
	name: string;
	/** Human-readable description */
	description: string;
	/** "default", "custom", or "cli" */
	section: string;
	/** false for VS Code-only commands like explain-changes */
	cliCompatible: boolean;
}

/** Response containing all available slash commands */
export interface SlashCommandsResponse {
	commands: SlashCommandInfo[];
}

function createBaseSlashCommandInfo(): SlashCommandInfo {
	return { name: "", description: "", section: "", cliCompatible: false };
}

export const SlashCommandInfo: MessageFns<SlashCommandInfo> = {
	encode(
		message: SlashCommandInfo,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.name !== "") {
			writer.uint32(10).string(message.name);
		}
		if (message.description !== "") {
			writer.uint32(18).string(message.description);
		}
		if (message.section !== "") {
			writer.uint32(26).string(message.section);
		}
		if (message.cliCompatible !== false) {
			writer.uint32(32).bool(message.cliCompatible);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SlashCommandInfo {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseSlashCommandInfo();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.name = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.description = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.section = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.cliCompatible = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): SlashCommandInfo {
		return {
			name: isSet(object.name) ? globalThis.String(object.name) : "",
			description: isSet(object.description)
				? globalThis.String(object.description)
				: "",
			section: isSet(object.section) ? globalThis.String(object.section) : "",
			cliCompatible: isSet(object.cliCompatible)
				? globalThis.Boolean(object.cliCompatible)
				: isSet(object.cli_compatible)
					? globalThis.Boolean(object.cli_compatible)
					: false,
		};
	},

	toJSON(message: SlashCommandInfo): unknown {
		const obj: any = {};
		if (message.name !== "") {
			obj.name = message.name;
		}
		if (message.description !== "") {
			obj.description = message.description;
		}
		if (message.section !== "") {
			obj.section = message.section;
		}
		if (message.cliCompatible !== false) {
			obj.cliCompatible = message.cliCompatible;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<SlashCommandInfo>, I>>(
		base?: I,
	): SlashCommandInfo {
		return SlashCommandInfo.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<SlashCommandInfo>, I>>(
		object: I,
	): SlashCommandInfo {
		const message = createBaseSlashCommandInfo();
		message.name = object.name ?? "";
		message.description = object.description ?? "";
		message.section = object.section ?? "";
		message.cliCompatible = object.cliCompatible ?? false;
		return message;
	},
};

function createBaseSlashCommandsResponse(): SlashCommandsResponse {
	return { commands: [] };
}

export const SlashCommandsResponse: MessageFns<SlashCommandsResponse> = {
	encode(
		message: SlashCommandsResponse,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		for (const v of message.commands) {
			SlashCommandInfo.encode(v!, writer.uint32(10).fork()).join();
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): SlashCommandsResponse {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseSlashCommandsResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.commands.push(
						SlashCommandInfo.decode(reader, reader.uint32()),
					);
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): SlashCommandsResponse {
		return {
			commands: globalThis.Array.isArray(object?.commands)
				? object.commands.map((e: any) => SlashCommandInfo.fromJSON(e))
				: [],
		};
	},

	toJSON(message: SlashCommandsResponse): unknown {
		const obj: any = {};
		if (message.commands?.length) {
			obj.commands = message.commands.map((e) => SlashCommandInfo.toJSON(e));
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<SlashCommandsResponse>, I>>(
		base?: I,
	): SlashCommandsResponse {
		return SlashCommandsResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<SlashCommandsResponse>, I>>(
		object: I,
	): SlashCommandsResponse {
		const message = createBaseSlashCommandsResponse();
		message.commands =
			object.commands?.map((e) => SlashCommandInfo.fromPartial(e)) || [];
		return message;
	},
};

/** SlashService provides methods for managing slash commands */
export type SlashServiceDefinition = typeof SlashServiceDefinition;
export const SlashServiceDefinition = {
	name: "SlashService",
	fullName: "cline.SlashService",
	methods: {
		/** Sends button click message */
		reportBug: {
			name: "reportBug",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		condense: {
			name: "condense",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/** Get available slash commands for autocomplete (used by CLI) */
		getAvailableSlashCommands: {
			name: "getAvailableSlashCommands",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: SlashCommandsResponse,
			responseStream: false,
			options: {},
		},
	},
} as const;

/** SlashService provides methods for managing slash commands */
export type SlashServiceService = typeof SlashServiceService;
export const SlashServiceService = {
	/** Sends button click message */
	reportBug: {
		path: "/cline.SlashService/reportBug",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: StringRequest): Buffer =>
			Buffer.from(StringRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): StringRequest =>
			StringRequest.decode(value),
		responseSerialize: (value: Empty): Buffer =>
			Buffer.from(Empty.encode(value).finish()),
		responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
	},
	condense: {
		path: "/cline.SlashService/condense",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: StringRequest): Buffer =>
			Buffer.from(StringRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): StringRequest =>
			StringRequest.decode(value),
		responseSerialize: (value: Empty): Buffer =>
			Buffer.from(Empty.encode(value).finish()),
		responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
	},
	/** Get available slash commands for autocomplete (used by CLI) */
	getAvailableSlashCommands: {
		path: "/cline.SlashService/getAvailableSlashCommands",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: EmptyRequest): Buffer =>
			Buffer.from(EmptyRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): EmptyRequest =>
			EmptyRequest.decode(value),
		responseSerialize: (value: SlashCommandsResponse): Buffer =>
			Buffer.from(SlashCommandsResponse.encode(value).finish()),
		responseDeserialize: (value: Buffer): SlashCommandsResponse =>
			SlashCommandsResponse.decode(value),
	},
} as const;

export interface SlashServiceServer extends UntypedServiceImplementation {
	/** Sends button click message */
	reportBug: handleUnaryCall<StringRequest, Empty>;
	condense: handleUnaryCall<StringRequest, Empty>;
	/** Get available slash commands for autocomplete (used by CLI) */
	getAvailableSlashCommands: handleUnaryCall<
		EmptyRequest,
		SlashCommandsResponse
	>;
}

export interface SlashServiceClient extends Client {
	/** Sends button click message */
	reportBug(
		request: StringRequest,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
	reportBug(
		request: StringRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
	reportBug(
		request: StringRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
	condense(
		request: StringRequest,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
	condense(
		request: StringRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
	condense(
		request: StringRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
	/** Get available slash commands for autocomplete (used by CLI) */
	getAvailableSlashCommands(
		request: EmptyRequest,
		callback: (
			error: ServiceError | null,
			response: SlashCommandsResponse,
		) => void,
	): ClientUnaryCall;
	getAvailableSlashCommands(
		request: EmptyRequest,
		metadata: Metadata,
		callback: (
			error: ServiceError | null,
			response: SlashCommandsResponse,
		) => void,
	): ClientUnaryCall;
	getAvailableSlashCommands(
		request: EmptyRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (
			error: ServiceError | null,
			response: SlashCommandsResponse,
		) => void,
	): ClientUnaryCall;
}

export const SlashServiceClient = makeGenericClientConstructor(
	SlashServiceService,
	"cline.SlashService",
) as unknown as {
	new (
		address: string,
		credentials: ChannelCredentials,
		options?: Partial<ClientOptions>,
	): SlashServiceClient;
	service: typeof SlashServiceService;
	serviceName: string;
};

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & {
			[K in Exclude<keyof I, KeysOfUnion<P>>]: never;
		};

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

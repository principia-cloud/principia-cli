// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: cline/worktree.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
	type CallOptions,
	type ChannelCredentials,
	Client,
	type ClientOptions,
	type ClientUnaryCall,
	type handleUnaryCall,
	makeGenericClientConstructor,
	type Metadata,
	type ServiceError,
	type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty, EmptyRequest, Metadata as Metadata1 } from "./common";

/** Represents a single git worktree */
export interface Worktree {
	/** Absolute path to the worktree */
	path: string;
	/** Branch name (empty if detached) */
	branch: string;
	/** Current commit hash */
	commitHash: string;
	/** Whether this is the current worktree */
	isCurrent: boolean;
	/** Whether this is the bare repository */
	isBare: boolean;
	/** Whether HEAD is detached */
	isDetached: boolean;
	/** Whether the worktree is locked */
	isLocked: boolean;
	/** Reason for lock if locked */
	lockReason?: string | undefined;
}

/** Response containing list of worktrees */
export interface WorktreeList {
	worktrees: Worktree[];
	/** Whether the current workspace is a git repo */
	isGitRepo: boolean;
	/** Error message if any */
	error: string;
	/** Whether multiple workspace folders are open (worktrees not supported) */
	isMultiRoot: boolean;
	/** Whether workspace is a subfolder of a git repo (not at repo root) */
	isSubfolder: boolean;
	/** The actual git root path (useful when is_subfolder is true) */
	gitRootPath: string;
}

/** Request to create a new worktree */
export interface CreateWorktreeRequest {
	metadata: Metadata1 | undefined;
	/** Path for the new worktree */
	path: string;
	/** Branch name (creates new if doesn't exist) */
	branch?: string | undefined;
	/** Base branch for new branch creation */
	baseBranch?: string | undefined;
	/** Whether to create a new branch */
	createNewBranch: boolean;
}

/** Request to delete a worktree */
export interface DeleteWorktreeRequest {
	metadata: Metadata1 | undefined;
	/** Path of the worktree to delete */
	path: string;
	/** Force deletion even if dirty */
	force: boolean;
	/** Also delete the branch */
	deleteBranch: boolean;
	/** Name of the branch to delete (required if delete_branch is true) */
	branchName: string;
}

/** Request to switch to a worktree */
export interface SwitchWorktreeRequest {
	metadata: Metadata1 | undefined;
	/** Path of the worktree to switch to */
	path: string;
	/** Whether to open in a new window */
	newWindow: boolean;
}

/** Result of worktree operations */
export interface WorktreeResult {
	success: boolean;
	/** Success or error message */
	message: string;
	/** The affected worktree (for create) */
	worktree?: Worktree | undefined;
}

/** List of available branches */
export interface BranchList {
	localBranches: string[];
	remoteBranches: string[];
	currentBranch: string;
}

/** Suggested defaults for creating a new worktree */
export interface WorktreeDefaults {
	/** Auto-generated branch name like "worktree/cline-abc12" */
	suggestedBranch: string;
	/** Path in Documents/Cline/Worktrees/<project>-<suffix> */
	suggestedPath: string;
}

/** Status of .worktreeinclude file */
export interface WorktreeIncludeStatus {
	/** Whether .worktreeinclude exists */
	exists: boolean;
	/** Content of .gitignore (for prefilling) */
	gitignoreContent: string;
	/** Whether .gitignore exists */
	hasGitignore: boolean;
}

/** Request to create .worktreeinclude file */
export interface CreateWorktreeIncludeRequest {
	/** Content for the .worktreeinclude file */
	content: string;
}

/** Request to checkout a branch in the current worktree */
export interface CheckoutBranchRequest {
	metadata: Metadata1 | undefined;
	/** Branch name to checkout */
	branch: string;
}

/** Request to merge a worktree's branch into target branch */
export interface MergeWorktreeRequest {
	metadata: Metadata1 | undefined;
	/** Path of the worktree to merge */
	worktreePath: string;
	/** Branch to merge into (e.g., "main") */
	targetBranch: string;
	/** Whether to delete the worktree after successful merge */
	deleteAfterMerge: boolean;
}

/** Result of merge operation */
export interface MergeWorktreeResult {
	success: boolean;
	/** Success or error message */
	message: string;
	/** Whether merge resulted in conflicts */
	hasConflicts: boolean;
	/** List of files with conflicts */
	conflictingFiles: string[];
	/** The branch that was merged */
	sourceBranch: string;
	/** The branch merged into */
	targetBranch: string;
}

/** Request to track worktree view opened (for telemetry) */
export interface TrackWorktreeViewOpenedRequest {
	/** Where the view was opened from: "home_page" or "menu_bar" */
	source: string;
}

function createBaseWorktree(): Worktree {
	return {
		path: "",
		branch: "",
		commitHash: "",
		isCurrent: false,
		isBare: false,
		isDetached: false,
		isLocked: false,
		lockReason: undefined,
	};
}

export const Worktree: MessageFns<Worktree> = {
	encode(
		message: Worktree,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.path !== "") {
			writer.uint32(10).string(message.path);
		}
		if (message.branch !== "") {
			writer.uint32(18).string(message.branch);
		}
		if (message.commitHash !== "") {
			writer.uint32(26).string(message.commitHash);
		}
		if (message.isCurrent !== false) {
			writer.uint32(32).bool(message.isCurrent);
		}
		if (message.isBare !== false) {
			writer.uint32(40).bool(message.isBare);
		}
		if (message.isDetached !== false) {
			writer.uint32(48).bool(message.isDetached);
		}
		if (message.isLocked !== false) {
			writer.uint32(56).bool(message.isLocked);
		}
		if (message.lockReason !== undefined) {
			writer.uint32(66).string(message.lockReason);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Worktree {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseWorktree();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.path = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.branch = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.commitHash = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.isCurrent = reader.bool();
					continue;
				}
				case 5: {
					if (tag !== 40) {
						break;
					}

					message.isBare = reader.bool();
					continue;
				}
				case 6: {
					if (tag !== 48) {
						break;
					}

					message.isDetached = reader.bool();
					continue;
				}
				case 7: {
					if (tag !== 56) {
						break;
					}

					message.isLocked = reader.bool();
					continue;
				}
				case 8: {
					if (tag !== 66) {
						break;
					}

					message.lockReason = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Worktree {
		return {
			path: isSet(object.path) ? globalThis.String(object.path) : "",
			branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
			commitHash: isSet(object.commitHash)
				? globalThis.String(object.commitHash)
				: isSet(object.commit_hash)
					? globalThis.String(object.commit_hash)
					: "",
			isCurrent: isSet(object.isCurrent)
				? globalThis.Boolean(object.isCurrent)
				: isSet(object.is_current)
					? globalThis.Boolean(object.is_current)
					: false,
			isBare: isSet(object.isBare)
				? globalThis.Boolean(object.isBare)
				: isSet(object.is_bare)
					? globalThis.Boolean(object.is_bare)
					: false,
			isDetached: isSet(object.isDetached)
				? globalThis.Boolean(object.isDetached)
				: isSet(object.is_detached)
					? globalThis.Boolean(object.is_detached)
					: false,
			isLocked: isSet(object.isLocked)
				? globalThis.Boolean(object.isLocked)
				: isSet(object.is_locked)
					? globalThis.Boolean(object.is_locked)
					: false,
			lockReason: isSet(object.lockReason)
				? globalThis.String(object.lockReason)
				: isSet(object.lock_reason)
					? globalThis.String(object.lock_reason)
					: undefined,
		};
	},

	toJSON(message: Worktree): unknown {
		const obj: any = {};
		if (message.path !== "") {
			obj.path = message.path;
		}
		if (message.branch !== "") {
			obj.branch = message.branch;
		}
		if (message.commitHash !== "") {
			obj.commitHash = message.commitHash;
		}
		if (message.isCurrent !== false) {
			obj.isCurrent = message.isCurrent;
		}
		if (message.isBare !== false) {
			obj.isBare = message.isBare;
		}
		if (message.isDetached !== false) {
			obj.isDetached = message.isDetached;
		}
		if (message.isLocked !== false) {
			obj.isLocked = message.isLocked;
		}
		if (message.lockReason !== undefined) {
			obj.lockReason = message.lockReason;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Worktree>, I>>(base?: I): Worktree {
		return Worktree.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Worktree>, I>>(object: I): Worktree {
		const message = createBaseWorktree();
		message.path = object.path ?? "";
		message.branch = object.branch ?? "";
		message.commitHash = object.commitHash ?? "";
		message.isCurrent = object.isCurrent ?? false;
		message.isBare = object.isBare ?? false;
		message.isDetached = object.isDetached ?? false;
		message.isLocked = object.isLocked ?? false;
		message.lockReason = object.lockReason ?? undefined;
		return message;
	},
};

function createBaseWorktreeList(): WorktreeList {
	return {
		worktrees: [],
		isGitRepo: false,
		error: "",
		isMultiRoot: false,
		isSubfolder: false,
		gitRootPath: "",
	};
}

export const WorktreeList: MessageFns<WorktreeList> = {
	encode(
		message: WorktreeList,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		for (const v of message.worktrees) {
			Worktree.encode(v!, writer.uint32(10).fork()).join();
		}
		if (message.isGitRepo !== false) {
			writer.uint32(16).bool(message.isGitRepo);
		}
		if (message.error !== "") {
			writer.uint32(26).string(message.error);
		}
		if (message.isMultiRoot !== false) {
			writer.uint32(32).bool(message.isMultiRoot);
		}
		if (message.isSubfolder !== false) {
			writer.uint32(40).bool(message.isSubfolder);
		}
		if (message.gitRootPath !== "") {
			writer.uint32(50).string(message.gitRootPath);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): WorktreeList {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseWorktreeList();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.worktrees.push(Worktree.decode(reader, reader.uint32()));
					continue;
				}
				case 2: {
					if (tag !== 16) {
						break;
					}

					message.isGitRepo = reader.bool();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.error = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.isMultiRoot = reader.bool();
					continue;
				}
				case 5: {
					if (tag !== 40) {
						break;
					}

					message.isSubfolder = reader.bool();
					continue;
				}
				case 6: {
					if (tag !== 50) {
						break;
					}

					message.gitRootPath = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): WorktreeList {
		return {
			worktrees: globalThis.Array.isArray(object?.worktrees)
				? object.worktrees.map((e: any) => Worktree.fromJSON(e))
				: [],
			isGitRepo: isSet(object.isGitRepo)
				? globalThis.Boolean(object.isGitRepo)
				: isSet(object.is_git_repo)
					? globalThis.Boolean(object.is_git_repo)
					: false,
			error: isSet(object.error) ? globalThis.String(object.error) : "",
			isMultiRoot: isSet(object.isMultiRoot)
				? globalThis.Boolean(object.isMultiRoot)
				: isSet(object.is_multi_root)
					? globalThis.Boolean(object.is_multi_root)
					: false,
			isSubfolder: isSet(object.isSubfolder)
				? globalThis.Boolean(object.isSubfolder)
				: isSet(object.is_subfolder)
					? globalThis.Boolean(object.is_subfolder)
					: false,
			gitRootPath: isSet(object.gitRootPath)
				? globalThis.String(object.gitRootPath)
				: isSet(object.git_root_path)
					? globalThis.String(object.git_root_path)
					: "",
		};
	},

	toJSON(message: WorktreeList): unknown {
		const obj: any = {};
		if (message.worktrees?.length) {
			obj.worktrees = message.worktrees.map((e) => Worktree.toJSON(e));
		}
		if (message.isGitRepo !== false) {
			obj.isGitRepo = message.isGitRepo;
		}
		if (message.error !== "") {
			obj.error = message.error;
		}
		if (message.isMultiRoot !== false) {
			obj.isMultiRoot = message.isMultiRoot;
		}
		if (message.isSubfolder !== false) {
			obj.isSubfolder = message.isSubfolder;
		}
		if (message.gitRootPath !== "") {
			obj.gitRootPath = message.gitRootPath;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<WorktreeList>, I>>(
		base?: I,
	): WorktreeList {
		return WorktreeList.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<WorktreeList>, I>>(
		object: I,
	): WorktreeList {
		const message = createBaseWorktreeList();
		message.worktrees =
			object.worktrees?.map((e) => Worktree.fromPartial(e)) || [];
		message.isGitRepo = object.isGitRepo ?? false;
		message.error = object.error ?? "";
		message.isMultiRoot = object.isMultiRoot ?? false;
		message.isSubfolder = object.isSubfolder ?? false;
		message.gitRootPath = object.gitRootPath ?? "";
		return message;
	},
};

function createBaseCreateWorktreeRequest(): CreateWorktreeRequest {
	return {
		metadata: undefined,
		path: "",
		branch: undefined,
		baseBranch: undefined,
		createNewBranch: false,
	};
}

export const CreateWorktreeRequest: MessageFns<CreateWorktreeRequest> = {
	encode(
		message: CreateWorktreeRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata1.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.path !== "") {
			writer.uint32(18).string(message.path);
		}
		if (message.branch !== undefined) {
			writer.uint32(26).string(message.branch);
		}
		if (message.baseBranch !== undefined) {
			writer.uint32(34).string(message.baseBranch);
		}
		if (message.createNewBranch !== false) {
			writer.uint32(40).bool(message.createNewBranch);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): CreateWorktreeRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseCreateWorktreeRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata1.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.path = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.branch = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.baseBranch = reader.string();
					continue;
				}
				case 5: {
					if (tag !== 40) {
						break;
					}

					message.createNewBranch = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): CreateWorktreeRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata1.fromJSON(object.metadata)
				: undefined,
			path: isSet(object.path) ? globalThis.String(object.path) : "",
			branch: isSet(object.branch)
				? globalThis.String(object.branch)
				: undefined,
			baseBranch: isSet(object.baseBranch)
				? globalThis.String(object.baseBranch)
				: isSet(object.base_branch)
					? globalThis.String(object.base_branch)
					: undefined,
			createNewBranch: isSet(object.createNewBranch)
				? globalThis.Boolean(object.createNewBranch)
				: isSet(object.create_new_branch)
					? globalThis.Boolean(object.create_new_branch)
					: false,
		};
	},

	toJSON(message: CreateWorktreeRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata1.toJSON(message.metadata);
		}
		if (message.path !== "") {
			obj.path = message.path;
		}
		if (message.branch !== undefined) {
			obj.branch = message.branch;
		}
		if (message.baseBranch !== undefined) {
			obj.baseBranch = message.baseBranch;
		}
		if (message.createNewBranch !== false) {
			obj.createNewBranch = message.createNewBranch;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<CreateWorktreeRequest>, I>>(
		base?: I,
	): CreateWorktreeRequest {
		return CreateWorktreeRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<CreateWorktreeRequest>, I>>(
		object: I,
	): CreateWorktreeRequest {
		const message = createBaseCreateWorktreeRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata1.fromPartial(object.metadata)
				: undefined;
		message.path = object.path ?? "";
		message.branch = object.branch ?? undefined;
		message.baseBranch = object.baseBranch ?? undefined;
		message.createNewBranch = object.createNewBranch ?? false;
		return message;
	},
};

function createBaseDeleteWorktreeRequest(): DeleteWorktreeRequest {
	return {
		metadata: undefined,
		path: "",
		force: false,
		deleteBranch: false,
		branchName: "",
	};
}

export const DeleteWorktreeRequest: MessageFns<DeleteWorktreeRequest> = {
	encode(
		message: DeleteWorktreeRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata1.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.path !== "") {
			writer.uint32(18).string(message.path);
		}
		if (message.force !== false) {
			writer.uint32(24).bool(message.force);
		}
		if (message.deleteBranch !== false) {
			writer.uint32(32).bool(message.deleteBranch);
		}
		if (message.branchName !== "") {
			writer.uint32(42).string(message.branchName);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): DeleteWorktreeRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseDeleteWorktreeRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata1.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.path = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.force = reader.bool();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.deleteBranch = reader.bool();
					continue;
				}
				case 5: {
					if (tag !== 42) {
						break;
					}

					message.branchName = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): DeleteWorktreeRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata1.fromJSON(object.metadata)
				: undefined,
			path: isSet(object.path) ? globalThis.String(object.path) : "",
			force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
			deleteBranch: isSet(object.deleteBranch)
				? globalThis.Boolean(object.deleteBranch)
				: isSet(object.delete_branch)
					? globalThis.Boolean(object.delete_branch)
					: false,
			branchName: isSet(object.branchName)
				? globalThis.String(object.branchName)
				: isSet(object.branch_name)
					? globalThis.String(object.branch_name)
					: "",
		};
	},

	toJSON(message: DeleteWorktreeRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata1.toJSON(message.metadata);
		}
		if (message.path !== "") {
			obj.path = message.path;
		}
		if (message.force !== false) {
			obj.force = message.force;
		}
		if (message.deleteBranch !== false) {
			obj.deleteBranch = message.deleteBranch;
		}
		if (message.branchName !== "") {
			obj.branchName = message.branchName;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<DeleteWorktreeRequest>, I>>(
		base?: I,
	): DeleteWorktreeRequest {
		return DeleteWorktreeRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<DeleteWorktreeRequest>, I>>(
		object: I,
	): DeleteWorktreeRequest {
		const message = createBaseDeleteWorktreeRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata1.fromPartial(object.metadata)
				: undefined;
		message.path = object.path ?? "";
		message.force = object.force ?? false;
		message.deleteBranch = object.deleteBranch ?? false;
		message.branchName = object.branchName ?? "";
		return message;
	},
};

function createBaseSwitchWorktreeRequest(): SwitchWorktreeRequest {
	return { metadata: undefined, path: "", newWindow: false };
}

export const SwitchWorktreeRequest: MessageFns<SwitchWorktreeRequest> = {
	encode(
		message: SwitchWorktreeRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata1.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.path !== "") {
			writer.uint32(18).string(message.path);
		}
		if (message.newWindow !== false) {
			writer.uint32(24).bool(message.newWindow);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): SwitchWorktreeRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseSwitchWorktreeRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata1.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.path = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.newWindow = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): SwitchWorktreeRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata1.fromJSON(object.metadata)
				: undefined,
			path: isSet(object.path) ? globalThis.String(object.path) : "",
			newWindow: isSet(object.newWindow)
				? globalThis.Boolean(object.newWindow)
				: isSet(object.new_window)
					? globalThis.Boolean(object.new_window)
					: false,
		};
	},

	toJSON(message: SwitchWorktreeRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata1.toJSON(message.metadata);
		}
		if (message.path !== "") {
			obj.path = message.path;
		}
		if (message.newWindow !== false) {
			obj.newWindow = message.newWindow;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<SwitchWorktreeRequest>, I>>(
		base?: I,
	): SwitchWorktreeRequest {
		return SwitchWorktreeRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<SwitchWorktreeRequest>, I>>(
		object: I,
	): SwitchWorktreeRequest {
		const message = createBaseSwitchWorktreeRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata1.fromPartial(object.metadata)
				: undefined;
		message.path = object.path ?? "";
		message.newWindow = object.newWindow ?? false;
		return message;
	},
};

function createBaseWorktreeResult(): WorktreeResult {
	return { success: false, message: "", worktree: undefined };
}

export const WorktreeResult: MessageFns<WorktreeResult> = {
	encode(
		message: WorktreeResult,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.success !== false) {
			writer.uint32(8).bool(message.success);
		}
		if (message.message !== "") {
			writer.uint32(18).string(message.message);
		}
		if (message.worktree !== undefined) {
			Worktree.encode(message.worktree, writer.uint32(26).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): WorktreeResult {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseWorktreeResult();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.success = reader.bool();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.message = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.worktree = Worktree.decode(reader, reader.uint32());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): WorktreeResult {
		return {
			success: isSet(object.success)
				? globalThis.Boolean(object.success)
				: false,
			message: isSet(object.message) ? globalThis.String(object.message) : "",
			worktree: isSet(object.worktree)
				? Worktree.fromJSON(object.worktree)
				: undefined,
		};
	},

	toJSON(message: WorktreeResult): unknown {
		const obj: any = {};
		if (message.success !== false) {
			obj.success = message.success;
		}
		if (message.message !== "") {
			obj.message = message.message;
		}
		if (message.worktree !== undefined) {
			obj.worktree = Worktree.toJSON(message.worktree);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<WorktreeResult>, I>>(
		base?: I,
	): WorktreeResult {
		return WorktreeResult.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<WorktreeResult>, I>>(
		object: I,
	): WorktreeResult {
		const message = createBaseWorktreeResult();
		message.success = object.success ?? false;
		message.message = object.message ?? "";
		message.worktree =
			object.worktree !== undefined && object.worktree !== null
				? Worktree.fromPartial(object.worktree)
				: undefined;
		return message;
	},
};

function createBaseBranchList(): BranchList {
	return { localBranches: [], remoteBranches: [], currentBranch: "" };
}

export const BranchList: MessageFns<BranchList> = {
	encode(
		message: BranchList,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		for (const v of message.localBranches) {
			writer.uint32(10).string(v!);
		}
		for (const v of message.remoteBranches) {
			writer.uint32(18).string(v!);
		}
		if (message.currentBranch !== "") {
			writer.uint32(26).string(message.currentBranch);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): BranchList {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseBranchList();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.localBranches.push(reader.string());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.remoteBranches.push(reader.string());
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.currentBranch = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): BranchList {
		return {
			localBranches: globalThis.Array.isArray(object?.localBranches)
				? object.localBranches.map((e: any) => globalThis.String(e))
				: globalThis.Array.isArray(object?.local_branches)
					? object.local_branches.map((e: any) => globalThis.String(e))
					: [],
			remoteBranches: globalThis.Array.isArray(object?.remoteBranches)
				? object.remoteBranches.map((e: any) => globalThis.String(e))
				: globalThis.Array.isArray(object?.remote_branches)
					? object.remote_branches.map((e: any) => globalThis.String(e))
					: [],
			currentBranch: isSet(object.currentBranch)
				? globalThis.String(object.currentBranch)
				: isSet(object.current_branch)
					? globalThis.String(object.current_branch)
					: "",
		};
	},

	toJSON(message: BranchList): unknown {
		const obj: any = {};
		if (message.localBranches?.length) {
			obj.localBranches = message.localBranches;
		}
		if (message.remoteBranches?.length) {
			obj.remoteBranches = message.remoteBranches;
		}
		if (message.currentBranch !== "") {
			obj.currentBranch = message.currentBranch;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<BranchList>, I>>(base?: I): BranchList {
		return BranchList.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<BranchList>, I>>(
		object: I,
	): BranchList {
		const message = createBaseBranchList();
		message.localBranches = object.localBranches?.map((e) => e) || [];
		message.remoteBranches = object.remoteBranches?.map((e) => e) || [];
		message.currentBranch = object.currentBranch ?? "";
		return message;
	},
};

function createBaseWorktreeDefaults(): WorktreeDefaults {
	return { suggestedBranch: "", suggestedPath: "" };
}

export const WorktreeDefaults: MessageFns<WorktreeDefaults> = {
	encode(
		message: WorktreeDefaults,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.suggestedBranch !== "") {
			writer.uint32(10).string(message.suggestedBranch);
		}
		if (message.suggestedPath !== "") {
			writer.uint32(18).string(message.suggestedPath);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): WorktreeDefaults {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseWorktreeDefaults();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.suggestedBranch = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.suggestedPath = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): WorktreeDefaults {
		return {
			suggestedBranch: isSet(object.suggestedBranch)
				? globalThis.String(object.suggestedBranch)
				: isSet(object.suggested_branch)
					? globalThis.String(object.suggested_branch)
					: "",
			suggestedPath: isSet(object.suggestedPath)
				? globalThis.String(object.suggestedPath)
				: isSet(object.suggested_path)
					? globalThis.String(object.suggested_path)
					: "",
		};
	},

	toJSON(message: WorktreeDefaults): unknown {
		const obj: any = {};
		if (message.suggestedBranch !== "") {
			obj.suggestedBranch = message.suggestedBranch;
		}
		if (message.suggestedPath !== "") {
			obj.suggestedPath = message.suggestedPath;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<WorktreeDefaults>, I>>(
		base?: I,
	): WorktreeDefaults {
		return WorktreeDefaults.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<WorktreeDefaults>, I>>(
		object: I,
	): WorktreeDefaults {
		const message = createBaseWorktreeDefaults();
		message.suggestedBranch = object.suggestedBranch ?? "";
		message.suggestedPath = object.suggestedPath ?? "";
		return message;
	},
};

function createBaseWorktreeIncludeStatus(): WorktreeIncludeStatus {
	return { exists: false, gitignoreContent: "", hasGitignore: false };
}

export const WorktreeIncludeStatus: MessageFns<WorktreeIncludeStatus> = {
	encode(
		message: WorktreeIncludeStatus,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.exists !== false) {
			writer.uint32(8).bool(message.exists);
		}
		if (message.gitignoreContent !== "") {
			writer.uint32(18).string(message.gitignoreContent);
		}
		if (message.hasGitignore !== false) {
			writer.uint32(24).bool(message.hasGitignore);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): WorktreeIncludeStatus {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseWorktreeIncludeStatus();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.exists = reader.bool();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.gitignoreContent = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.hasGitignore = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): WorktreeIncludeStatus {
		return {
			exists: isSet(object.exists) ? globalThis.Boolean(object.exists) : false,
			gitignoreContent: isSet(object.gitignoreContent)
				? globalThis.String(object.gitignoreContent)
				: isSet(object.gitignore_content)
					? globalThis.String(object.gitignore_content)
					: "",
			hasGitignore: isSet(object.hasGitignore)
				? globalThis.Boolean(object.hasGitignore)
				: isSet(object.has_gitignore)
					? globalThis.Boolean(object.has_gitignore)
					: false,
		};
	},

	toJSON(message: WorktreeIncludeStatus): unknown {
		const obj: any = {};
		if (message.exists !== false) {
			obj.exists = message.exists;
		}
		if (message.gitignoreContent !== "") {
			obj.gitignoreContent = message.gitignoreContent;
		}
		if (message.hasGitignore !== false) {
			obj.hasGitignore = message.hasGitignore;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<WorktreeIncludeStatus>, I>>(
		base?: I,
	): WorktreeIncludeStatus {
		return WorktreeIncludeStatus.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<WorktreeIncludeStatus>, I>>(
		object: I,
	): WorktreeIncludeStatus {
		const message = createBaseWorktreeIncludeStatus();
		message.exists = object.exists ?? false;
		message.gitignoreContent = object.gitignoreContent ?? "";
		message.hasGitignore = object.hasGitignore ?? false;
		return message;
	},
};

function createBaseCreateWorktreeIncludeRequest(): CreateWorktreeIncludeRequest {
	return { content: "" };
}

export const CreateWorktreeIncludeRequest: MessageFns<CreateWorktreeIncludeRequest> =
	{
		encode(
			message: CreateWorktreeIncludeRequest,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.content !== "") {
				writer.uint32(10).string(message.content);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): CreateWorktreeIncludeRequest {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseCreateWorktreeIncludeRequest();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.content = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): CreateWorktreeIncludeRequest {
			return {
				content: isSet(object.content) ? globalThis.String(object.content) : "",
			};
		},

		toJSON(message: CreateWorktreeIncludeRequest): unknown {
			const obj: any = {};
			if (message.content !== "") {
				obj.content = message.content;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<CreateWorktreeIncludeRequest>, I>>(
			base?: I,
		): CreateWorktreeIncludeRequest {
			return CreateWorktreeIncludeRequest.fromPartial(base ?? ({} as any));
		},
		fromPartial<I extends Exact<DeepPartial<CreateWorktreeIncludeRequest>, I>>(
			object: I,
		): CreateWorktreeIncludeRequest {
			const message = createBaseCreateWorktreeIncludeRequest();
			message.content = object.content ?? "";
			return message;
		},
	};

function createBaseCheckoutBranchRequest(): CheckoutBranchRequest {
	return { metadata: undefined, branch: "" };
}

export const CheckoutBranchRequest: MessageFns<CheckoutBranchRequest> = {
	encode(
		message: CheckoutBranchRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata1.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.branch !== "") {
			writer.uint32(18).string(message.branch);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): CheckoutBranchRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseCheckoutBranchRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata1.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.branch = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): CheckoutBranchRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata1.fromJSON(object.metadata)
				: undefined,
			branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
		};
	},

	toJSON(message: CheckoutBranchRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata1.toJSON(message.metadata);
		}
		if (message.branch !== "") {
			obj.branch = message.branch;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<CheckoutBranchRequest>, I>>(
		base?: I,
	): CheckoutBranchRequest {
		return CheckoutBranchRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<CheckoutBranchRequest>, I>>(
		object: I,
	): CheckoutBranchRequest {
		const message = createBaseCheckoutBranchRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata1.fromPartial(object.metadata)
				: undefined;
		message.branch = object.branch ?? "";
		return message;
	},
};

function createBaseMergeWorktreeRequest(): MergeWorktreeRequest {
	return {
		metadata: undefined,
		worktreePath: "",
		targetBranch: "",
		deleteAfterMerge: false,
	};
}

export const MergeWorktreeRequest: MessageFns<MergeWorktreeRequest> = {
	encode(
		message: MergeWorktreeRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata1.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.worktreePath !== "") {
			writer.uint32(18).string(message.worktreePath);
		}
		if (message.targetBranch !== "") {
			writer.uint32(26).string(message.targetBranch);
		}
		if (message.deleteAfterMerge !== false) {
			writer.uint32(32).bool(message.deleteAfterMerge);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): MergeWorktreeRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseMergeWorktreeRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata1.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.worktreePath = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.targetBranch = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.deleteAfterMerge = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): MergeWorktreeRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata1.fromJSON(object.metadata)
				: undefined,
			worktreePath: isSet(object.worktreePath)
				? globalThis.String(object.worktreePath)
				: isSet(object.worktree_path)
					? globalThis.String(object.worktree_path)
					: "",
			targetBranch: isSet(object.targetBranch)
				? globalThis.String(object.targetBranch)
				: isSet(object.target_branch)
					? globalThis.String(object.target_branch)
					: "",
			deleteAfterMerge: isSet(object.deleteAfterMerge)
				? globalThis.Boolean(object.deleteAfterMerge)
				: isSet(object.delete_after_merge)
					? globalThis.Boolean(object.delete_after_merge)
					: false,
		};
	},

	toJSON(message: MergeWorktreeRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata1.toJSON(message.metadata);
		}
		if (message.worktreePath !== "") {
			obj.worktreePath = message.worktreePath;
		}
		if (message.targetBranch !== "") {
			obj.targetBranch = message.targetBranch;
		}
		if (message.deleteAfterMerge !== false) {
			obj.deleteAfterMerge = message.deleteAfterMerge;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<MergeWorktreeRequest>, I>>(
		base?: I,
	): MergeWorktreeRequest {
		return MergeWorktreeRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<MergeWorktreeRequest>, I>>(
		object: I,
	): MergeWorktreeRequest {
		const message = createBaseMergeWorktreeRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata1.fromPartial(object.metadata)
				: undefined;
		message.worktreePath = object.worktreePath ?? "";
		message.targetBranch = object.targetBranch ?? "";
		message.deleteAfterMerge = object.deleteAfterMerge ?? false;
		return message;
	},
};

function createBaseMergeWorktreeResult(): MergeWorktreeResult {
	return {
		success: false,
		message: "",
		hasConflicts: false,
		conflictingFiles: [],
		sourceBranch: "",
		targetBranch: "",
	};
}

export const MergeWorktreeResult: MessageFns<MergeWorktreeResult> = {
	encode(
		message: MergeWorktreeResult,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.success !== false) {
			writer.uint32(8).bool(message.success);
		}
		if (message.message !== "") {
			writer.uint32(18).string(message.message);
		}
		if (message.hasConflicts !== false) {
			writer.uint32(24).bool(message.hasConflicts);
		}
		for (const v of message.conflictingFiles) {
			writer.uint32(34).string(v!);
		}
		if (message.sourceBranch !== "") {
			writer.uint32(42).string(message.sourceBranch);
		}
		if (message.targetBranch !== "") {
			writer.uint32(50).string(message.targetBranch);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): MergeWorktreeResult {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseMergeWorktreeResult();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.success = reader.bool();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.message = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.hasConflicts = reader.bool();
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.conflictingFiles.push(reader.string());
					continue;
				}
				case 5: {
					if (tag !== 42) {
						break;
					}

					message.sourceBranch = reader.string();
					continue;
				}
				case 6: {
					if (tag !== 50) {
						break;
					}

					message.targetBranch = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): MergeWorktreeResult {
		return {
			success: isSet(object.success)
				? globalThis.Boolean(object.success)
				: false,
			message: isSet(object.message) ? globalThis.String(object.message) : "",
			hasConflicts: isSet(object.hasConflicts)
				? globalThis.Boolean(object.hasConflicts)
				: isSet(object.has_conflicts)
					? globalThis.Boolean(object.has_conflicts)
					: false,
			conflictingFiles: globalThis.Array.isArray(object?.conflictingFiles)
				? object.conflictingFiles.map((e: any) => globalThis.String(e))
				: globalThis.Array.isArray(object?.conflicting_files)
					? object.conflicting_files.map((e: any) => globalThis.String(e))
					: [],
			sourceBranch: isSet(object.sourceBranch)
				? globalThis.String(object.sourceBranch)
				: isSet(object.source_branch)
					? globalThis.String(object.source_branch)
					: "",
			targetBranch: isSet(object.targetBranch)
				? globalThis.String(object.targetBranch)
				: isSet(object.target_branch)
					? globalThis.String(object.target_branch)
					: "",
		};
	},

	toJSON(message: MergeWorktreeResult): unknown {
		const obj: any = {};
		if (message.success !== false) {
			obj.success = message.success;
		}
		if (message.message !== "") {
			obj.message = message.message;
		}
		if (message.hasConflicts !== false) {
			obj.hasConflicts = message.hasConflicts;
		}
		if (message.conflictingFiles?.length) {
			obj.conflictingFiles = message.conflictingFiles;
		}
		if (message.sourceBranch !== "") {
			obj.sourceBranch = message.sourceBranch;
		}
		if (message.targetBranch !== "") {
			obj.targetBranch = message.targetBranch;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<MergeWorktreeResult>, I>>(
		base?: I,
	): MergeWorktreeResult {
		return MergeWorktreeResult.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<MergeWorktreeResult>, I>>(
		object: I,
	): MergeWorktreeResult {
		const message = createBaseMergeWorktreeResult();
		message.success = object.success ?? false;
		message.message = object.message ?? "";
		message.hasConflicts = object.hasConflicts ?? false;
		message.conflictingFiles = object.conflictingFiles?.map((e) => e) || [];
		message.sourceBranch = object.sourceBranch ?? "";
		message.targetBranch = object.targetBranch ?? "";
		return message;
	},
};

function createBaseTrackWorktreeViewOpenedRequest(): TrackWorktreeViewOpenedRequest {
	return { source: "" };
}

export const TrackWorktreeViewOpenedRequest: MessageFns<TrackWorktreeViewOpenedRequest> =
	{
		encode(
			message: TrackWorktreeViewOpenedRequest,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.source !== "") {
				writer.uint32(10).string(message.source);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): TrackWorktreeViewOpenedRequest {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseTrackWorktreeViewOpenedRequest();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.source = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): TrackWorktreeViewOpenedRequest {
			return {
				source: isSet(object.source) ? globalThis.String(object.source) : "",
			};
		},

		toJSON(message: TrackWorktreeViewOpenedRequest): unknown {
			const obj: any = {};
			if (message.source !== "") {
				obj.source = message.source;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<TrackWorktreeViewOpenedRequest>, I>>(
			base?: I,
		): TrackWorktreeViewOpenedRequest {
			return TrackWorktreeViewOpenedRequest.fromPartial(base ?? ({} as any));
		},
		fromPartial<
			I extends Exact<DeepPartial<TrackWorktreeViewOpenedRequest>, I>,
		>(object: I): TrackWorktreeViewOpenedRequest {
			const message = createBaseTrackWorktreeViewOpenedRequest();
			message.source = object.source ?? "";
			return message;
		},
	};

/** Service for git worktree operations */
export type WorktreeServiceDefinition = typeof WorktreeServiceDefinition;
export const WorktreeServiceDefinition = {
	name: "WorktreeService",
	fullName: "cline.WorktreeService",
	methods: {
		/** Lists all worktrees in the current repository */
		listWorktrees: {
			name: "listWorktrees",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: WorktreeList,
			responseStream: false,
			options: {},
		},
		/** Creates a new worktree */
		createWorktree: {
			name: "createWorktree",
			requestType: CreateWorktreeRequest,
			requestStream: false,
			responseType: WorktreeResult,
			responseStream: false,
			options: {},
		},
		/** Deletes an existing worktree */
		deleteWorktree: {
			name: "deleteWorktree",
			requestType: DeleteWorktreeRequest,
			requestStream: false,
			responseType: WorktreeResult,
			responseStream: false,
			options: {},
		},
		/** Switches to a different worktree (opens in VS Code) */
		switchWorktree: {
			name: "switchWorktree",
			requestType: SwitchWorktreeRequest,
			requestStream: false,
			responseType: WorktreeResult,
			responseStream: false,
			options: {},
		},
		/** Gets available branches for creating worktrees */
		getAvailableBranches: {
			name: "getAvailableBranches",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: BranchList,
			responseStream: false,
			options: {},
		},
		/** Gets suggested defaults for creating a new worktree (auto-generated branch name and path) */
		getWorktreeDefaults: {
			name: "getWorktreeDefaults",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: WorktreeDefaults,
			responseStream: false,
			options: {},
		},
		/** Gets the status of .worktreeinclude file and .gitignore contents for creating one */
		getWorktreeIncludeStatus: {
			name: "getWorktreeIncludeStatus",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: WorktreeIncludeStatus,
			responseStream: false,
			options: {},
		},
		/** Creates a .worktreeinclude file with the provided content */
		createWorktreeInclude: {
			name: "createWorktreeInclude",
			requestType: CreateWorktreeIncludeRequest,
			requestStream: false,
			responseType: WorktreeResult,
			responseStream: false,
			options: {},
		},
		/** Switches to a different branch in the current worktree (git checkout) */
		checkoutBranch: {
			name: "checkoutBranch",
			requestType: CheckoutBranchRequest,
			requestStream: false,
			responseType: WorktreeResult,
			responseStream: false,
			options: {},
		},
		/** Merges a worktree's branch into the target branch and optionally deletes the worktree */
		mergeWorktree: {
			name: "mergeWorktree",
			requestType: MergeWorktreeRequest,
			requestStream: false,
			responseType: MergeWorktreeResult,
			responseStream: false,
			options: {},
		},
		/** Tracks when the worktrees view is opened (for telemetry) */
		trackWorktreeViewOpened: {
			name: "trackWorktreeViewOpened",
			requestType: TrackWorktreeViewOpenedRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
	},
} as const;

/** Service for git worktree operations */
export type WorktreeServiceService = typeof WorktreeServiceService;
export const WorktreeServiceService = {
	/** Lists all worktrees in the current repository */
	listWorktrees: {
		path: "/cline.WorktreeService/listWorktrees",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: EmptyRequest): Buffer =>
			Buffer.from(EmptyRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): EmptyRequest =>
			EmptyRequest.decode(value),
		responseSerialize: (value: WorktreeList): Buffer =>
			Buffer.from(WorktreeList.encode(value).finish()),
		responseDeserialize: (value: Buffer): WorktreeList =>
			WorktreeList.decode(value),
	},
	/** Creates a new worktree */
	createWorktree: {
		path: "/cline.WorktreeService/createWorktree",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: CreateWorktreeRequest): Buffer =>
			Buffer.from(CreateWorktreeRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): CreateWorktreeRequest =>
			CreateWorktreeRequest.decode(value),
		responseSerialize: (value: WorktreeResult): Buffer =>
			Buffer.from(WorktreeResult.encode(value).finish()),
		responseDeserialize: (value: Buffer): WorktreeResult =>
			WorktreeResult.decode(value),
	},
	/** Deletes an existing worktree */
	deleteWorktree: {
		path: "/cline.WorktreeService/deleteWorktree",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: DeleteWorktreeRequest): Buffer =>
			Buffer.from(DeleteWorktreeRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): DeleteWorktreeRequest =>
			DeleteWorktreeRequest.decode(value),
		responseSerialize: (value: WorktreeResult): Buffer =>
			Buffer.from(WorktreeResult.encode(value).finish()),
		responseDeserialize: (value: Buffer): WorktreeResult =>
			WorktreeResult.decode(value),
	},
	/** Switches to a different worktree (opens in VS Code) */
	switchWorktree: {
		path: "/cline.WorktreeService/switchWorktree",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: SwitchWorktreeRequest): Buffer =>
			Buffer.from(SwitchWorktreeRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): SwitchWorktreeRequest =>
			SwitchWorktreeRequest.decode(value),
		responseSerialize: (value: WorktreeResult): Buffer =>
			Buffer.from(WorktreeResult.encode(value).finish()),
		responseDeserialize: (value: Buffer): WorktreeResult =>
			WorktreeResult.decode(value),
	},
	/** Gets available branches for creating worktrees */
	getAvailableBranches: {
		path: "/cline.WorktreeService/getAvailableBranches",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: EmptyRequest): Buffer =>
			Buffer.from(EmptyRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): EmptyRequest =>
			EmptyRequest.decode(value),
		responseSerialize: (value: BranchList): Buffer =>
			Buffer.from(BranchList.encode(value).finish()),
		responseDeserialize: (value: Buffer): BranchList =>
			BranchList.decode(value),
	},
	/** Gets suggested defaults for creating a new worktree (auto-generated branch name and path) */
	getWorktreeDefaults: {
		path: "/cline.WorktreeService/getWorktreeDefaults",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: EmptyRequest): Buffer =>
			Buffer.from(EmptyRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): EmptyRequest =>
			EmptyRequest.decode(value),
		responseSerialize: (value: WorktreeDefaults): Buffer =>
			Buffer.from(WorktreeDefaults.encode(value).finish()),
		responseDeserialize: (value: Buffer): WorktreeDefaults =>
			WorktreeDefaults.decode(value),
	},
	/** Gets the status of .worktreeinclude file and .gitignore contents for creating one */
	getWorktreeIncludeStatus: {
		path: "/cline.WorktreeService/getWorktreeIncludeStatus",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: EmptyRequest): Buffer =>
			Buffer.from(EmptyRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): EmptyRequest =>
			EmptyRequest.decode(value),
		responseSerialize: (value: WorktreeIncludeStatus): Buffer =>
			Buffer.from(WorktreeIncludeStatus.encode(value).finish()),
		responseDeserialize: (value: Buffer): WorktreeIncludeStatus =>
			WorktreeIncludeStatus.decode(value),
	},
	/** Creates a .worktreeinclude file with the provided content */
	createWorktreeInclude: {
		path: "/cline.WorktreeService/createWorktreeInclude",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: CreateWorktreeIncludeRequest): Buffer =>
			Buffer.from(CreateWorktreeIncludeRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): CreateWorktreeIncludeRequest =>
			CreateWorktreeIncludeRequest.decode(value),
		responseSerialize: (value: WorktreeResult): Buffer =>
			Buffer.from(WorktreeResult.encode(value).finish()),
		responseDeserialize: (value: Buffer): WorktreeResult =>
			WorktreeResult.decode(value),
	},
	/** Switches to a different branch in the current worktree (git checkout) */
	checkoutBranch: {
		path: "/cline.WorktreeService/checkoutBranch",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: CheckoutBranchRequest): Buffer =>
			Buffer.from(CheckoutBranchRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): CheckoutBranchRequest =>
			CheckoutBranchRequest.decode(value),
		responseSerialize: (value: WorktreeResult): Buffer =>
			Buffer.from(WorktreeResult.encode(value).finish()),
		responseDeserialize: (value: Buffer): WorktreeResult =>
			WorktreeResult.decode(value),
	},
	/** Merges a worktree's branch into the target branch and optionally deletes the worktree */
	mergeWorktree: {
		path: "/cline.WorktreeService/mergeWorktree",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: MergeWorktreeRequest): Buffer =>
			Buffer.from(MergeWorktreeRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): MergeWorktreeRequest =>
			MergeWorktreeRequest.decode(value),
		responseSerialize: (value: MergeWorktreeResult): Buffer =>
			Buffer.from(MergeWorktreeResult.encode(value).finish()),
		responseDeserialize: (value: Buffer): MergeWorktreeResult =>
			MergeWorktreeResult.decode(value),
	},
	/** Tracks when the worktrees view is opened (for telemetry) */
	trackWorktreeViewOpened: {
		path: "/cline.WorktreeService/trackWorktreeViewOpened",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: TrackWorktreeViewOpenedRequest): Buffer =>
			Buffer.from(TrackWorktreeViewOpenedRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): TrackWorktreeViewOpenedRequest =>
			TrackWorktreeViewOpenedRequest.decode(value),
		responseSerialize: (value: Empty): Buffer =>
			Buffer.from(Empty.encode(value).finish()),
		responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
	},
} as const;

export interface WorktreeServiceServer extends UntypedServiceImplementation {
	/** Lists all worktrees in the current repository */
	listWorktrees: handleUnaryCall<EmptyRequest, WorktreeList>;
	/** Creates a new worktree */
	createWorktree: handleUnaryCall<CreateWorktreeRequest, WorktreeResult>;
	/** Deletes an existing worktree */
	deleteWorktree: handleUnaryCall<DeleteWorktreeRequest, WorktreeResult>;
	/** Switches to a different worktree (opens in VS Code) */
	switchWorktree: handleUnaryCall<SwitchWorktreeRequest, WorktreeResult>;
	/** Gets available branches for creating worktrees */
	getAvailableBranches: handleUnaryCall<EmptyRequest, BranchList>;
	/** Gets suggested defaults for creating a new worktree (auto-generated branch name and path) */
	getWorktreeDefaults: handleUnaryCall<EmptyRequest, WorktreeDefaults>;
	/** Gets the status of .worktreeinclude file and .gitignore contents for creating one */
	getWorktreeIncludeStatus: handleUnaryCall<
		EmptyRequest,
		WorktreeIncludeStatus
	>;
	/** Creates a .worktreeinclude file with the provided content */
	createWorktreeInclude: handleUnaryCall<
		CreateWorktreeIncludeRequest,
		WorktreeResult
	>;
	/** Switches to a different branch in the current worktree (git checkout) */
	checkoutBranch: handleUnaryCall<CheckoutBranchRequest, WorktreeResult>;
	/** Merges a worktree's branch into the target branch and optionally deletes the worktree */
	mergeWorktree: handleUnaryCall<MergeWorktreeRequest, MergeWorktreeResult>;
	/** Tracks when the worktrees view is opened (for telemetry) */
	trackWorktreeViewOpened: handleUnaryCall<
		TrackWorktreeViewOpenedRequest,
		Empty
	>;
}

export interface WorktreeServiceClient extends Client {
	/** Lists all worktrees in the current repository */
	listWorktrees(
		request: EmptyRequest,
		callback: (error: ServiceError | null, response: WorktreeList) => void,
	): ClientUnaryCall;
	listWorktrees(
		request: EmptyRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: WorktreeList) => void,
	): ClientUnaryCall;
	listWorktrees(
		request: EmptyRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: WorktreeList) => void,
	): ClientUnaryCall;
	/** Creates a new worktree */
	createWorktree(
		request: CreateWorktreeRequest,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	createWorktree(
		request: CreateWorktreeRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	createWorktree(
		request: CreateWorktreeRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	/** Deletes an existing worktree */
	deleteWorktree(
		request: DeleteWorktreeRequest,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	deleteWorktree(
		request: DeleteWorktreeRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	deleteWorktree(
		request: DeleteWorktreeRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	/** Switches to a different worktree (opens in VS Code) */
	switchWorktree(
		request: SwitchWorktreeRequest,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	switchWorktree(
		request: SwitchWorktreeRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	switchWorktree(
		request: SwitchWorktreeRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	/** Gets available branches for creating worktrees */
	getAvailableBranches(
		request: EmptyRequest,
		callback: (error: ServiceError | null, response: BranchList) => void,
	): ClientUnaryCall;
	getAvailableBranches(
		request: EmptyRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: BranchList) => void,
	): ClientUnaryCall;
	getAvailableBranches(
		request: EmptyRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: BranchList) => void,
	): ClientUnaryCall;
	/** Gets suggested defaults for creating a new worktree (auto-generated branch name and path) */
	getWorktreeDefaults(
		request: EmptyRequest,
		callback: (error: ServiceError | null, response: WorktreeDefaults) => void,
	): ClientUnaryCall;
	getWorktreeDefaults(
		request: EmptyRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: WorktreeDefaults) => void,
	): ClientUnaryCall;
	getWorktreeDefaults(
		request: EmptyRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: WorktreeDefaults) => void,
	): ClientUnaryCall;
	/** Gets the status of .worktreeinclude file and .gitignore contents for creating one */
	getWorktreeIncludeStatus(
		request: EmptyRequest,
		callback: (
			error: ServiceError | null,
			response: WorktreeIncludeStatus,
		) => void,
	): ClientUnaryCall;
	getWorktreeIncludeStatus(
		request: EmptyRequest,
		metadata: Metadata,
		callback: (
			error: ServiceError | null,
			response: WorktreeIncludeStatus,
		) => void,
	): ClientUnaryCall;
	getWorktreeIncludeStatus(
		request: EmptyRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (
			error: ServiceError | null,
			response: WorktreeIncludeStatus,
		) => void,
	): ClientUnaryCall;
	/** Creates a .worktreeinclude file with the provided content */
	createWorktreeInclude(
		request: CreateWorktreeIncludeRequest,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	createWorktreeInclude(
		request: CreateWorktreeIncludeRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	createWorktreeInclude(
		request: CreateWorktreeIncludeRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	/** Switches to a different branch in the current worktree (git checkout) */
	checkoutBranch(
		request: CheckoutBranchRequest,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	checkoutBranch(
		request: CheckoutBranchRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	checkoutBranch(
		request: CheckoutBranchRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: WorktreeResult) => void,
	): ClientUnaryCall;
	/** Merges a worktree's branch into the target branch and optionally deletes the worktree */
	mergeWorktree(
		request: MergeWorktreeRequest,
		callback: (
			error: ServiceError | null,
			response: MergeWorktreeResult,
		) => void,
	): ClientUnaryCall;
	mergeWorktree(
		request: MergeWorktreeRequest,
		metadata: Metadata,
		callback: (
			error: ServiceError | null,
			response: MergeWorktreeResult,
		) => void,
	): ClientUnaryCall;
	mergeWorktree(
		request: MergeWorktreeRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (
			error: ServiceError | null,
			response: MergeWorktreeResult,
		) => void,
	): ClientUnaryCall;
	/** Tracks when the worktrees view is opened (for telemetry) */
	trackWorktreeViewOpened(
		request: TrackWorktreeViewOpenedRequest,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
	trackWorktreeViewOpened(
		request: TrackWorktreeViewOpenedRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
	trackWorktreeViewOpened(
		request: TrackWorktreeViewOpenedRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
}

export const WorktreeServiceClient = makeGenericClientConstructor(
	WorktreeServiceService,
	"cline.WorktreeService",
) as unknown as {
	new (
		address: string,
		credentials: ChannelCredentials,
		options?: Partial<ClientOptions>,
	): WorktreeServiceClient;
	service: typeof WorktreeServiceService;
	serviceName: string;
};

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & {
			[K in Exclude<keyof I, KeysOfUnion<P>>]: never;
		};

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: cline/checkpoints.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
	type CallOptions,
	type ChannelCredentials,
	Client,
	type ClientOptions,
	type ClientReadableStream,
	type ClientUnaryCall,
	type handleServerStreamingCall,
	type handleUnaryCall,
	makeGenericClientConstructor,
	type Metadata,
	type ServiceError,
	type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Timestamp } from "../google/protobuf/timestamp";
import {
	Empty,
	Int64Request,
	Metadata as Metadata1,
	StringArrayRequest,
} from "./common";

export interface CheckpointRestoreRequest {
	metadata: Metadata1 | undefined;
	number: number;
	restoreType: string;
	offset?: number | undefined;
}

export interface CheckpointSubscriptionRequest {
	cwdHash: string;
}

export interface CheckpointEvent {
	operation: CheckpointEvent_OperationType;
	cwdHash: string;
	isActive: boolean;
	timestamp: Timestamp | undefined;
	taskId?: string | undefined;
	commitHash?: string | undefined;
}

export enum CheckpointEvent_OperationType {
	CHECKPOINT_INIT = 0,
	CHECKPOINT_COMMIT = 1,
	CHECKPOINT_RESTORE = 2,
	UNRECOGNIZED = -1,
}

export function checkpointEvent_OperationTypeFromJSON(
	object: any,
): CheckpointEvent_OperationType {
	switch (object) {
		case 0:
		case "CHECKPOINT_INIT":
			return CheckpointEvent_OperationType.CHECKPOINT_INIT;
		case 1:
		case "CHECKPOINT_COMMIT":
			return CheckpointEvent_OperationType.CHECKPOINT_COMMIT;
		case 2:
		case "CHECKPOINT_RESTORE":
			return CheckpointEvent_OperationType.CHECKPOINT_RESTORE;
		case -1:
		case "UNRECOGNIZED":
		default:
			return CheckpointEvent_OperationType.UNRECOGNIZED;
	}
}

export function checkpointEvent_OperationTypeToJSON(
	object: CheckpointEvent_OperationType,
): string {
	switch (object) {
		case CheckpointEvent_OperationType.CHECKPOINT_INIT:
			return "CHECKPOINT_INIT";
		case CheckpointEvent_OperationType.CHECKPOINT_COMMIT:
			return "CHECKPOINT_COMMIT";
		case CheckpointEvent_OperationType.CHECKPOINT_RESTORE:
			return "CHECKPOINT_RESTORE";
		case CheckpointEvent_OperationType.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED";
	}
}

export interface PathHashMap {
	pathHash: { [key: string]: string };
}

export interface PathHashMap_PathHashEntry {
	key: string;
	value: string;
}

function createBaseCheckpointRestoreRequest(): CheckpointRestoreRequest {
	return { metadata: undefined, number: 0, restoreType: "", offset: undefined };
}

export const CheckpointRestoreRequest: MessageFns<CheckpointRestoreRequest> = {
	encode(
		message: CheckpointRestoreRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata1.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.number !== 0) {
			writer.uint32(16).int64(message.number);
		}
		if (message.restoreType !== "") {
			writer.uint32(26).string(message.restoreType);
		}
		if (message.offset !== undefined) {
			writer.uint32(32).int64(message.offset);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): CheckpointRestoreRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseCheckpointRestoreRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata1.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 16) {
						break;
					}

					message.number = longToNumber(reader.int64());
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.restoreType = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.offset = longToNumber(reader.int64());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): CheckpointRestoreRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata1.fromJSON(object.metadata)
				: undefined,
			number: isSet(object.number) ? globalThis.Number(object.number) : 0,
			restoreType: isSet(object.restoreType)
				? globalThis.String(object.restoreType)
				: isSet(object.restore_type)
					? globalThis.String(object.restore_type)
					: "",
			offset: isSet(object.offset)
				? globalThis.Number(object.offset)
				: undefined,
		};
	},

	toJSON(message: CheckpointRestoreRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata1.toJSON(message.metadata);
		}
		if (message.number !== 0) {
			obj.number = Math.round(message.number);
		}
		if (message.restoreType !== "") {
			obj.restoreType = message.restoreType;
		}
		if (message.offset !== undefined) {
			obj.offset = Math.round(message.offset);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<CheckpointRestoreRequest>, I>>(
		base?: I,
	): CheckpointRestoreRequest {
		return CheckpointRestoreRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<CheckpointRestoreRequest>, I>>(
		object: I,
	): CheckpointRestoreRequest {
		const message = createBaseCheckpointRestoreRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata1.fromPartial(object.metadata)
				: undefined;
		message.number = object.number ?? 0;
		message.restoreType = object.restoreType ?? "";
		message.offset = object.offset ?? undefined;
		return message;
	},
};

function createBaseCheckpointSubscriptionRequest(): CheckpointSubscriptionRequest {
	return { cwdHash: "" };
}

export const CheckpointSubscriptionRequest: MessageFns<CheckpointSubscriptionRequest> =
	{
		encode(
			message: CheckpointSubscriptionRequest,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.cwdHash !== "") {
				writer.uint32(10).string(message.cwdHash);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): CheckpointSubscriptionRequest {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseCheckpointSubscriptionRequest();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.cwdHash = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): CheckpointSubscriptionRequest {
			return {
				cwdHash: isSet(object.cwdHash)
					? globalThis.String(object.cwdHash)
					: isSet(object.cwd_hash)
						? globalThis.String(object.cwd_hash)
						: "",
			};
		},

		toJSON(message: CheckpointSubscriptionRequest): unknown {
			const obj: any = {};
			if (message.cwdHash !== "") {
				obj.cwdHash = message.cwdHash;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<CheckpointSubscriptionRequest>, I>>(
			base?: I,
		): CheckpointSubscriptionRequest {
			return CheckpointSubscriptionRequest.fromPartial(base ?? ({} as any));
		},
		fromPartial<I extends Exact<DeepPartial<CheckpointSubscriptionRequest>, I>>(
			object: I,
		): CheckpointSubscriptionRequest {
			const message = createBaseCheckpointSubscriptionRequest();
			message.cwdHash = object.cwdHash ?? "";
			return message;
		},
	};

function createBaseCheckpointEvent(): CheckpointEvent {
	return {
		operation: 0,
		cwdHash: "",
		isActive: false,
		timestamp: undefined,
		taskId: undefined,
		commitHash: undefined,
	};
}

export const CheckpointEvent: MessageFns<CheckpointEvent> = {
	encode(
		message: CheckpointEvent,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.operation !== 0) {
			writer.uint32(8).int32(message.operation);
		}
		if (message.cwdHash !== "") {
			writer.uint32(18).string(message.cwdHash);
		}
		if (message.isActive !== false) {
			writer.uint32(24).bool(message.isActive);
		}
		if (message.timestamp !== undefined) {
			Timestamp.encode(message.timestamp, writer.uint32(34).fork()).join();
		}
		if (message.taskId !== undefined) {
			writer.uint32(42).string(message.taskId);
		}
		if (message.commitHash !== undefined) {
			writer.uint32(50).string(message.commitHash);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): CheckpointEvent {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseCheckpointEvent();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.operation = reader.int32() as any;
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.cwdHash = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.isActive = reader.bool();
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.timestamp = Timestamp.decode(reader, reader.uint32());
					continue;
				}
				case 5: {
					if (tag !== 42) {
						break;
					}

					message.taskId = reader.string();
					continue;
				}
				case 6: {
					if (tag !== 50) {
						break;
					}

					message.commitHash = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): CheckpointEvent {
		return {
			operation: isSet(object.operation)
				? checkpointEvent_OperationTypeFromJSON(object.operation)
				: 0,
			cwdHash: isSet(object.cwdHash)
				? globalThis.String(object.cwdHash)
				: isSet(object.cwd_hash)
					? globalThis.String(object.cwd_hash)
					: "",
			isActive: isSet(object.isActive)
				? globalThis.Boolean(object.isActive)
				: isSet(object.is_active)
					? globalThis.Boolean(object.is_active)
					: false,
			timestamp: isSet(object.timestamp)
				? fromJsonTimestamp(object.timestamp)
				: undefined,
			taskId: isSet(object.taskId)
				? globalThis.String(object.taskId)
				: isSet(object.task_id)
					? globalThis.String(object.task_id)
					: undefined,
			commitHash: isSet(object.commitHash)
				? globalThis.String(object.commitHash)
				: isSet(object.commit_hash)
					? globalThis.String(object.commit_hash)
					: undefined,
		};
	},

	toJSON(message: CheckpointEvent): unknown {
		const obj: any = {};
		if (message.operation !== 0) {
			obj.operation = checkpointEvent_OperationTypeToJSON(message.operation);
		}
		if (message.cwdHash !== "") {
			obj.cwdHash = message.cwdHash;
		}
		if (message.isActive !== false) {
			obj.isActive = message.isActive;
		}
		if (message.timestamp !== undefined) {
			obj.timestamp = fromTimestamp(message.timestamp).toISOString();
		}
		if (message.taskId !== undefined) {
			obj.taskId = message.taskId;
		}
		if (message.commitHash !== undefined) {
			obj.commitHash = message.commitHash;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<CheckpointEvent>, I>>(
		base?: I,
	): CheckpointEvent {
		return CheckpointEvent.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<CheckpointEvent>, I>>(
		object: I,
	): CheckpointEvent {
		const message = createBaseCheckpointEvent();
		message.operation = object.operation ?? 0;
		message.cwdHash = object.cwdHash ?? "";
		message.isActive = object.isActive ?? false;
		message.timestamp =
			object.timestamp !== undefined && object.timestamp !== null
				? Timestamp.fromPartial(object.timestamp)
				: undefined;
		message.taskId = object.taskId ?? undefined;
		message.commitHash = object.commitHash ?? undefined;
		return message;
	},
};

function createBasePathHashMap(): PathHashMap {
	return { pathHash: {} };
}

export const PathHashMap: MessageFns<PathHashMap> = {
	encode(
		message: PathHashMap,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		globalThis.Object.entries(message.pathHash).forEach(
			([key, value]: [string, string]) => {
				PathHashMap_PathHashEntry.encode(
					{ key: key as any, value },
					writer.uint32(10).fork(),
				).join();
			},
		);
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): PathHashMap {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBasePathHashMap();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					const entry1 = PathHashMap_PathHashEntry.decode(
						reader,
						reader.uint32(),
					);
					if (entry1.value !== undefined) {
						message.pathHash[entry1.key] = entry1.value;
					}
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): PathHashMap {
		return {
			pathHash: isObject(object.pathHash)
				? (
						globalThis.Object.entries(object.pathHash) as [string, any][]
					).reduce(
						(acc: { [key: string]: string }, [key, value]: [string, any]) => {
							acc[key] = globalThis.String(value);
							return acc;
						},
						{},
					)
				: isObject(object.path_hash)
					? (
							globalThis.Object.entries(object.path_hash) as [string, any][]
						).reduce(
							(acc: { [key: string]: string }, [key, value]: [string, any]) => {
								acc[key] = globalThis.String(value);
								return acc;
							},
							{},
						)
					: {},
		};
	},

	toJSON(message: PathHashMap): unknown {
		const obj: any = {};
		if (message.pathHash) {
			const entries = globalThis.Object.entries(message.pathHash) as [
				string,
				string,
			][];
			if (entries.length > 0) {
				obj.pathHash = {};
				entries.forEach(([k, v]) => {
					obj.pathHash[k] = v;
				});
			}
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<PathHashMap>, I>>(base?: I): PathHashMap {
		return PathHashMap.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<PathHashMap>, I>>(
		object: I,
	): PathHashMap {
		const message = createBasePathHashMap();
		message.pathHash = (
			globalThis.Object.entries(object.pathHash ?? {}) as [string, string][]
		).reduce(
			(acc: { [key: string]: string }, [key, value]: [string, string]) => {
				if (value !== undefined) {
					acc[key] = globalThis.String(value);
				}
				return acc;
			},
			{},
		);
		return message;
	},
};

function createBasePathHashMap_PathHashEntry(): PathHashMap_PathHashEntry {
	return { key: "", value: "" };
}

export const PathHashMap_PathHashEntry: MessageFns<PathHashMap_PathHashEntry> =
	{
		encode(
			message: PathHashMap_PathHashEntry,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.key !== "") {
				writer.uint32(10).string(message.key);
			}
			if (message.value !== "") {
				writer.uint32(18).string(message.value);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): PathHashMap_PathHashEntry {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBasePathHashMap_PathHashEntry();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.key = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 18) {
							break;
						}

						message.value = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): PathHashMap_PathHashEntry {
			return {
				key: isSet(object.key) ? globalThis.String(object.key) : "",
				value: isSet(object.value) ? globalThis.String(object.value) : "",
			};
		},

		toJSON(message: PathHashMap_PathHashEntry): unknown {
			const obj: any = {};
			if (message.key !== "") {
				obj.key = message.key;
			}
			if (message.value !== "") {
				obj.value = message.value;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<PathHashMap_PathHashEntry>, I>>(
			base?: I,
		): PathHashMap_PathHashEntry {
			return PathHashMap_PathHashEntry.fromPartial(base ?? ({} as any));
		},
		fromPartial<I extends Exact<DeepPartial<PathHashMap_PathHashEntry>, I>>(
			object: I,
		): PathHashMap_PathHashEntry {
			const message = createBasePathHashMap_PathHashEntry();
			message.key = object.key ?? "";
			message.value = object.value ?? "";
			return message;
		},
	};

export type CheckpointsServiceDefinition = typeof CheckpointsServiceDefinition;
export const CheckpointsServiceDefinition = {
	name: "CheckpointsService",
	fullName: "cline.CheckpointsService",
	methods: {
		checkpointDiff: {
			name: "checkpointDiff",
			requestType: Int64Request,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		checkpointRestore: {
			name: "checkpointRestore",
			requestType: CheckpointRestoreRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		subscribeToCheckpoints: {
			name: "subscribeToCheckpoints",
			requestType: CheckpointSubscriptionRequest,
			requestStream: false,
			responseType: CheckpointEvent,
			responseStream: true,
			options: {},
		},
		getCwdHash: {
			name: "getCwdHash",
			requestType: StringArrayRequest,
			requestStream: false,
			responseType: PathHashMap,
			responseStream: false,
			options: {},
		},
	},
} as const;

export type CheckpointsServiceService = typeof CheckpointsServiceService;
export const CheckpointsServiceService = {
	checkpointDiff: {
		path: "/cline.CheckpointsService/checkpointDiff",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: Int64Request): Buffer =>
			Buffer.from(Int64Request.encode(value).finish()),
		requestDeserialize: (value: Buffer): Int64Request =>
			Int64Request.decode(value),
		responseSerialize: (value: Empty): Buffer =>
			Buffer.from(Empty.encode(value).finish()),
		responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
	},
	checkpointRestore: {
		path: "/cline.CheckpointsService/checkpointRestore",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: CheckpointRestoreRequest): Buffer =>
			Buffer.from(CheckpointRestoreRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): CheckpointRestoreRequest =>
			CheckpointRestoreRequest.decode(value),
		responseSerialize: (value: Empty): Buffer =>
			Buffer.from(Empty.encode(value).finish()),
		responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
	},
	subscribeToCheckpoints: {
		path: "/cline.CheckpointsService/subscribeToCheckpoints",
		requestStream: false,
		responseStream: true,
		requestSerialize: (value: CheckpointSubscriptionRequest): Buffer =>
			Buffer.from(CheckpointSubscriptionRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): CheckpointSubscriptionRequest =>
			CheckpointSubscriptionRequest.decode(value),
		responseSerialize: (value: CheckpointEvent): Buffer =>
			Buffer.from(CheckpointEvent.encode(value).finish()),
		responseDeserialize: (value: Buffer): CheckpointEvent =>
			CheckpointEvent.decode(value),
	},
	getCwdHash: {
		path: "/cline.CheckpointsService/getCwdHash",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: StringArrayRequest): Buffer =>
			Buffer.from(StringArrayRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): StringArrayRequest =>
			StringArrayRequest.decode(value),
		responseSerialize: (value: PathHashMap): Buffer =>
			Buffer.from(PathHashMap.encode(value).finish()),
		responseDeserialize: (value: Buffer): PathHashMap =>
			PathHashMap.decode(value),
	},
} as const;

export interface CheckpointsServiceServer extends UntypedServiceImplementation {
	checkpointDiff: handleUnaryCall<Int64Request, Empty>;
	checkpointRestore: handleUnaryCall<CheckpointRestoreRequest, Empty>;
	subscribeToCheckpoints: handleServerStreamingCall<
		CheckpointSubscriptionRequest,
		CheckpointEvent
	>;
	getCwdHash: handleUnaryCall<StringArrayRequest, PathHashMap>;
}

export interface CheckpointsServiceClient extends Client {
	checkpointDiff(
		request: Int64Request,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
	checkpointDiff(
		request: Int64Request,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
	checkpointDiff(
		request: Int64Request,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
	checkpointRestore(
		request: CheckpointRestoreRequest,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
	checkpointRestore(
		request: CheckpointRestoreRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
	checkpointRestore(
		request: CheckpointRestoreRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: Empty) => void,
	): ClientUnaryCall;
	subscribeToCheckpoints(
		request: CheckpointSubscriptionRequest,
		options?: Partial<CallOptions>,
	): ClientReadableStream<CheckpointEvent>;
	subscribeToCheckpoints(
		request: CheckpointSubscriptionRequest,
		metadata?: Metadata,
		options?: Partial<CallOptions>,
	): ClientReadableStream<CheckpointEvent>;
	getCwdHash(
		request: StringArrayRequest,
		callback: (error: ServiceError | null, response: PathHashMap) => void,
	): ClientUnaryCall;
	getCwdHash(
		request: StringArrayRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: PathHashMap) => void,
	): ClientUnaryCall;
	getCwdHash(
		request: StringArrayRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: PathHashMap) => void,
	): ClientUnaryCall;
}

export const CheckpointsServiceClient = makeGenericClientConstructor(
	CheckpointsServiceService,
	"cline.CheckpointsService",
) as unknown as {
	new (
		address: string,
		credentials: ChannelCredentials,
		options?: Partial<ClientOptions>,
	): CheckpointsServiceClient;
	service: typeof CheckpointsServiceService;
	serviceName: string;
};

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & {
			[K in Exclude<keyof I, KeysOfUnion<P>>]: never;
		};

function toTimestamp(date: Date): Timestamp {
	const seconds = Math.trunc(date.getTime() / 1_000);
	const nanos = (date.getTime() % 1_000) * 1_000_000;
	return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
	let millis = (t.seconds || 0) * 1_000;
	millis += (t.nanos || 0) / 1_000_000;
	return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Timestamp {
	if (o instanceof globalThis.Date) {
		return toTimestamp(o);
	} else if (typeof o === "string") {
		return toTimestamp(new globalThis.Date(o));
	} else {
		return Timestamp.fromJSON(o);
	}
}

function longToNumber(int64: { toString(): string }): number {
	const num = globalThis.Number(int64.toString());
	if (num > globalThis.Number.MAX_SAFE_INTEGER) {
		throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
	}
	if (num < globalThis.Number.MIN_SAFE_INTEGER) {
		throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
	}
	return num;
}

function isObject(value: any): boolean {
	return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: cline/dictation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
	type CallOptions,
	type ChannelCredentials,
	Client,
	type ClientOptions,
	type ClientUnaryCall,
	type handleUnaryCall,
	makeGenericClientConstructor,
	type Metadata,
	type ServiceError,
	type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { EmptyRequest } from "./common";

export interface TranscribeAudioRequest {
	audioBase64: string;
	language: string;
}

export interface RecordingResult {
	success: boolean;
	error: string;
}

export interface RecordedAudio {
	success: boolean;
	audioBase64: string;
	error: string;
}

export interface RecordingStatus {
	isRecording: boolean;
	durationSeconds: number;
	error: string;
}

export interface Transcription {
	text: string;
	error: string;
}

function createBaseTranscribeAudioRequest(): TranscribeAudioRequest {
	return { audioBase64: "", language: "" };
}

export const TranscribeAudioRequest: MessageFns<TranscribeAudioRequest> = {
	encode(
		message: TranscribeAudioRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.audioBase64 !== "") {
			writer.uint32(18).string(message.audioBase64);
		}
		if (message.language !== "") {
			writer.uint32(26).string(message.language);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): TranscribeAudioRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseTranscribeAudioRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.audioBase64 = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.language = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): TranscribeAudioRequest {
		return {
			audioBase64: isSet(object.audioBase64)
				? globalThis.String(object.audioBase64)
				: isSet(object.audio_base64)
					? globalThis.String(object.audio_base64)
					: "",
			language: isSet(object.language)
				? globalThis.String(object.language)
				: "",
		};
	},

	toJSON(message: TranscribeAudioRequest): unknown {
		const obj: any = {};
		if (message.audioBase64 !== "") {
			obj.audioBase64 = message.audioBase64;
		}
		if (message.language !== "") {
			obj.language = message.language;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<TranscribeAudioRequest>, I>>(
		base?: I,
	): TranscribeAudioRequest {
		return TranscribeAudioRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<TranscribeAudioRequest>, I>>(
		object: I,
	): TranscribeAudioRequest {
		const message = createBaseTranscribeAudioRequest();
		message.audioBase64 = object.audioBase64 ?? "";
		message.language = object.language ?? "";
		return message;
	},
};

function createBaseRecordingResult(): RecordingResult {
	return { success: false, error: "" };
}

export const RecordingResult: MessageFns<RecordingResult> = {
	encode(
		message: RecordingResult,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.success !== false) {
			writer.uint32(8).bool(message.success);
		}
		if (message.error !== "") {
			writer.uint32(18).string(message.error);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RecordingResult {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRecordingResult();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.success = reader.bool();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.error = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): RecordingResult {
		return {
			success: isSet(object.success)
				? globalThis.Boolean(object.success)
				: false,
			error: isSet(object.error) ? globalThis.String(object.error) : "",
		};
	},

	toJSON(message: RecordingResult): unknown {
		const obj: any = {};
		if (message.success !== false) {
			obj.success = message.success;
		}
		if (message.error !== "") {
			obj.error = message.error;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<RecordingResult>, I>>(
		base?: I,
	): RecordingResult {
		return RecordingResult.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<RecordingResult>, I>>(
		object: I,
	): RecordingResult {
		const message = createBaseRecordingResult();
		message.success = object.success ?? false;
		message.error = object.error ?? "";
		return message;
	},
};

function createBaseRecordedAudio(): RecordedAudio {
	return { success: false, audioBase64: "", error: "" };
}

export const RecordedAudio: MessageFns<RecordedAudio> = {
	encode(
		message: RecordedAudio,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.success !== false) {
			writer.uint32(8).bool(message.success);
		}
		if (message.audioBase64 !== "") {
			writer.uint32(18).string(message.audioBase64);
		}
		if (message.error !== "") {
			writer.uint32(26).string(message.error);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RecordedAudio {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRecordedAudio();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.success = reader.bool();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.audioBase64 = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.error = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): RecordedAudio {
		return {
			success: isSet(object.success)
				? globalThis.Boolean(object.success)
				: false,
			audioBase64: isSet(object.audioBase64)
				? globalThis.String(object.audioBase64)
				: isSet(object.audio_base64)
					? globalThis.String(object.audio_base64)
					: "",
			error: isSet(object.error) ? globalThis.String(object.error) : "",
		};
	},

	toJSON(message: RecordedAudio): unknown {
		const obj: any = {};
		if (message.success !== false) {
			obj.success = message.success;
		}
		if (message.audioBase64 !== "") {
			obj.audioBase64 = message.audioBase64;
		}
		if (message.error !== "") {
			obj.error = message.error;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<RecordedAudio>, I>>(
		base?: I,
	): RecordedAudio {
		return RecordedAudio.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<RecordedAudio>, I>>(
		object: I,
	): RecordedAudio {
		const message = createBaseRecordedAudio();
		message.success = object.success ?? false;
		message.audioBase64 = object.audioBase64 ?? "";
		message.error = object.error ?? "";
		return message;
	},
};

function createBaseRecordingStatus(): RecordingStatus {
	return { isRecording: false, durationSeconds: 0, error: "" };
}

export const RecordingStatus: MessageFns<RecordingStatus> = {
	encode(
		message: RecordingStatus,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.isRecording !== false) {
			writer.uint32(8).bool(message.isRecording);
		}
		if (message.durationSeconds !== 0) {
			writer.uint32(17).double(message.durationSeconds);
		}
		if (message.error !== "") {
			writer.uint32(26).string(message.error);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RecordingStatus {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRecordingStatus();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.isRecording = reader.bool();
					continue;
				}
				case 2: {
					if (tag !== 17) {
						break;
					}

					message.durationSeconds = reader.double();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.error = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): RecordingStatus {
		return {
			isRecording: isSet(object.isRecording)
				? globalThis.Boolean(object.isRecording)
				: isSet(object.is_recording)
					? globalThis.Boolean(object.is_recording)
					: false,
			durationSeconds: isSet(object.durationSeconds)
				? globalThis.Number(object.durationSeconds)
				: isSet(object.duration_seconds)
					? globalThis.Number(object.duration_seconds)
					: 0,
			error: isSet(object.error) ? globalThis.String(object.error) : "",
		};
	},

	toJSON(message: RecordingStatus): unknown {
		const obj: any = {};
		if (message.isRecording !== false) {
			obj.isRecording = message.isRecording;
		}
		if (message.durationSeconds !== 0) {
			obj.durationSeconds = message.durationSeconds;
		}
		if (message.error !== "") {
			obj.error = message.error;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<RecordingStatus>, I>>(
		base?: I,
	): RecordingStatus {
		return RecordingStatus.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<RecordingStatus>, I>>(
		object: I,
	): RecordingStatus {
		const message = createBaseRecordingStatus();
		message.isRecording = object.isRecording ?? false;
		message.durationSeconds = object.durationSeconds ?? 0;
		message.error = object.error ?? "";
		return message;
	},
};

function createBaseTranscription(): Transcription {
	return { text: "", error: "" };
}

export const Transcription: MessageFns<Transcription> = {
	encode(
		message: Transcription,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.text !== "") {
			writer.uint32(10).string(message.text);
		}
		if (message.error !== "") {
			writer.uint32(18).string(message.error);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Transcription {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseTranscription();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.text = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.error = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Transcription {
		return {
			text: isSet(object.text) ? globalThis.String(object.text) : "",
			error: isSet(object.error) ? globalThis.String(object.error) : "",
		};
	},

	toJSON(message: Transcription): unknown {
		const obj: any = {};
		if (message.text !== "") {
			obj.text = message.text;
		}
		if (message.error !== "") {
			obj.error = message.error;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Transcription>, I>>(
		base?: I,
	): Transcription {
		return Transcription.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Transcription>, I>>(
		object: I,
	): Transcription {
		const message = createBaseTranscription();
		message.text = object.text ?? "";
		message.error = object.error ?? "";
		return message;
	},
};

export type DictationServiceDefinition = typeof DictationServiceDefinition;
export const DictationServiceDefinition = {
	name: "DictationService",
	fullName: "cline.DictationService",
	methods: {
		startRecording: {
			name: "startRecording",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: RecordingResult,
			responseStream: false,
			options: {},
		},
		stopRecording: {
			name: "stopRecording",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: RecordedAudio,
			responseStream: false,
			options: {},
		},
		cancelRecording: {
			name: "cancelRecording",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: RecordingResult,
			responseStream: false,
			options: {},
		},
		getRecordingStatus: {
			name: "getRecordingStatus",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: RecordingStatus,
			responseStream: false,
			options: {},
		},
		transcribeAudio: {
			name: "transcribeAudio",
			requestType: TranscribeAudioRequest,
			requestStream: false,
			responseType: Transcription,
			responseStream: false,
			options: {},
		},
	},
} as const;

export type DictationServiceService = typeof DictationServiceService;
export const DictationServiceService = {
	startRecording: {
		path: "/cline.DictationService/startRecording",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: EmptyRequest): Buffer =>
			Buffer.from(EmptyRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): EmptyRequest =>
			EmptyRequest.decode(value),
		responseSerialize: (value: RecordingResult): Buffer =>
			Buffer.from(RecordingResult.encode(value).finish()),
		responseDeserialize: (value: Buffer): RecordingResult =>
			RecordingResult.decode(value),
	},
	stopRecording: {
		path: "/cline.DictationService/stopRecording",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: EmptyRequest): Buffer =>
			Buffer.from(EmptyRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): EmptyRequest =>
			EmptyRequest.decode(value),
		responseSerialize: (value: RecordedAudio): Buffer =>
			Buffer.from(RecordedAudio.encode(value).finish()),
		responseDeserialize: (value: Buffer): RecordedAudio =>
			RecordedAudio.decode(value),
	},
	cancelRecording: {
		path: "/cline.DictationService/cancelRecording",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: EmptyRequest): Buffer =>
			Buffer.from(EmptyRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): EmptyRequest =>
			EmptyRequest.decode(value),
		responseSerialize: (value: RecordingResult): Buffer =>
			Buffer.from(RecordingResult.encode(value).finish()),
		responseDeserialize: (value: Buffer): RecordingResult =>
			RecordingResult.decode(value),
	},
	getRecordingStatus: {
		path: "/cline.DictationService/getRecordingStatus",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: EmptyRequest): Buffer =>
			Buffer.from(EmptyRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): EmptyRequest =>
			EmptyRequest.decode(value),
		responseSerialize: (value: RecordingStatus): Buffer =>
			Buffer.from(RecordingStatus.encode(value).finish()),
		responseDeserialize: (value: Buffer): RecordingStatus =>
			RecordingStatus.decode(value),
	},
	transcribeAudio: {
		path: "/cline.DictationService/transcribeAudio",
		requestStream: false,
		responseStream: false,
		requestSerialize: (value: TranscribeAudioRequest): Buffer =>
			Buffer.from(TranscribeAudioRequest.encode(value).finish()),
		requestDeserialize: (value: Buffer): TranscribeAudioRequest =>
			TranscribeAudioRequest.decode(value),
		responseSerialize: (value: Transcription): Buffer =>
			Buffer.from(Transcription.encode(value).finish()),
		responseDeserialize: (value: Buffer): Transcription =>
			Transcription.decode(value),
	},
} as const;

export interface DictationServiceServer extends UntypedServiceImplementation {
	startRecording: handleUnaryCall<EmptyRequest, RecordingResult>;
	stopRecording: handleUnaryCall<EmptyRequest, RecordedAudio>;
	cancelRecording: handleUnaryCall<EmptyRequest, RecordingResult>;
	getRecordingStatus: handleUnaryCall<EmptyRequest, RecordingStatus>;
	transcribeAudio: handleUnaryCall<TranscribeAudioRequest, Transcription>;
}

export interface DictationServiceClient extends Client {
	startRecording(
		request: EmptyRequest,
		callback: (error: ServiceError | null, response: RecordingResult) => void,
	): ClientUnaryCall;
	startRecording(
		request: EmptyRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: RecordingResult) => void,
	): ClientUnaryCall;
	startRecording(
		request: EmptyRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: RecordingResult) => void,
	): ClientUnaryCall;
	stopRecording(
		request: EmptyRequest,
		callback: (error: ServiceError | null, response: RecordedAudio) => void,
	): ClientUnaryCall;
	stopRecording(
		request: EmptyRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: RecordedAudio) => void,
	): ClientUnaryCall;
	stopRecording(
		request: EmptyRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: RecordedAudio) => void,
	): ClientUnaryCall;
	cancelRecording(
		request: EmptyRequest,
		callback: (error: ServiceError | null, response: RecordingResult) => void,
	): ClientUnaryCall;
	cancelRecording(
		request: EmptyRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: RecordingResult) => void,
	): ClientUnaryCall;
	cancelRecording(
		request: EmptyRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: RecordingResult) => void,
	): ClientUnaryCall;
	getRecordingStatus(
		request: EmptyRequest,
		callback: (error: ServiceError | null, response: RecordingStatus) => void,
	): ClientUnaryCall;
	getRecordingStatus(
		request: EmptyRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: RecordingStatus) => void,
	): ClientUnaryCall;
	getRecordingStatus(
		request: EmptyRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: RecordingStatus) => void,
	): ClientUnaryCall;
	transcribeAudio(
		request: TranscribeAudioRequest,
		callback: (error: ServiceError | null, response: Transcription) => void,
	): ClientUnaryCall;
	transcribeAudio(
		request: TranscribeAudioRequest,
		metadata: Metadata,
		callback: (error: ServiceError | null, response: Transcription) => void,
	): ClientUnaryCall;
	transcribeAudio(
		request: TranscribeAudioRequest,
		metadata: Metadata,
		options: Partial<CallOptions>,
		callback: (error: ServiceError | null, response: Transcription) => void,
	): ClientUnaryCall;
}

export const DictationServiceClient = makeGenericClientConstructor(
	DictationServiceService,
	"cline.DictationService",
) as unknown as {
	new (
		address: string,
		credentials: ChannelCredentials,
		options?: Partial<ClientOptions>,
	): DictationServiceClient;
	service: typeof DictationServiceService;
	serviceName: string;
};

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & {
			[K in Exclude<keyof I, KeysOfUnion<P>>]: never;
		};

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

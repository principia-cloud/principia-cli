// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: host/env.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import { Empty, EmptyRequest, String, StringRequest } from "../cline/common";

export enum Setting {
	/** UNSUPPORTED - This host does not support this setting. */
	UNSUPPORTED = 0,
	ENABLED = 1,
	DISABLED = 2,
	UNRECOGNIZED = -1,
}

export function settingFromJSON(object: any): Setting {
	switch (object) {
		case 0:
		case "UNSUPPORTED":
			return Setting.UNSUPPORTED;
		case 1:
		case "ENABLED":
			return Setting.ENABLED;
		case 2:
		case "DISABLED":
			return Setting.DISABLED;
		case -1:
		case "UNRECOGNIZED":
		default:
			return Setting.UNRECOGNIZED;
	}
}

export function settingToJSON(object: Setting): string {
	switch (object) {
		case Setting.UNSUPPORTED:
			return "UNSUPPORTED";
		case Setting.ENABLED:
			return "ENABLED";
		case Setting.DISABLED:
			return "DISABLED";
		case Setting.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED";
	}
}

export interface GetHostVersionResponse {
	/** The name of the host platform, e.g VSCode, IntelliJ Ultimate Edition, etc. */
	platform?: string | undefined;
	/** The version of the host platform, e.g. 1.103.0 for VSCode, or 2025.1.1.1 for JetBrains IDEs. */
	version?: string | undefined;
	/**
	 * The type of the cline host environment, e.g. 'VSCode Extension', 'Cline for JetBrains', 'CLI'
	 * This is different from the platform because there are many JetBrains IDEs, but they all use the same
	 * plugin.
	 */
	clineType?: string | undefined;
	/** The version of the cline host environment, e.g. 33.2.10 for extension, or 1.0.6 for JetBrains. */
	clineVersion?: string | undefined;
}

export interface GetTelemetrySettingsResponse {
	isEnabled: Setting;
	errorLevel?: string | undefined;
}

export interface TelemetrySettingsEvent {
	isEnabled: Setting;
	errorLevel?: string | undefined;
}

function createBaseGetHostVersionResponse(): GetHostVersionResponse {
	return {
		platform: undefined,
		version: undefined,
		clineType: undefined,
		clineVersion: undefined,
	};
}

export const GetHostVersionResponse: MessageFns<GetHostVersionResponse> = {
	encode(
		message: GetHostVersionResponse,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.platform !== undefined) {
			writer.uint32(10).string(message.platform);
		}
		if (message.version !== undefined) {
			writer.uint32(18).string(message.version);
		}
		if (message.clineType !== undefined) {
			writer.uint32(26).string(message.clineType);
		}
		if (message.clineVersion !== undefined) {
			writer.uint32(34).string(message.clineVersion);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): GetHostVersionResponse {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseGetHostVersionResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.platform = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.version = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.clineType = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.clineVersion = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): GetHostVersionResponse {
		return {
			platform: isSet(object.platform)
				? globalThis.String(object.platform)
				: undefined,
			version: isSet(object.version)
				? globalThis.String(object.version)
				: undefined,
			clineType: isSet(object.clineType)
				? globalThis.String(object.clineType)
				: isSet(object.cline_type)
					? globalThis.String(object.cline_type)
					: undefined,
			clineVersion: isSet(object.clineVersion)
				? globalThis.String(object.clineVersion)
				: isSet(object.cline_version)
					? globalThis.String(object.cline_version)
					: undefined,
		};
	},

	toJSON(message: GetHostVersionResponse): unknown {
		const obj: any = {};
		if (message.platform !== undefined) {
			obj.platform = message.platform;
		}
		if (message.version !== undefined) {
			obj.version = message.version;
		}
		if (message.clineType !== undefined) {
			obj.clineType = message.clineType;
		}
		if (message.clineVersion !== undefined) {
			obj.clineVersion = message.clineVersion;
		}
		return obj;
	},

	create(base?: DeepPartial<GetHostVersionResponse>): GetHostVersionResponse {
		return GetHostVersionResponse.fromPartial(base ?? {});
	},
	fromPartial(
		object: DeepPartial<GetHostVersionResponse>,
	): GetHostVersionResponse {
		const message = createBaseGetHostVersionResponse();
		message.platform = object.platform ?? undefined;
		message.version = object.version ?? undefined;
		message.clineType = object.clineType ?? undefined;
		message.clineVersion = object.clineVersion ?? undefined;
		return message;
	},
};

function createBaseGetTelemetrySettingsResponse(): GetTelemetrySettingsResponse {
	return { isEnabled: 0, errorLevel: undefined };
}

export const GetTelemetrySettingsResponse: MessageFns<GetTelemetrySettingsResponse> =
	{
		encode(
			message: GetTelemetrySettingsResponse,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.isEnabled !== 0) {
				writer.uint32(8).int32(message.isEnabled);
			}
			if (message.errorLevel !== undefined) {
				writer.uint32(18).string(message.errorLevel);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): GetTelemetrySettingsResponse {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseGetTelemetrySettingsResponse();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 8) {
							break;
						}

						message.isEnabled = reader.int32() as any;
						continue;
					}
					case 2: {
						if (tag !== 18) {
							break;
						}

						message.errorLevel = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): GetTelemetrySettingsResponse {
			return {
				isEnabled: isSet(object.isEnabled)
					? settingFromJSON(object.isEnabled)
					: isSet(object.is_enabled)
						? settingFromJSON(object.is_enabled)
						: 0,
				errorLevel: isSet(object.errorLevel)
					? globalThis.String(object.errorLevel)
					: isSet(object.error_level)
						? globalThis.String(object.error_level)
						: undefined,
			};
		},

		toJSON(message: GetTelemetrySettingsResponse): unknown {
			const obj: any = {};
			if (message.isEnabled !== 0) {
				obj.isEnabled = settingToJSON(message.isEnabled);
			}
			if (message.errorLevel !== undefined) {
				obj.errorLevel = message.errorLevel;
			}
			return obj;
		},

		create(
			base?: DeepPartial<GetTelemetrySettingsResponse>,
		): GetTelemetrySettingsResponse {
			return GetTelemetrySettingsResponse.fromPartial(base ?? {});
		},
		fromPartial(
			object: DeepPartial<GetTelemetrySettingsResponse>,
		): GetTelemetrySettingsResponse {
			const message = createBaseGetTelemetrySettingsResponse();
			message.isEnabled = object.isEnabled ?? 0;
			message.errorLevel = object.errorLevel ?? undefined;
			return message;
		},
	};

function createBaseTelemetrySettingsEvent(): TelemetrySettingsEvent {
	return { isEnabled: 0, errorLevel: undefined };
}

export const TelemetrySettingsEvent: MessageFns<TelemetrySettingsEvent> = {
	encode(
		message: TelemetrySettingsEvent,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.isEnabled !== 0) {
			writer.uint32(8).int32(message.isEnabled);
		}
		if (message.errorLevel !== undefined) {
			writer.uint32(18).string(message.errorLevel);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): TelemetrySettingsEvent {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseTelemetrySettingsEvent();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.isEnabled = reader.int32() as any;
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.errorLevel = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): TelemetrySettingsEvent {
		return {
			isEnabled: isSet(object.isEnabled)
				? settingFromJSON(object.isEnabled)
				: isSet(object.is_enabled)
					? settingFromJSON(object.is_enabled)
					: 0,
			errorLevel: isSet(object.errorLevel)
				? globalThis.String(object.errorLevel)
				: isSet(object.error_level)
					? globalThis.String(object.error_level)
					: undefined,
		};
	},

	toJSON(message: TelemetrySettingsEvent): unknown {
		const obj: any = {};
		if (message.isEnabled !== 0) {
			obj.isEnabled = settingToJSON(message.isEnabled);
		}
		if (message.errorLevel !== undefined) {
			obj.errorLevel = message.errorLevel;
		}
		return obj;
	},

	create(base?: DeepPartial<TelemetrySettingsEvent>): TelemetrySettingsEvent {
		return TelemetrySettingsEvent.fromPartial(base ?? {});
	},
	fromPartial(
		object: DeepPartial<TelemetrySettingsEvent>,
	): TelemetrySettingsEvent {
		const message = createBaseTelemetrySettingsEvent();
		message.isEnabled = object.isEnabled ?? 0;
		message.errorLevel = object.errorLevel ?? undefined;
		return message;
	},
};

/** Provides methods for working with the user's environment. */
export type EnvServiceDefinition = typeof EnvServiceDefinition;
export const EnvServiceDefinition = {
	name: "EnvService",
	fullName: "host.EnvService",
	methods: {
		/** Writes text to the system clipboard. */
		clipboardWriteText: {
			name: "clipboardWriteText",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/** Reads text from the system clipboard. */
		clipboardReadText: {
			name: "clipboardReadText",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: String,
			responseStream: false,
			options: {},
		},
		/** Returns the name and version of the host IDE or environment. */
		getHostVersion: {
			name: "getHostVersion",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: GetHostVersionResponse,
			responseStream: false,
			options: {},
		},
		/**
		 * Returns a URI that will redirect to the host environment.
		 * e.g. vscode://saoudrizwan.claude-dev, idea://, pycharm://, etc.
		 * If the host does not support URIs it should return empty.
		 */
		getIdeRedirectUri: {
			name: "getIdeRedirectUri",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: String,
			responseStream: false,
			options: {},
		},
		/**
		 * Returns the telemetry settings of the host environment. This may return UNSUPPORTED
		 * if the host does not specify telemetry settings for the plugin.
		 */
		getTelemetrySettings: {
			name: "getTelemetrySettings",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: GetTelemetrySettingsResponse,
			responseStream: false,
			options: {},
		},
		/** Returns events when the telemetry settings change. */
		subscribeToTelemetrySettings: {
			name: "subscribeToTelemetrySettings",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: TelemetrySettingsEvent,
			responseStream: true,
			options: {},
		},
		/** Initiates a graceful shutdown of the host bridge service. */
		shutdown: {
			name: "shutdown",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/** Logs a debug message to the host environment's log/output console. */
		debugLog: {
			name: "debugLog",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/**
		 * Opens an external URL in the default browser.
		 * In remote environments (VS Code Server, SSH, etc.), this routes the URL
		 * to the user's local machine to open in their local browser.
		 */
		openExternal: {
			name: "openExternal",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
	},
} as const;

export interface EnvServiceImplementation<CallContextExt = {}> {
	/** Writes text to the system clipboard. */
	clipboardWriteText(
		request: StringRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<Empty>>;
	/** Reads text from the system clipboard. */
	clipboardReadText(
		request: EmptyRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<String>>;
	/** Returns the name and version of the host IDE or environment. */
	getHostVersion(
		request: EmptyRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<GetHostVersionResponse>>;
	/**
	 * Returns a URI that will redirect to the host environment.
	 * e.g. vscode://saoudrizwan.claude-dev, idea://, pycharm://, etc.
	 * If the host does not support URIs it should return empty.
	 */
	getIdeRedirectUri(
		request: EmptyRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<String>>;
	/**
	 * Returns the telemetry settings of the host environment. This may return UNSUPPORTED
	 * if the host does not specify telemetry settings for the plugin.
	 */
	getTelemetrySettings(
		request: EmptyRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<GetTelemetrySettingsResponse>>;
	/** Returns events when the telemetry settings change. */
	subscribeToTelemetrySettings(
		request: EmptyRequest,
		context: CallContext & CallContextExt,
	): ServerStreamingMethodResult<DeepPartial<TelemetrySettingsEvent>>;
	/** Initiates a graceful shutdown of the host bridge service. */
	shutdown(
		request: EmptyRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<Empty>>;
	/** Logs a debug message to the host environment's log/output console. */
	debugLog(
		request: StringRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<Empty>>;
	/**
	 * Opens an external URL in the default browser.
	 * In remote environments (VS Code Server, SSH, etc.), this routes the URL
	 * to the user's local machine to open in their local browser.
	 */
	openExternal(
		request: StringRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<Empty>>;
}

export interface EnvServiceClient<CallOptionsExt = {}> {
	/** Writes text to the system clipboard. */
	clipboardWriteText(
		request: DeepPartial<StringRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<Empty>;
	/** Reads text from the system clipboard. */
	clipboardReadText(
		request: DeepPartial<EmptyRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<String>;
	/** Returns the name and version of the host IDE or environment. */
	getHostVersion(
		request: DeepPartial<EmptyRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<GetHostVersionResponse>;
	/**
	 * Returns a URI that will redirect to the host environment.
	 * e.g. vscode://saoudrizwan.claude-dev, idea://, pycharm://, etc.
	 * If the host does not support URIs it should return empty.
	 */
	getIdeRedirectUri(
		request: DeepPartial<EmptyRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<String>;
	/**
	 * Returns the telemetry settings of the host environment. This may return UNSUPPORTED
	 * if the host does not specify telemetry settings for the plugin.
	 */
	getTelemetrySettings(
		request: DeepPartial<EmptyRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<GetTelemetrySettingsResponse>;
	/** Returns events when the telemetry settings change. */
	subscribeToTelemetrySettings(
		request: DeepPartial<EmptyRequest>,
		options?: CallOptions & CallOptionsExt,
	): AsyncIterable<TelemetrySettingsEvent>;
	/** Initiates a graceful shutdown of the host bridge service. */
	shutdown(
		request: DeepPartial<EmptyRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<Empty>;
	/** Logs a debug message to the host environment's log/output console. */
	debugLog(
		request: DeepPartial<StringRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<Empty>;
	/**
	 * Opens an external URL in the default browser.
	 * In remote environments (VS Code Server, SSH, etc.), this routes the URL
	 * to the user's local machine to open in their local browser.
	 */
	openExternal(
		request: DeepPartial<StringRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<Empty>;
}

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

type ServerStreamingMethodResult<Response> = {
	[Symbol.asyncIterator](): AsyncIterator<Response, void>;
};

interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create(base?: DeepPartial<T>): T;
	fromPartial(object: DeepPartial<T>): T;
}

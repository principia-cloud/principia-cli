// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: cline/slash.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import { Empty, EmptyRequest, StringRequest } from "./common";

/** Slash command definition for autocomplete */
export interface SlashCommandInfo {
	/** Command name without slash, e.g., "newtask", "smol" */
	name: string;
	/** Human-readable description */
	description: string;
	/** "default", "custom", or "cli" */
	section: string;
	/** false for VS Code-only commands like explain-changes */
	cliCompatible: boolean;
}

/** Response containing all available slash commands */
export interface SlashCommandsResponse {
	commands: SlashCommandInfo[];
}

function createBaseSlashCommandInfo(): SlashCommandInfo {
	return { name: "", description: "", section: "", cliCompatible: false };
}

export const SlashCommandInfo: MessageFns<SlashCommandInfo> = {
	encode(
		message: SlashCommandInfo,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.name !== "") {
			writer.uint32(10).string(message.name);
		}
		if (message.description !== "") {
			writer.uint32(18).string(message.description);
		}
		if (message.section !== "") {
			writer.uint32(26).string(message.section);
		}
		if (message.cliCompatible !== false) {
			writer.uint32(32).bool(message.cliCompatible);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SlashCommandInfo {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseSlashCommandInfo();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.name = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.description = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.section = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.cliCompatible = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): SlashCommandInfo {
		return {
			name: isSet(object.name) ? globalThis.String(object.name) : "",
			description: isSet(object.description)
				? globalThis.String(object.description)
				: "",
			section: isSet(object.section) ? globalThis.String(object.section) : "",
			cliCompatible: isSet(object.cliCompatible)
				? globalThis.Boolean(object.cliCompatible)
				: isSet(object.cli_compatible)
					? globalThis.Boolean(object.cli_compatible)
					: false,
		};
	},

	toJSON(message: SlashCommandInfo): unknown {
		const obj: any = {};
		if (message.name !== "") {
			obj.name = message.name;
		}
		if (message.description !== "") {
			obj.description = message.description;
		}
		if (message.section !== "") {
			obj.section = message.section;
		}
		if (message.cliCompatible !== false) {
			obj.cliCompatible = message.cliCompatible;
		}
		return obj;
	},

	create(base?: DeepPartial<SlashCommandInfo>): SlashCommandInfo {
		return SlashCommandInfo.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<SlashCommandInfo>): SlashCommandInfo {
		const message = createBaseSlashCommandInfo();
		message.name = object.name ?? "";
		message.description = object.description ?? "";
		message.section = object.section ?? "";
		message.cliCompatible = object.cliCompatible ?? false;
		return message;
	},
};

function createBaseSlashCommandsResponse(): SlashCommandsResponse {
	return { commands: [] };
}

export const SlashCommandsResponse: MessageFns<SlashCommandsResponse> = {
	encode(
		message: SlashCommandsResponse,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		for (const v of message.commands) {
			SlashCommandInfo.encode(v!, writer.uint32(10).fork()).join();
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): SlashCommandsResponse {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseSlashCommandsResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.commands.push(
						SlashCommandInfo.decode(reader, reader.uint32()),
					);
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): SlashCommandsResponse {
		return {
			commands: globalThis.Array.isArray(object?.commands)
				? object.commands.map((e: any) => SlashCommandInfo.fromJSON(e))
				: [],
		};
	},

	toJSON(message: SlashCommandsResponse): unknown {
		const obj: any = {};
		if (message.commands?.length) {
			obj.commands = message.commands.map((e) => SlashCommandInfo.toJSON(e));
		}
		return obj;
	},

	create(base?: DeepPartial<SlashCommandsResponse>): SlashCommandsResponse {
		return SlashCommandsResponse.fromPartial(base ?? {});
	},
	fromPartial(
		object: DeepPartial<SlashCommandsResponse>,
	): SlashCommandsResponse {
		const message = createBaseSlashCommandsResponse();
		message.commands =
			object.commands?.map((e) => SlashCommandInfo.fromPartial(e)) || [];
		return message;
	},
};

/** SlashService provides methods for managing slash commands */
export type SlashServiceDefinition = typeof SlashServiceDefinition;
export const SlashServiceDefinition = {
	name: "SlashService",
	fullName: "cline.SlashService",
	methods: {
		/** Sends button click message */
		reportBug: {
			name: "reportBug",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		condense: {
			name: "condense",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/** Get available slash commands for autocomplete (used by CLI) */
		getAvailableSlashCommands: {
			name: "getAvailableSlashCommands",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: SlashCommandsResponse,
			responseStream: false,
			options: {},
		},
	},
} as const;

export interface SlashServiceImplementation<CallContextExt = {}> {
	/** Sends button click message */
	reportBug(
		request: StringRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<Empty>>;
	condense(
		request: StringRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<Empty>>;
	/** Get available slash commands for autocomplete (used by CLI) */
	getAvailableSlashCommands(
		request: EmptyRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<SlashCommandsResponse>>;
}

export interface SlashServiceClient<CallOptionsExt = {}> {
	/** Sends button click message */
	reportBug(
		request: DeepPartial<StringRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<Empty>;
	condense(
		request: DeepPartial<StringRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<Empty>;
	/** Get available slash commands for autocomplete (used by CLI) */
	getAvailableSlashCommands(
		request: DeepPartial<EmptyRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<SlashCommandsResponse>;
}

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create(base?: DeepPartial<T>): T;
	fromPartial(object: DeepPartial<T>): T;
}

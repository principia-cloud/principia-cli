// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: cline/file.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import {
	BooleanRequest,
	BooleanResponse,
	Empty,
	EmptyRequest,
	Metadata,
	StringArrays,
	StringRequest,
} from "./common";

/** Enum for file search type filtering */
export enum FileSearchType {
	FILE = 0,
	FOLDER = 1,
	UNRECOGNIZED = -1,
}

export function fileSearchTypeFromJSON(object: any): FileSearchType {
	switch (object) {
		case 0:
		case "FILE":
			return FileSearchType.FILE;
		case 1:
		case "FOLDER":
			return FileSearchType.FOLDER;
		case -1:
		case "UNRECOGNIZED":
		default:
			return FileSearchType.UNRECOGNIZED;
	}
}

export function fileSearchTypeToJSON(object: FileSearchType): string {
	switch (object) {
		case FileSearchType.FILE:
			return "FILE";
		case FileSearchType.FOLDER:
			return "FOLDER";
		case FileSearchType.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED";
	}
}

/** Enum for rule scope (local, global, or remote) */
export enum RuleScope {
	LOCAL = 0,
	GLOBAL = 1,
	REMOTE = 2,
	UNRECOGNIZED = -1,
}

export function ruleScopeFromJSON(object: any): RuleScope {
	switch (object) {
		case 0:
		case "LOCAL":
			return RuleScope.LOCAL;
		case 1:
		case "GLOBAL":
			return RuleScope.GLOBAL;
		case 2:
		case "REMOTE":
			return RuleScope.REMOTE;
		case -1:
		case "UNRECOGNIZED":
		default:
			return RuleScope.UNRECOGNIZED;
	}
}

export function ruleScopeToJSON(object: RuleScope): string {
	switch (object) {
		case RuleScope.LOCAL:
			return "LOCAL";
		case RuleScope.GLOBAL:
			return "GLOBAL";
		case RuleScope.REMOTE:
			return "REMOTE";
		case RuleScope.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED";
	}
}

/** Response for refreshRules operation */
export interface RefreshedRules {
	globalClineRulesToggles: ClineRulesToggles | undefined;
	localClineRulesToggles: ClineRulesToggles | undefined;
	localCursorRulesToggles: ClineRulesToggles | undefined;
	localWindsurfRulesToggles: ClineRulesToggles | undefined;
	localAgentsRulesToggles: ClineRulesToggles | undefined;
	localWorkflowToggles: ClineRulesToggles | undefined;
	globalWorkflowToggles: ClineRulesToggles | undefined;
}

/** Request to toggle a Windsurf rule */
export interface ToggleWindsurfRuleRequest {
	metadata: Metadata | undefined;
	/** Path to the rule file */
	rulePath: string;
	/** Whether to enable or disable the rule */
	enabled: boolean;
}

/** Request to toggle an Agents rule */
export interface ToggleAgentsRuleRequest {
	metadata: Metadata | undefined;
	/** Path to the rule file */
	rulePath: string;
	/** Whether to enable or disable the rule */
	enabled: boolean;
}

/** Request to convert a list of URIs to relative paths */
export interface RelativePathsRequest {
	metadata: Metadata | undefined;
	uris: string[];
}

/** Response containing the converted relative paths */
export interface RelativePaths {
	paths: string[];
}

/** Request for file search operations */
export interface FileSearchRequest {
	metadata: Metadata | undefined;
	/** Search query string */
	query: string;
	/** Optional request ID for tracking requests */
	mentionsRequestId?: string | undefined;
	/** Optional limit for results (default: 20) */
	limit?: number | undefined;
	/** Optional selected type filter */
	selectedType?: FileSearchType | undefined;
	/** Optional workspace name to search in */
	workspaceHint?: string | undefined;
}

/** Result for file search operations */
export interface FileSearchResults {
	/** Array of file/folder results */
	results: FileInfo[];
	/** Echo of the request ID for tracking */
	mentionsRequestId?: string | undefined;
}

/** File information structure for search results */
export interface FileInfo {
	/** Relative path from workspace root */
	path: string;
	/** "file" or "folder" */
	type: string;
	/** Display name (usually basename) */
	label?: string | undefined;
	/** Workspace this result came from */
	workspaceName?: string | undefined;
}

/** Response for searchCommits */
export interface GitCommits {
	commits: GitCommit[];
}

/** Represents a Git commit */
export interface GitCommit {
	hash: string;
	shortHash: string;
	subject: string;
	author: string;
	date: string;
}

/** Unified request for all rule file operations */
export interface RuleFileRequest {
	metadata: Metadata | undefined;
	/** Common field for all operations */
	isGlobal: boolean;
	/** Path field for deleteRuleFile (optional) */
	rulePath?: string | undefined;
	/** Filename field for createRuleFile (optional) */
	filename?: string | undefined;
	/** Type of the file to create (optional) */
	type?: string | undefined;
}

/** Result for rule file operations with meaningful data only */
export interface RuleFile {
	/** Path to the rule file */
	filePath: string;
	/** Filename for display purposes */
	displayName: string;
	/** For createRuleFile, indicates if file already existed */
	alreadyExists: boolean;
}

/** Request to toggle a Cline rule */
export interface ToggleClineRuleRequest {
	metadata: Metadata | undefined;
	/** Scope of the rule (local, global, or remote) */
	scope: RuleScope;
	/** Path to the rule file */
	rulePath: string;
	/** Whether to enable or disable the rule */
	enabled: boolean;
}

/** Maps from filepath to enabled/disabled status, matching app's ClineRulesToggles type */
export interface ClineRulesToggles {
	toggles: { [key: string]: boolean };
}

export interface ClineRulesToggles_TogglesEntry {
	key: string;
	value: boolean;
}

/** Response for toggleClineRule operation */
export interface ToggleClineRules {
	globalClineRulesToggles: ClineRulesToggles | undefined;
	localClineRulesToggles: ClineRulesToggles | undefined;
	remoteRulesToggles: ClineRulesToggles | undefined;
}

/** Request to toggle a Cursor rule */
export interface ToggleCursorRuleRequest {
	metadata: Metadata | undefined;
	/** Path to the rule file */
	rulePath: string;
	/** Whether to enable or disable the rule */
	enabled: boolean;
}

/** Request to toggle a workflow on or off */
export interface ToggleWorkflowRequest {
	metadata: Metadata | undefined;
	workflowPath: string;
	enabled: boolean;
	/** Scope of the workflow (local, global, or remote) */
	scope: RuleScope;
}

/** Maps from hook name to enabled/disabled status */
export interface HookInfo {
	name: string;
	enabled: boolean;
	absolutePath: string;
}

export interface WorkspaceHooks {
	workspaceName: string;
	hooks: HookInfo[];
}

export interface HooksToggles {
	globalHooks: HookInfo[];
	workspaceHooks: WorkspaceHooks[];
	/** Whether the system is Windows (toggles disabled) */
	isWindows: boolean;
}

/** Request to toggle a hook */
export interface ToggleHookRequest {
	metadata: Metadata | undefined;
	/** Name of the hook (e.g., "TaskStart") */
	hookName: string;
	/** Whether this is a global or workspace hook */
	isGlobal: boolean;
	/** Whether to enable (chmod +x) or disable (chmod -x) */
	enabled: boolean;
	/** For multi-root workspaces, specifies which workspace */
	workspaceName?: string | undefined;
}

/** Response for toggleHook operation */
export interface ToggleHookResponse {
	hooksToggles: HooksToggles | undefined;
}

/** Request to create a hook */
export interface CreateHookRequest {
	metadata: Metadata | undefined;
	/** Name of the hook to create */
	hookName: string;
	/** Whether to create in global or workspace hooks directory */
	isGlobal: boolean;
	/** For multi-root workspaces, specifies which workspace */
	workspaceName?: string | undefined;
}

/** Response for createHook operation */
export interface CreateHookResponse {
	hooksToggles: HooksToggles | undefined;
}

/** Request to delete a hook */
export interface DeleteHookRequest {
	metadata: Metadata | undefined;
	/** Name of the hook to delete */
	hookName: string;
	/** Whether this is a global or workspace hook */
	isGlobal: boolean;
	/** For multi-root workspaces, specifies which workspace */
	workspaceName?: string | undefined;
}

/** Response for deleteHook operation */
export interface DeleteHookResponse {
	hooksToggles: HooksToggles | undefined;
}

/** Skill information structure */
export interface SkillInfo {
	/** Name of the skill (matches directory name) */
	name: string;
	/** Description from SKILL.md frontmatter */
	description: string;
	/** Full path to SKILL.md file */
	path: string;
	/** Whether the skill is enabled */
	enabled: boolean;
}

/** Response for refreshSkills operation */
export interface RefreshedSkills {
	globalSkills: SkillInfo[];
	localSkills: SkillInfo[];
}

/** Maps from skill path to enabled/disabled status */
export interface SkillsToggles {
	globalSkillsToggles: { [key: string]: boolean };
	localSkillsToggles: { [key: string]: boolean };
}

export interface SkillsToggles_GlobalSkillsTogglesEntry {
	key: string;
	value: boolean;
}

export interface SkillsToggles_LocalSkillsTogglesEntry {
	key: string;
	value: boolean;
}

/** Request to toggle a skill */
export interface ToggleSkillRequest {
	metadata: Metadata | undefined;
	/** Path to the skill directory */
	skillPath: string;
	/** Whether this is a global or workspace skill */
	isGlobal: boolean;
	/** Whether to enable or disable the skill */
	enabled: boolean;
}

/** Request to create a skill */
export interface CreateSkillRequest {
	metadata: Metadata | undefined;
	/** Name of the skill to create */
	skillName: string;
	/** Whether to create in global or workspace skills directory */
	isGlobal: boolean;
}

/** Request to delete a skill */
export interface DeleteSkillRequest {
	metadata: Metadata | undefined;
	/** Path to the skill directory */
	skillPath: string;
	/** Whether this is a global or workspace skill */
	isGlobal: boolean;
}

function createBaseRefreshedRules(): RefreshedRules {
	return {
		globalClineRulesToggles: undefined,
		localClineRulesToggles: undefined,
		localCursorRulesToggles: undefined,
		localWindsurfRulesToggles: undefined,
		localAgentsRulesToggles: undefined,
		localWorkflowToggles: undefined,
		globalWorkflowToggles: undefined,
	};
}

export const RefreshedRules: MessageFns<RefreshedRules> = {
	encode(
		message: RefreshedRules,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.globalClineRulesToggles !== undefined) {
			ClineRulesToggles.encode(
				message.globalClineRulesToggles,
				writer.uint32(10).fork(),
			).join();
		}
		if (message.localClineRulesToggles !== undefined) {
			ClineRulesToggles.encode(
				message.localClineRulesToggles,
				writer.uint32(18).fork(),
			).join();
		}
		if (message.localCursorRulesToggles !== undefined) {
			ClineRulesToggles.encode(
				message.localCursorRulesToggles,
				writer.uint32(26).fork(),
			).join();
		}
		if (message.localWindsurfRulesToggles !== undefined) {
			ClineRulesToggles.encode(
				message.localWindsurfRulesToggles,
				writer.uint32(34).fork(),
			).join();
		}
		if (message.localAgentsRulesToggles !== undefined) {
			ClineRulesToggles.encode(
				message.localAgentsRulesToggles,
				writer.uint32(42).fork(),
			).join();
		}
		if (message.localWorkflowToggles !== undefined) {
			ClineRulesToggles.encode(
				message.localWorkflowToggles,
				writer.uint32(50).fork(),
			).join();
		}
		if (message.globalWorkflowToggles !== undefined) {
			ClineRulesToggles.encode(
				message.globalWorkflowToggles,
				writer.uint32(58).fork(),
			).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RefreshedRules {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRefreshedRules();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.globalClineRulesToggles = ClineRulesToggles.decode(
						reader,
						reader.uint32(),
					);
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.localClineRulesToggles = ClineRulesToggles.decode(
						reader,
						reader.uint32(),
					);
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.localCursorRulesToggles = ClineRulesToggles.decode(
						reader,
						reader.uint32(),
					);
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.localWindsurfRulesToggles = ClineRulesToggles.decode(
						reader,
						reader.uint32(),
					);
					continue;
				}
				case 5: {
					if (tag !== 42) {
						break;
					}

					message.localAgentsRulesToggles = ClineRulesToggles.decode(
						reader,
						reader.uint32(),
					);
					continue;
				}
				case 6: {
					if (tag !== 50) {
						break;
					}

					message.localWorkflowToggles = ClineRulesToggles.decode(
						reader,
						reader.uint32(),
					);
					continue;
				}
				case 7: {
					if (tag !== 58) {
						break;
					}

					message.globalWorkflowToggles = ClineRulesToggles.decode(
						reader,
						reader.uint32(),
					);
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): RefreshedRules {
		return {
			globalClineRulesToggles: isSet(object.globalClineRulesToggles)
				? ClineRulesToggles.fromJSON(object.globalClineRulesToggles)
				: isSet(object.global_cline_rules_toggles)
					? ClineRulesToggles.fromJSON(object.global_cline_rules_toggles)
					: undefined,
			localClineRulesToggles: isSet(object.localClineRulesToggles)
				? ClineRulesToggles.fromJSON(object.localClineRulesToggles)
				: isSet(object.local_cline_rules_toggles)
					? ClineRulesToggles.fromJSON(object.local_cline_rules_toggles)
					: undefined,
			localCursorRulesToggles: isSet(object.localCursorRulesToggles)
				? ClineRulesToggles.fromJSON(object.localCursorRulesToggles)
				: isSet(object.local_cursor_rules_toggles)
					? ClineRulesToggles.fromJSON(object.local_cursor_rules_toggles)
					: undefined,
			localWindsurfRulesToggles: isSet(object.localWindsurfRulesToggles)
				? ClineRulesToggles.fromJSON(object.localWindsurfRulesToggles)
				: isSet(object.local_windsurf_rules_toggles)
					? ClineRulesToggles.fromJSON(object.local_windsurf_rules_toggles)
					: undefined,
			localAgentsRulesToggles: isSet(object.localAgentsRulesToggles)
				? ClineRulesToggles.fromJSON(object.localAgentsRulesToggles)
				: isSet(object.local_agents_rules_toggles)
					? ClineRulesToggles.fromJSON(object.local_agents_rules_toggles)
					: undefined,
			localWorkflowToggles: isSet(object.localWorkflowToggles)
				? ClineRulesToggles.fromJSON(object.localWorkflowToggles)
				: isSet(object.local_workflow_toggles)
					? ClineRulesToggles.fromJSON(object.local_workflow_toggles)
					: undefined,
			globalWorkflowToggles: isSet(object.globalWorkflowToggles)
				? ClineRulesToggles.fromJSON(object.globalWorkflowToggles)
				: isSet(object.global_workflow_toggles)
					? ClineRulesToggles.fromJSON(object.global_workflow_toggles)
					: undefined,
		};
	},

	toJSON(message: RefreshedRules): unknown {
		const obj: any = {};
		if (message.globalClineRulesToggles !== undefined) {
			obj.globalClineRulesToggles = ClineRulesToggles.toJSON(
				message.globalClineRulesToggles,
			);
		}
		if (message.localClineRulesToggles !== undefined) {
			obj.localClineRulesToggles = ClineRulesToggles.toJSON(
				message.localClineRulesToggles,
			);
		}
		if (message.localCursorRulesToggles !== undefined) {
			obj.localCursorRulesToggles = ClineRulesToggles.toJSON(
				message.localCursorRulesToggles,
			);
		}
		if (message.localWindsurfRulesToggles !== undefined) {
			obj.localWindsurfRulesToggles = ClineRulesToggles.toJSON(
				message.localWindsurfRulesToggles,
			);
		}
		if (message.localAgentsRulesToggles !== undefined) {
			obj.localAgentsRulesToggles = ClineRulesToggles.toJSON(
				message.localAgentsRulesToggles,
			);
		}
		if (message.localWorkflowToggles !== undefined) {
			obj.localWorkflowToggles = ClineRulesToggles.toJSON(
				message.localWorkflowToggles,
			);
		}
		if (message.globalWorkflowToggles !== undefined) {
			obj.globalWorkflowToggles = ClineRulesToggles.toJSON(
				message.globalWorkflowToggles,
			);
		}
		return obj;
	},

	create(base?: DeepPartial<RefreshedRules>): RefreshedRules {
		return RefreshedRules.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<RefreshedRules>): RefreshedRules {
		const message = createBaseRefreshedRules();
		message.globalClineRulesToggles =
			object.globalClineRulesToggles !== undefined &&
			object.globalClineRulesToggles !== null
				? ClineRulesToggles.fromPartial(object.globalClineRulesToggles)
				: undefined;
		message.localClineRulesToggles =
			object.localClineRulesToggles !== undefined &&
			object.localClineRulesToggles !== null
				? ClineRulesToggles.fromPartial(object.localClineRulesToggles)
				: undefined;
		message.localCursorRulesToggles =
			object.localCursorRulesToggles !== undefined &&
			object.localCursorRulesToggles !== null
				? ClineRulesToggles.fromPartial(object.localCursorRulesToggles)
				: undefined;
		message.localWindsurfRulesToggles =
			object.localWindsurfRulesToggles !== undefined &&
			object.localWindsurfRulesToggles !== null
				? ClineRulesToggles.fromPartial(object.localWindsurfRulesToggles)
				: undefined;
		message.localAgentsRulesToggles =
			object.localAgentsRulesToggles !== undefined &&
			object.localAgentsRulesToggles !== null
				? ClineRulesToggles.fromPartial(object.localAgentsRulesToggles)
				: undefined;
		message.localWorkflowToggles =
			object.localWorkflowToggles !== undefined &&
			object.localWorkflowToggles !== null
				? ClineRulesToggles.fromPartial(object.localWorkflowToggles)
				: undefined;
		message.globalWorkflowToggles =
			object.globalWorkflowToggles !== undefined &&
			object.globalWorkflowToggles !== null
				? ClineRulesToggles.fromPartial(object.globalWorkflowToggles)
				: undefined;
		return message;
	},
};

function createBaseToggleWindsurfRuleRequest(): ToggleWindsurfRuleRequest {
	return { metadata: undefined, rulePath: "", enabled: false };
}

export const ToggleWindsurfRuleRequest: MessageFns<ToggleWindsurfRuleRequest> =
	{
		encode(
			message: ToggleWindsurfRuleRequest,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.metadata !== undefined) {
				Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
			}
			if (message.rulePath !== "") {
				writer.uint32(18).string(message.rulePath);
			}
			if (message.enabled !== false) {
				writer.uint32(24).bool(message.enabled);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): ToggleWindsurfRuleRequest {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseToggleWindsurfRuleRequest();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.metadata = Metadata.decode(reader, reader.uint32());
						continue;
					}
					case 2: {
						if (tag !== 18) {
							break;
						}

						message.rulePath = reader.string();
						continue;
					}
					case 3: {
						if (tag !== 24) {
							break;
						}

						message.enabled = reader.bool();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): ToggleWindsurfRuleRequest {
			return {
				metadata: isSet(object.metadata)
					? Metadata.fromJSON(object.metadata)
					: undefined,
				rulePath: isSet(object.rulePath)
					? globalThis.String(object.rulePath)
					: isSet(object.rule_path)
						? globalThis.String(object.rule_path)
						: "",
				enabled: isSet(object.enabled)
					? globalThis.Boolean(object.enabled)
					: false,
			};
		},

		toJSON(message: ToggleWindsurfRuleRequest): unknown {
			const obj: any = {};
			if (message.metadata !== undefined) {
				obj.metadata = Metadata.toJSON(message.metadata);
			}
			if (message.rulePath !== "") {
				obj.rulePath = message.rulePath;
			}
			if (message.enabled !== false) {
				obj.enabled = message.enabled;
			}
			return obj;
		},

		create(
			base?: DeepPartial<ToggleWindsurfRuleRequest>,
		): ToggleWindsurfRuleRequest {
			return ToggleWindsurfRuleRequest.fromPartial(base ?? {});
		},
		fromPartial(
			object: DeepPartial<ToggleWindsurfRuleRequest>,
		): ToggleWindsurfRuleRequest {
			const message = createBaseToggleWindsurfRuleRequest();
			message.metadata =
				object.metadata !== undefined && object.metadata !== null
					? Metadata.fromPartial(object.metadata)
					: undefined;
			message.rulePath = object.rulePath ?? "";
			message.enabled = object.enabled ?? false;
			return message;
		},
	};

function createBaseToggleAgentsRuleRequest(): ToggleAgentsRuleRequest {
	return { metadata: undefined, rulePath: "", enabled: false };
}

export const ToggleAgentsRuleRequest: MessageFns<ToggleAgentsRuleRequest> = {
	encode(
		message: ToggleAgentsRuleRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.rulePath !== "") {
			writer.uint32(18).string(message.rulePath);
		}
		if (message.enabled !== false) {
			writer.uint32(24).bool(message.enabled);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): ToggleAgentsRuleRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseToggleAgentsRuleRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.rulePath = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.enabled = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): ToggleAgentsRuleRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata.fromJSON(object.metadata)
				: undefined,
			rulePath: isSet(object.rulePath)
				? globalThis.String(object.rulePath)
				: isSet(object.rule_path)
					? globalThis.String(object.rule_path)
					: "",
			enabled: isSet(object.enabled)
				? globalThis.Boolean(object.enabled)
				: false,
		};
	},

	toJSON(message: ToggleAgentsRuleRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		if (message.rulePath !== "") {
			obj.rulePath = message.rulePath;
		}
		if (message.enabled !== false) {
			obj.enabled = message.enabled;
		}
		return obj;
	},

	create(base?: DeepPartial<ToggleAgentsRuleRequest>): ToggleAgentsRuleRequest {
		return ToggleAgentsRuleRequest.fromPartial(base ?? {});
	},
	fromPartial(
		object: DeepPartial<ToggleAgentsRuleRequest>,
	): ToggleAgentsRuleRequest {
		const message = createBaseToggleAgentsRuleRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata.fromPartial(object.metadata)
				: undefined;
		message.rulePath = object.rulePath ?? "";
		message.enabled = object.enabled ?? false;
		return message;
	},
};

function createBaseRelativePathsRequest(): RelativePathsRequest {
	return { metadata: undefined, uris: [] };
}

export const RelativePathsRequest: MessageFns<RelativePathsRequest> = {
	encode(
		message: RelativePathsRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		for (const v of message.uris) {
			writer.uint32(18).string(v!);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): RelativePathsRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRelativePathsRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.uris.push(reader.string());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): RelativePathsRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata.fromJSON(object.metadata)
				: undefined,
			uris: globalThis.Array.isArray(object?.uris)
				? object.uris.map((e: any) => globalThis.String(e))
				: [],
		};
	},

	toJSON(message: RelativePathsRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		if (message.uris?.length) {
			obj.uris = message.uris;
		}
		return obj;
	},

	create(base?: DeepPartial<RelativePathsRequest>): RelativePathsRequest {
		return RelativePathsRequest.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<RelativePathsRequest>): RelativePathsRequest {
		const message = createBaseRelativePathsRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata.fromPartial(object.metadata)
				: undefined;
		message.uris = object.uris?.map((e) => e) || [];
		return message;
	},
};

function createBaseRelativePaths(): RelativePaths {
	return { paths: [] };
}

export const RelativePaths: MessageFns<RelativePaths> = {
	encode(
		message: RelativePaths,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		for (const v of message.paths) {
			writer.uint32(10).string(v!);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RelativePaths {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRelativePaths();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.paths.push(reader.string());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): RelativePaths {
		return {
			paths: globalThis.Array.isArray(object?.paths)
				? object.paths.map((e: any) => globalThis.String(e))
				: [],
		};
	},

	toJSON(message: RelativePaths): unknown {
		const obj: any = {};
		if (message.paths?.length) {
			obj.paths = message.paths;
		}
		return obj;
	},

	create(base?: DeepPartial<RelativePaths>): RelativePaths {
		return RelativePaths.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<RelativePaths>): RelativePaths {
		const message = createBaseRelativePaths();
		message.paths = object.paths?.map((e) => e) || [];
		return message;
	},
};

function createBaseFileSearchRequest(): FileSearchRequest {
	return {
		metadata: undefined,
		query: "",
		mentionsRequestId: undefined,
		limit: undefined,
		selectedType: undefined,
		workspaceHint: undefined,
	};
}

export const FileSearchRequest: MessageFns<FileSearchRequest> = {
	encode(
		message: FileSearchRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.query !== "") {
			writer.uint32(18).string(message.query);
		}
		if (message.mentionsRequestId !== undefined) {
			writer.uint32(26).string(message.mentionsRequestId);
		}
		if (message.limit !== undefined) {
			writer.uint32(32).int32(message.limit);
		}
		if (message.selectedType !== undefined) {
			writer.uint32(40).int32(message.selectedType);
		}
		if (message.workspaceHint !== undefined) {
			writer.uint32(50).string(message.workspaceHint);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): FileSearchRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseFileSearchRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.query = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.mentionsRequestId = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.limit = reader.int32();
					continue;
				}
				case 5: {
					if (tag !== 40) {
						break;
					}

					message.selectedType = reader.int32() as any;
					continue;
				}
				case 6: {
					if (tag !== 50) {
						break;
					}

					message.workspaceHint = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): FileSearchRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata.fromJSON(object.metadata)
				: undefined,
			query: isSet(object.query) ? globalThis.String(object.query) : "",
			mentionsRequestId: isSet(object.mentionsRequestId)
				? globalThis.String(object.mentionsRequestId)
				: isSet(object.mentions_request_id)
					? globalThis.String(object.mentions_request_id)
					: undefined,
			limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
			selectedType: isSet(object.selectedType)
				? fileSearchTypeFromJSON(object.selectedType)
				: isSet(object.selected_type)
					? fileSearchTypeFromJSON(object.selected_type)
					: undefined,
			workspaceHint: isSet(object.workspaceHint)
				? globalThis.String(object.workspaceHint)
				: isSet(object.workspace_hint)
					? globalThis.String(object.workspace_hint)
					: undefined,
		};
	},

	toJSON(message: FileSearchRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		if (message.query !== "") {
			obj.query = message.query;
		}
		if (message.mentionsRequestId !== undefined) {
			obj.mentionsRequestId = message.mentionsRequestId;
		}
		if (message.limit !== undefined) {
			obj.limit = Math.round(message.limit);
		}
		if (message.selectedType !== undefined) {
			obj.selectedType = fileSearchTypeToJSON(message.selectedType);
		}
		if (message.workspaceHint !== undefined) {
			obj.workspaceHint = message.workspaceHint;
		}
		return obj;
	},

	create(base?: DeepPartial<FileSearchRequest>): FileSearchRequest {
		return FileSearchRequest.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<FileSearchRequest>): FileSearchRequest {
		const message = createBaseFileSearchRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata.fromPartial(object.metadata)
				: undefined;
		message.query = object.query ?? "";
		message.mentionsRequestId = object.mentionsRequestId ?? undefined;
		message.limit = object.limit ?? undefined;
		message.selectedType = object.selectedType ?? undefined;
		message.workspaceHint = object.workspaceHint ?? undefined;
		return message;
	},
};

function createBaseFileSearchResults(): FileSearchResults {
	return { results: [], mentionsRequestId: undefined };
}

export const FileSearchResults: MessageFns<FileSearchResults> = {
	encode(
		message: FileSearchResults,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		for (const v of message.results) {
			FileInfo.encode(v!, writer.uint32(10).fork()).join();
		}
		if (message.mentionsRequestId !== undefined) {
			writer.uint32(18).string(message.mentionsRequestId);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): FileSearchResults {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseFileSearchResults();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.results.push(FileInfo.decode(reader, reader.uint32()));
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.mentionsRequestId = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): FileSearchResults {
		return {
			results: globalThis.Array.isArray(object?.results)
				? object.results.map((e: any) => FileInfo.fromJSON(e))
				: [],
			mentionsRequestId: isSet(object.mentionsRequestId)
				? globalThis.String(object.mentionsRequestId)
				: isSet(object.mentions_request_id)
					? globalThis.String(object.mentions_request_id)
					: undefined,
		};
	},

	toJSON(message: FileSearchResults): unknown {
		const obj: any = {};
		if (message.results?.length) {
			obj.results = message.results.map((e) => FileInfo.toJSON(e));
		}
		if (message.mentionsRequestId !== undefined) {
			obj.mentionsRequestId = message.mentionsRequestId;
		}
		return obj;
	},

	create(base?: DeepPartial<FileSearchResults>): FileSearchResults {
		return FileSearchResults.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<FileSearchResults>): FileSearchResults {
		const message = createBaseFileSearchResults();
		message.results = object.results?.map((e) => FileInfo.fromPartial(e)) || [];
		message.mentionsRequestId = object.mentionsRequestId ?? undefined;
		return message;
	},
};

function createBaseFileInfo(): FileInfo {
	return { path: "", type: "", label: undefined, workspaceName: undefined };
}

export const FileInfo: MessageFns<FileInfo> = {
	encode(
		message: FileInfo,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.path !== "") {
			writer.uint32(10).string(message.path);
		}
		if (message.type !== "") {
			writer.uint32(18).string(message.type);
		}
		if (message.label !== undefined) {
			writer.uint32(26).string(message.label);
		}
		if (message.workspaceName !== undefined) {
			writer.uint32(34).string(message.workspaceName);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): FileInfo {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseFileInfo();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.path = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.type = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.label = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.workspaceName = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): FileInfo {
		return {
			path: isSet(object.path) ? globalThis.String(object.path) : "",
			type: isSet(object.type) ? globalThis.String(object.type) : "",
			label: isSet(object.label) ? globalThis.String(object.label) : undefined,
			workspaceName: isSet(object.workspaceName)
				? globalThis.String(object.workspaceName)
				: isSet(object.workspace_name)
					? globalThis.String(object.workspace_name)
					: undefined,
		};
	},

	toJSON(message: FileInfo): unknown {
		const obj: any = {};
		if (message.path !== "") {
			obj.path = message.path;
		}
		if (message.type !== "") {
			obj.type = message.type;
		}
		if (message.label !== undefined) {
			obj.label = message.label;
		}
		if (message.workspaceName !== undefined) {
			obj.workspaceName = message.workspaceName;
		}
		return obj;
	},

	create(base?: DeepPartial<FileInfo>): FileInfo {
		return FileInfo.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<FileInfo>): FileInfo {
		const message = createBaseFileInfo();
		message.path = object.path ?? "";
		message.type = object.type ?? "";
		message.label = object.label ?? undefined;
		message.workspaceName = object.workspaceName ?? undefined;
		return message;
	},
};

function createBaseGitCommits(): GitCommits {
	return { commits: [] };
}

export const GitCommits: MessageFns<GitCommits> = {
	encode(
		message: GitCommits,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		for (const v of message.commits) {
			GitCommit.encode(v!, writer.uint32(10).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): GitCommits {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseGitCommits();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.commits.push(GitCommit.decode(reader, reader.uint32()));
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): GitCommits {
		return {
			commits: globalThis.Array.isArray(object?.commits)
				? object.commits.map((e: any) => GitCommit.fromJSON(e))
				: [],
		};
	},

	toJSON(message: GitCommits): unknown {
		const obj: any = {};
		if (message.commits?.length) {
			obj.commits = message.commits.map((e) => GitCommit.toJSON(e));
		}
		return obj;
	},

	create(base?: DeepPartial<GitCommits>): GitCommits {
		return GitCommits.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<GitCommits>): GitCommits {
		const message = createBaseGitCommits();
		message.commits =
			object.commits?.map((e) => GitCommit.fromPartial(e)) || [];
		return message;
	},
};

function createBaseGitCommit(): GitCommit {
	return { hash: "", shortHash: "", subject: "", author: "", date: "" };
}

export const GitCommit: MessageFns<GitCommit> = {
	encode(
		message: GitCommit,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.hash !== "") {
			writer.uint32(10).string(message.hash);
		}
		if (message.shortHash !== "") {
			writer.uint32(18).string(message.shortHash);
		}
		if (message.subject !== "") {
			writer.uint32(26).string(message.subject);
		}
		if (message.author !== "") {
			writer.uint32(34).string(message.author);
		}
		if (message.date !== "") {
			writer.uint32(42).string(message.date);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): GitCommit {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseGitCommit();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.hash = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.shortHash = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.subject = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.author = reader.string();
					continue;
				}
				case 5: {
					if (tag !== 42) {
						break;
					}

					message.date = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): GitCommit {
		return {
			hash: isSet(object.hash) ? globalThis.String(object.hash) : "",
			shortHash: isSet(object.shortHash)
				? globalThis.String(object.shortHash)
				: isSet(object.short_hash)
					? globalThis.String(object.short_hash)
					: "",
			subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
			author: isSet(object.author) ? globalThis.String(object.author) : "",
			date: isSet(object.date) ? globalThis.String(object.date) : "",
		};
	},

	toJSON(message: GitCommit): unknown {
		const obj: any = {};
		if (message.hash !== "") {
			obj.hash = message.hash;
		}
		if (message.shortHash !== "") {
			obj.shortHash = message.shortHash;
		}
		if (message.subject !== "") {
			obj.subject = message.subject;
		}
		if (message.author !== "") {
			obj.author = message.author;
		}
		if (message.date !== "") {
			obj.date = message.date;
		}
		return obj;
	},

	create(base?: DeepPartial<GitCommit>): GitCommit {
		return GitCommit.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<GitCommit>): GitCommit {
		const message = createBaseGitCommit();
		message.hash = object.hash ?? "";
		message.shortHash = object.shortHash ?? "";
		message.subject = object.subject ?? "";
		message.author = object.author ?? "";
		message.date = object.date ?? "";
		return message;
	},
};

function createBaseRuleFileRequest(): RuleFileRequest {
	return {
		metadata: undefined,
		isGlobal: false,
		rulePath: undefined,
		filename: undefined,
		type: undefined,
	};
}

export const RuleFileRequest: MessageFns<RuleFileRequest> = {
	encode(
		message: RuleFileRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.isGlobal !== false) {
			writer.uint32(16).bool(message.isGlobal);
		}
		if (message.rulePath !== undefined) {
			writer.uint32(26).string(message.rulePath);
		}
		if (message.filename !== undefined) {
			writer.uint32(34).string(message.filename);
		}
		if (message.type !== undefined) {
			writer.uint32(42).string(message.type);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RuleFileRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRuleFileRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 16) {
						break;
					}

					message.isGlobal = reader.bool();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.rulePath = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.filename = reader.string();
					continue;
				}
				case 5: {
					if (tag !== 42) {
						break;
					}

					message.type = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): RuleFileRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata.fromJSON(object.metadata)
				: undefined,
			isGlobal: isSet(object.isGlobal)
				? globalThis.Boolean(object.isGlobal)
				: isSet(object.is_global)
					? globalThis.Boolean(object.is_global)
					: false,
			rulePath: isSet(object.rulePath)
				? globalThis.String(object.rulePath)
				: isSet(object.rule_path)
					? globalThis.String(object.rule_path)
					: undefined,
			filename: isSet(object.filename)
				? globalThis.String(object.filename)
				: undefined,
			type: isSet(object.type) ? globalThis.String(object.type) : undefined,
		};
	},

	toJSON(message: RuleFileRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		if (message.isGlobal !== false) {
			obj.isGlobal = message.isGlobal;
		}
		if (message.rulePath !== undefined) {
			obj.rulePath = message.rulePath;
		}
		if (message.filename !== undefined) {
			obj.filename = message.filename;
		}
		if (message.type !== undefined) {
			obj.type = message.type;
		}
		return obj;
	},

	create(base?: DeepPartial<RuleFileRequest>): RuleFileRequest {
		return RuleFileRequest.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<RuleFileRequest>): RuleFileRequest {
		const message = createBaseRuleFileRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata.fromPartial(object.metadata)
				: undefined;
		message.isGlobal = object.isGlobal ?? false;
		message.rulePath = object.rulePath ?? undefined;
		message.filename = object.filename ?? undefined;
		message.type = object.type ?? undefined;
		return message;
	},
};

function createBaseRuleFile(): RuleFile {
	return { filePath: "", displayName: "", alreadyExists: false };
}

export const RuleFile: MessageFns<RuleFile> = {
	encode(
		message: RuleFile,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.filePath !== "") {
			writer.uint32(10).string(message.filePath);
		}
		if (message.displayName !== "") {
			writer.uint32(18).string(message.displayName);
		}
		if (message.alreadyExists !== false) {
			writer.uint32(24).bool(message.alreadyExists);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RuleFile {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRuleFile();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.filePath = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.displayName = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.alreadyExists = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): RuleFile {
		return {
			filePath: isSet(object.filePath)
				? globalThis.String(object.filePath)
				: isSet(object.file_path)
					? globalThis.String(object.file_path)
					: "",
			displayName: isSet(object.displayName)
				? globalThis.String(object.displayName)
				: isSet(object.display_name)
					? globalThis.String(object.display_name)
					: "",
			alreadyExists: isSet(object.alreadyExists)
				? globalThis.Boolean(object.alreadyExists)
				: isSet(object.already_exists)
					? globalThis.Boolean(object.already_exists)
					: false,
		};
	},

	toJSON(message: RuleFile): unknown {
		const obj: any = {};
		if (message.filePath !== "") {
			obj.filePath = message.filePath;
		}
		if (message.displayName !== "") {
			obj.displayName = message.displayName;
		}
		if (message.alreadyExists !== false) {
			obj.alreadyExists = message.alreadyExists;
		}
		return obj;
	},

	create(base?: DeepPartial<RuleFile>): RuleFile {
		return RuleFile.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<RuleFile>): RuleFile {
		const message = createBaseRuleFile();
		message.filePath = object.filePath ?? "";
		message.displayName = object.displayName ?? "";
		message.alreadyExists = object.alreadyExists ?? false;
		return message;
	},
};

function createBaseToggleClineRuleRequest(): ToggleClineRuleRequest {
	return { metadata: undefined, scope: 0, rulePath: "", enabled: false };
}

export const ToggleClineRuleRequest: MessageFns<ToggleClineRuleRequest> = {
	encode(
		message: ToggleClineRuleRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.scope !== 0) {
			writer.uint32(16).int32(message.scope);
		}
		if (message.rulePath !== "") {
			writer.uint32(26).string(message.rulePath);
		}
		if (message.enabled !== false) {
			writer.uint32(32).bool(message.enabled);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): ToggleClineRuleRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseToggleClineRuleRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 16) {
						break;
					}

					message.scope = reader.int32() as any;
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.rulePath = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.enabled = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): ToggleClineRuleRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata.fromJSON(object.metadata)
				: undefined,
			scope: isSet(object.scope) ? ruleScopeFromJSON(object.scope) : 0,
			rulePath: isSet(object.rulePath)
				? globalThis.String(object.rulePath)
				: isSet(object.rule_path)
					? globalThis.String(object.rule_path)
					: "",
			enabled: isSet(object.enabled)
				? globalThis.Boolean(object.enabled)
				: false,
		};
	},

	toJSON(message: ToggleClineRuleRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		if (message.scope !== 0) {
			obj.scope = ruleScopeToJSON(message.scope);
		}
		if (message.rulePath !== "") {
			obj.rulePath = message.rulePath;
		}
		if (message.enabled !== false) {
			obj.enabled = message.enabled;
		}
		return obj;
	},

	create(base?: DeepPartial<ToggleClineRuleRequest>): ToggleClineRuleRequest {
		return ToggleClineRuleRequest.fromPartial(base ?? {});
	},
	fromPartial(
		object: DeepPartial<ToggleClineRuleRequest>,
	): ToggleClineRuleRequest {
		const message = createBaseToggleClineRuleRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata.fromPartial(object.metadata)
				: undefined;
		message.scope = object.scope ?? 0;
		message.rulePath = object.rulePath ?? "";
		message.enabled = object.enabled ?? false;
		return message;
	},
};

function createBaseClineRulesToggles(): ClineRulesToggles {
	return { toggles: {} };
}

export const ClineRulesToggles: MessageFns<ClineRulesToggles> = {
	encode(
		message: ClineRulesToggles,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		globalThis.Object.entries(message.toggles).forEach(
			([key, value]: [string, boolean]) => {
				ClineRulesToggles_TogglesEntry.encode(
					{ key: key as any, value },
					writer.uint32(10).fork(),
				).join();
			},
		);
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ClineRulesToggles {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseClineRulesToggles();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					const entry1 = ClineRulesToggles_TogglesEntry.decode(
						reader,
						reader.uint32(),
					);
					if (entry1.value !== undefined) {
						message.toggles[entry1.key] = entry1.value;
					}
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): ClineRulesToggles {
		return {
			toggles: isObject(object.toggles)
				? (globalThis.Object.entries(object.toggles) as [string, any][]).reduce(
						(acc: { [key: string]: boolean }, [key, value]: [string, any]) => {
							acc[key] = globalThis.Boolean(value);
							return acc;
						},
						{},
					)
				: {},
		};
	},

	toJSON(message: ClineRulesToggles): unknown {
		const obj: any = {};
		if (message.toggles) {
			const entries = globalThis.Object.entries(message.toggles) as [
				string,
				boolean,
			][];
			if (entries.length > 0) {
				obj.toggles = {};
				entries.forEach(([k, v]) => {
					obj.toggles[k] = v;
				});
			}
		}
		return obj;
	},

	create(base?: DeepPartial<ClineRulesToggles>): ClineRulesToggles {
		return ClineRulesToggles.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<ClineRulesToggles>): ClineRulesToggles {
		const message = createBaseClineRulesToggles();
		message.toggles = (
			globalThis.Object.entries(object.toggles ?? {}) as [string, boolean][]
		).reduce(
			(acc: { [key: string]: boolean }, [key, value]: [string, boolean]) => {
				if (value !== undefined) {
					acc[key] = globalThis.Boolean(value);
				}
				return acc;
			},
			{},
		);
		return message;
	},
};

function createBaseClineRulesToggles_TogglesEntry(): ClineRulesToggles_TogglesEntry {
	return { key: "", value: false };
}

export const ClineRulesToggles_TogglesEntry: MessageFns<ClineRulesToggles_TogglesEntry> =
	{
		encode(
			message: ClineRulesToggles_TogglesEntry,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.key !== "") {
				writer.uint32(10).string(message.key);
			}
			if (message.value !== false) {
				writer.uint32(16).bool(message.value);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): ClineRulesToggles_TogglesEntry {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseClineRulesToggles_TogglesEntry();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.key = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 16) {
							break;
						}

						message.value = reader.bool();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): ClineRulesToggles_TogglesEntry {
			return {
				key: isSet(object.key) ? globalThis.String(object.key) : "",
				value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
			};
		},

		toJSON(message: ClineRulesToggles_TogglesEntry): unknown {
			const obj: any = {};
			if (message.key !== "") {
				obj.key = message.key;
			}
			if (message.value !== false) {
				obj.value = message.value;
			}
			return obj;
		},

		create(
			base?: DeepPartial<ClineRulesToggles_TogglesEntry>,
		): ClineRulesToggles_TogglesEntry {
			return ClineRulesToggles_TogglesEntry.fromPartial(base ?? {});
		},
		fromPartial(
			object: DeepPartial<ClineRulesToggles_TogglesEntry>,
		): ClineRulesToggles_TogglesEntry {
			const message = createBaseClineRulesToggles_TogglesEntry();
			message.key = object.key ?? "";
			message.value = object.value ?? false;
			return message;
		},
	};

function createBaseToggleClineRules(): ToggleClineRules {
	return {
		globalClineRulesToggles: undefined,
		localClineRulesToggles: undefined,
		remoteRulesToggles: undefined,
	};
}

export const ToggleClineRules: MessageFns<ToggleClineRules> = {
	encode(
		message: ToggleClineRules,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.globalClineRulesToggles !== undefined) {
			ClineRulesToggles.encode(
				message.globalClineRulesToggles,
				writer.uint32(10).fork(),
			).join();
		}
		if (message.localClineRulesToggles !== undefined) {
			ClineRulesToggles.encode(
				message.localClineRulesToggles,
				writer.uint32(18).fork(),
			).join();
		}
		if (message.remoteRulesToggles !== undefined) {
			ClineRulesToggles.encode(
				message.remoteRulesToggles,
				writer.uint32(26).fork(),
			).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ToggleClineRules {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseToggleClineRules();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.globalClineRulesToggles = ClineRulesToggles.decode(
						reader,
						reader.uint32(),
					);
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.localClineRulesToggles = ClineRulesToggles.decode(
						reader,
						reader.uint32(),
					);
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.remoteRulesToggles = ClineRulesToggles.decode(
						reader,
						reader.uint32(),
					);
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): ToggleClineRules {
		return {
			globalClineRulesToggles: isSet(object.globalClineRulesToggles)
				? ClineRulesToggles.fromJSON(object.globalClineRulesToggles)
				: isSet(object.global_cline_rules_toggles)
					? ClineRulesToggles.fromJSON(object.global_cline_rules_toggles)
					: undefined,
			localClineRulesToggles: isSet(object.localClineRulesToggles)
				? ClineRulesToggles.fromJSON(object.localClineRulesToggles)
				: isSet(object.local_cline_rules_toggles)
					? ClineRulesToggles.fromJSON(object.local_cline_rules_toggles)
					: undefined,
			remoteRulesToggles: isSet(object.remoteRulesToggles)
				? ClineRulesToggles.fromJSON(object.remoteRulesToggles)
				: isSet(object.remote_rules_toggles)
					? ClineRulesToggles.fromJSON(object.remote_rules_toggles)
					: undefined,
		};
	},

	toJSON(message: ToggleClineRules): unknown {
		const obj: any = {};
		if (message.globalClineRulesToggles !== undefined) {
			obj.globalClineRulesToggles = ClineRulesToggles.toJSON(
				message.globalClineRulesToggles,
			);
		}
		if (message.localClineRulesToggles !== undefined) {
			obj.localClineRulesToggles = ClineRulesToggles.toJSON(
				message.localClineRulesToggles,
			);
		}
		if (message.remoteRulesToggles !== undefined) {
			obj.remoteRulesToggles = ClineRulesToggles.toJSON(
				message.remoteRulesToggles,
			);
		}
		return obj;
	},

	create(base?: DeepPartial<ToggleClineRules>): ToggleClineRules {
		return ToggleClineRules.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<ToggleClineRules>): ToggleClineRules {
		const message = createBaseToggleClineRules();
		message.globalClineRulesToggles =
			object.globalClineRulesToggles !== undefined &&
			object.globalClineRulesToggles !== null
				? ClineRulesToggles.fromPartial(object.globalClineRulesToggles)
				: undefined;
		message.localClineRulesToggles =
			object.localClineRulesToggles !== undefined &&
			object.localClineRulesToggles !== null
				? ClineRulesToggles.fromPartial(object.localClineRulesToggles)
				: undefined;
		message.remoteRulesToggles =
			object.remoteRulesToggles !== undefined &&
			object.remoteRulesToggles !== null
				? ClineRulesToggles.fromPartial(object.remoteRulesToggles)
				: undefined;
		return message;
	},
};

function createBaseToggleCursorRuleRequest(): ToggleCursorRuleRequest {
	return { metadata: undefined, rulePath: "", enabled: false };
}

export const ToggleCursorRuleRequest: MessageFns<ToggleCursorRuleRequest> = {
	encode(
		message: ToggleCursorRuleRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.rulePath !== "") {
			writer.uint32(18).string(message.rulePath);
		}
		if (message.enabled !== false) {
			writer.uint32(24).bool(message.enabled);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): ToggleCursorRuleRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseToggleCursorRuleRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.rulePath = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.enabled = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): ToggleCursorRuleRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata.fromJSON(object.metadata)
				: undefined,
			rulePath: isSet(object.rulePath)
				? globalThis.String(object.rulePath)
				: isSet(object.rule_path)
					? globalThis.String(object.rule_path)
					: "",
			enabled: isSet(object.enabled)
				? globalThis.Boolean(object.enabled)
				: false,
		};
	},

	toJSON(message: ToggleCursorRuleRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		if (message.rulePath !== "") {
			obj.rulePath = message.rulePath;
		}
		if (message.enabled !== false) {
			obj.enabled = message.enabled;
		}
		return obj;
	},

	create(base?: DeepPartial<ToggleCursorRuleRequest>): ToggleCursorRuleRequest {
		return ToggleCursorRuleRequest.fromPartial(base ?? {});
	},
	fromPartial(
		object: DeepPartial<ToggleCursorRuleRequest>,
	): ToggleCursorRuleRequest {
		const message = createBaseToggleCursorRuleRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata.fromPartial(object.metadata)
				: undefined;
		message.rulePath = object.rulePath ?? "";
		message.enabled = object.enabled ?? false;
		return message;
	},
};

function createBaseToggleWorkflowRequest(): ToggleWorkflowRequest {
	return { metadata: undefined, workflowPath: "", enabled: false, scope: 0 };
}

export const ToggleWorkflowRequest: MessageFns<ToggleWorkflowRequest> = {
	encode(
		message: ToggleWorkflowRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.workflowPath !== "") {
			writer.uint32(18).string(message.workflowPath);
		}
		if (message.enabled !== false) {
			writer.uint32(24).bool(message.enabled);
		}
		if (message.scope !== 0) {
			writer.uint32(32).int32(message.scope);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): ToggleWorkflowRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseToggleWorkflowRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.workflowPath = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.enabled = reader.bool();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.scope = reader.int32() as any;
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): ToggleWorkflowRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata.fromJSON(object.metadata)
				: undefined,
			workflowPath: isSet(object.workflowPath)
				? globalThis.String(object.workflowPath)
				: isSet(object.workflow_path)
					? globalThis.String(object.workflow_path)
					: "",
			enabled: isSet(object.enabled)
				? globalThis.Boolean(object.enabled)
				: false,
			scope: isSet(object.scope) ? ruleScopeFromJSON(object.scope) : 0,
		};
	},

	toJSON(message: ToggleWorkflowRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		if (message.workflowPath !== "") {
			obj.workflowPath = message.workflowPath;
		}
		if (message.enabled !== false) {
			obj.enabled = message.enabled;
		}
		if (message.scope !== 0) {
			obj.scope = ruleScopeToJSON(message.scope);
		}
		return obj;
	},

	create(base?: DeepPartial<ToggleWorkflowRequest>): ToggleWorkflowRequest {
		return ToggleWorkflowRequest.fromPartial(base ?? {});
	},
	fromPartial(
		object: DeepPartial<ToggleWorkflowRequest>,
	): ToggleWorkflowRequest {
		const message = createBaseToggleWorkflowRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata.fromPartial(object.metadata)
				: undefined;
		message.workflowPath = object.workflowPath ?? "";
		message.enabled = object.enabled ?? false;
		message.scope = object.scope ?? 0;
		return message;
	},
};

function createBaseHookInfo(): HookInfo {
	return { name: "", enabled: false, absolutePath: "" };
}

export const HookInfo: MessageFns<HookInfo> = {
	encode(
		message: HookInfo,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.name !== "") {
			writer.uint32(10).string(message.name);
		}
		if (message.enabled !== false) {
			writer.uint32(16).bool(message.enabled);
		}
		if (message.absolutePath !== "") {
			writer.uint32(26).string(message.absolutePath);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): HookInfo {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseHookInfo();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.name = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 16) {
						break;
					}

					message.enabled = reader.bool();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.absolutePath = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): HookInfo {
		return {
			name: isSet(object.name) ? globalThis.String(object.name) : "",
			enabled: isSet(object.enabled)
				? globalThis.Boolean(object.enabled)
				: false,
			absolutePath: isSet(object.absolutePath)
				? globalThis.String(object.absolutePath)
				: isSet(object.absolute_path)
					? globalThis.String(object.absolute_path)
					: "",
		};
	},

	toJSON(message: HookInfo): unknown {
		const obj: any = {};
		if (message.name !== "") {
			obj.name = message.name;
		}
		if (message.enabled !== false) {
			obj.enabled = message.enabled;
		}
		if (message.absolutePath !== "") {
			obj.absolutePath = message.absolutePath;
		}
		return obj;
	},

	create(base?: DeepPartial<HookInfo>): HookInfo {
		return HookInfo.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<HookInfo>): HookInfo {
		const message = createBaseHookInfo();
		message.name = object.name ?? "";
		message.enabled = object.enabled ?? false;
		message.absolutePath = object.absolutePath ?? "";
		return message;
	},
};

function createBaseWorkspaceHooks(): WorkspaceHooks {
	return { workspaceName: "", hooks: [] };
}

export const WorkspaceHooks: MessageFns<WorkspaceHooks> = {
	encode(
		message: WorkspaceHooks,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.workspaceName !== "") {
			writer.uint32(10).string(message.workspaceName);
		}
		for (const v of message.hooks) {
			HookInfo.encode(v!, writer.uint32(18).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): WorkspaceHooks {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseWorkspaceHooks();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.workspaceName = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.hooks.push(HookInfo.decode(reader, reader.uint32()));
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): WorkspaceHooks {
		return {
			workspaceName: isSet(object.workspaceName)
				? globalThis.String(object.workspaceName)
				: isSet(object.workspace_name)
					? globalThis.String(object.workspace_name)
					: "",
			hooks: globalThis.Array.isArray(object?.hooks)
				? object.hooks.map((e: any) => HookInfo.fromJSON(e))
				: [],
		};
	},

	toJSON(message: WorkspaceHooks): unknown {
		const obj: any = {};
		if (message.workspaceName !== "") {
			obj.workspaceName = message.workspaceName;
		}
		if (message.hooks?.length) {
			obj.hooks = message.hooks.map((e) => HookInfo.toJSON(e));
		}
		return obj;
	},

	create(base?: DeepPartial<WorkspaceHooks>): WorkspaceHooks {
		return WorkspaceHooks.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<WorkspaceHooks>): WorkspaceHooks {
		const message = createBaseWorkspaceHooks();
		message.workspaceName = object.workspaceName ?? "";
		message.hooks = object.hooks?.map((e) => HookInfo.fromPartial(e)) || [];
		return message;
	},
};

function createBaseHooksToggles(): HooksToggles {
	return { globalHooks: [], workspaceHooks: [], isWindows: false };
}

export const HooksToggles: MessageFns<HooksToggles> = {
	encode(
		message: HooksToggles,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		for (const v of message.globalHooks) {
			HookInfo.encode(v!, writer.uint32(10).fork()).join();
		}
		for (const v of message.workspaceHooks) {
			WorkspaceHooks.encode(v!, writer.uint32(18).fork()).join();
		}
		if (message.isWindows !== false) {
			writer.uint32(24).bool(message.isWindows);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): HooksToggles {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseHooksToggles();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.globalHooks.push(HookInfo.decode(reader, reader.uint32()));
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.workspaceHooks.push(
						WorkspaceHooks.decode(reader, reader.uint32()),
					);
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.isWindows = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): HooksToggles {
		return {
			globalHooks: globalThis.Array.isArray(object?.globalHooks)
				? object.globalHooks.map((e: any) => HookInfo.fromJSON(e))
				: globalThis.Array.isArray(object?.global_hooks)
					? object.global_hooks.map((e: any) => HookInfo.fromJSON(e))
					: [],
			workspaceHooks: globalThis.Array.isArray(object?.workspaceHooks)
				? object.workspaceHooks.map((e: any) => WorkspaceHooks.fromJSON(e))
				: globalThis.Array.isArray(object?.workspace_hooks)
					? object.workspace_hooks.map((e: any) => WorkspaceHooks.fromJSON(e))
					: [],
			isWindows: isSet(object.isWindows)
				? globalThis.Boolean(object.isWindows)
				: isSet(object.is_windows)
					? globalThis.Boolean(object.is_windows)
					: false,
		};
	},

	toJSON(message: HooksToggles): unknown {
		const obj: any = {};
		if (message.globalHooks?.length) {
			obj.globalHooks = message.globalHooks.map((e) => HookInfo.toJSON(e));
		}
		if (message.workspaceHooks?.length) {
			obj.workspaceHooks = message.workspaceHooks.map((e) =>
				WorkspaceHooks.toJSON(e),
			);
		}
		if (message.isWindows !== false) {
			obj.isWindows = message.isWindows;
		}
		return obj;
	},

	create(base?: DeepPartial<HooksToggles>): HooksToggles {
		return HooksToggles.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<HooksToggles>): HooksToggles {
		const message = createBaseHooksToggles();
		message.globalHooks =
			object.globalHooks?.map((e) => HookInfo.fromPartial(e)) || [];
		message.workspaceHooks =
			object.workspaceHooks?.map((e) => WorkspaceHooks.fromPartial(e)) || [];
		message.isWindows = object.isWindows ?? false;
		return message;
	},
};

function createBaseToggleHookRequest(): ToggleHookRequest {
	return {
		metadata: undefined,
		hookName: "",
		isGlobal: false,
		enabled: false,
		workspaceName: undefined,
	};
}

export const ToggleHookRequest: MessageFns<ToggleHookRequest> = {
	encode(
		message: ToggleHookRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.hookName !== "") {
			writer.uint32(18).string(message.hookName);
		}
		if (message.isGlobal !== false) {
			writer.uint32(24).bool(message.isGlobal);
		}
		if (message.enabled !== false) {
			writer.uint32(32).bool(message.enabled);
		}
		if (message.workspaceName !== undefined) {
			writer.uint32(42).string(message.workspaceName);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): ToggleHookRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseToggleHookRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.hookName = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.isGlobal = reader.bool();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.enabled = reader.bool();
					continue;
				}
				case 5: {
					if (tag !== 42) {
						break;
					}

					message.workspaceName = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): ToggleHookRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata.fromJSON(object.metadata)
				: undefined,
			hookName: isSet(object.hookName)
				? globalThis.String(object.hookName)
				: isSet(object.hook_name)
					? globalThis.String(object.hook_name)
					: "",
			isGlobal: isSet(object.isGlobal)
				? globalThis.Boolean(object.isGlobal)
				: isSet(object.is_global)
					? globalThis.Boolean(object.is_global)
					: false,
			enabled: isSet(object.enabled)
				? globalThis.Boolean(object.enabled)
				: false,
			workspaceName: isSet(object.workspaceName)
				? globalThis.String(object.workspaceName)
				: isSet(object.workspace_name)
					? globalThis.String(object.workspace_name)
					: undefined,
		};
	},

	toJSON(message: ToggleHookRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		if (message.hookName !== "") {
			obj.hookName = message.hookName;
		}
		if (message.isGlobal !== false) {
			obj.isGlobal = message.isGlobal;
		}
		if (message.enabled !== false) {
			obj.enabled = message.enabled;
		}
		if (message.workspaceName !== undefined) {
			obj.workspaceName = message.workspaceName;
		}
		return obj;
	},

	create(base?: DeepPartial<ToggleHookRequest>): ToggleHookRequest {
		return ToggleHookRequest.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<ToggleHookRequest>): ToggleHookRequest {
		const message = createBaseToggleHookRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata.fromPartial(object.metadata)
				: undefined;
		message.hookName = object.hookName ?? "";
		message.isGlobal = object.isGlobal ?? false;
		message.enabled = object.enabled ?? false;
		message.workspaceName = object.workspaceName ?? undefined;
		return message;
	},
};

function createBaseToggleHookResponse(): ToggleHookResponse {
	return { hooksToggles: undefined };
}

export const ToggleHookResponse: MessageFns<ToggleHookResponse> = {
	encode(
		message: ToggleHookResponse,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.hooksToggles !== undefined) {
			HooksToggles.encode(
				message.hooksToggles,
				writer.uint32(10).fork(),
			).join();
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): ToggleHookResponse {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseToggleHookResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.hooksToggles = HooksToggles.decode(reader, reader.uint32());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): ToggleHookResponse {
		return {
			hooksToggles: isSet(object.hooksToggles)
				? HooksToggles.fromJSON(object.hooksToggles)
				: isSet(object.hooks_toggles)
					? HooksToggles.fromJSON(object.hooks_toggles)
					: undefined,
		};
	},

	toJSON(message: ToggleHookResponse): unknown {
		const obj: any = {};
		if (message.hooksToggles !== undefined) {
			obj.hooksToggles = HooksToggles.toJSON(message.hooksToggles);
		}
		return obj;
	},

	create(base?: DeepPartial<ToggleHookResponse>): ToggleHookResponse {
		return ToggleHookResponse.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<ToggleHookResponse>): ToggleHookResponse {
		const message = createBaseToggleHookResponse();
		message.hooksToggles =
			object.hooksToggles !== undefined && object.hooksToggles !== null
				? HooksToggles.fromPartial(object.hooksToggles)
				: undefined;
		return message;
	},
};

function createBaseCreateHookRequest(): CreateHookRequest {
	return {
		metadata: undefined,
		hookName: "",
		isGlobal: false,
		workspaceName: undefined,
	};
}

export const CreateHookRequest: MessageFns<CreateHookRequest> = {
	encode(
		message: CreateHookRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.hookName !== "") {
			writer.uint32(18).string(message.hookName);
		}
		if (message.isGlobal !== false) {
			writer.uint32(24).bool(message.isGlobal);
		}
		if (message.workspaceName !== undefined) {
			writer.uint32(34).string(message.workspaceName);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): CreateHookRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseCreateHookRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.hookName = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.isGlobal = reader.bool();
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.workspaceName = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): CreateHookRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata.fromJSON(object.metadata)
				: undefined,
			hookName: isSet(object.hookName)
				? globalThis.String(object.hookName)
				: isSet(object.hook_name)
					? globalThis.String(object.hook_name)
					: "",
			isGlobal: isSet(object.isGlobal)
				? globalThis.Boolean(object.isGlobal)
				: isSet(object.is_global)
					? globalThis.Boolean(object.is_global)
					: false,
			workspaceName: isSet(object.workspaceName)
				? globalThis.String(object.workspaceName)
				: isSet(object.workspace_name)
					? globalThis.String(object.workspace_name)
					: undefined,
		};
	},

	toJSON(message: CreateHookRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		if (message.hookName !== "") {
			obj.hookName = message.hookName;
		}
		if (message.isGlobal !== false) {
			obj.isGlobal = message.isGlobal;
		}
		if (message.workspaceName !== undefined) {
			obj.workspaceName = message.workspaceName;
		}
		return obj;
	},

	create(base?: DeepPartial<CreateHookRequest>): CreateHookRequest {
		return CreateHookRequest.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<CreateHookRequest>): CreateHookRequest {
		const message = createBaseCreateHookRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata.fromPartial(object.metadata)
				: undefined;
		message.hookName = object.hookName ?? "";
		message.isGlobal = object.isGlobal ?? false;
		message.workspaceName = object.workspaceName ?? undefined;
		return message;
	},
};

function createBaseCreateHookResponse(): CreateHookResponse {
	return { hooksToggles: undefined };
}

export const CreateHookResponse: MessageFns<CreateHookResponse> = {
	encode(
		message: CreateHookResponse,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.hooksToggles !== undefined) {
			HooksToggles.encode(
				message.hooksToggles,
				writer.uint32(10).fork(),
			).join();
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): CreateHookResponse {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseCreateHookResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.hooksToggles = HooksToggles.decode(reader, reader.uint32());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): CreateHookResponse {
		return {
			hooksToggles: isSet(object.hooksToggles)
				? HooksToggles.fromJSON(object.hooksToggles)
				: isSet(object.hooks_toggles)
					? HooksToggles.fromJSON(object.hooks_toggles)
					: undefined,
		};
	},

	toJSON(message: CreateHookResponse): unknown {
		const obj: any = {};
		if (message.hooksToggles !== undefined) {
			obj.hooksToggles = HooksToggles.toJSON(message.hooksToggles);
		}
		return obj;
	},

	create(base?: DeepPartial<CreateHookResponse>): CreateHookResponse {
		return CreateHookResponse.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<CreateHookResponse>): CreateHookResponse {
		const message = createBaseCreateHookResponse();
		message.hooksToggles =
			object.hooksToggles !== undefined && object.hooksToggles !== null
				? HooksToggles.fromPartial(object.hooksToggles)
				: undefined;
		return message;
	},
};

function createBaseDeleteHookRequest(): DeleteHookRequest {
	return {
		metadata: undefined,
		hookName: "",
		isGlobal: false,
		workspaceName: undefined,
	};
}

export const DeleteHookRequest: MessageFns<DeleteHookRequest> = {
	encode(
		message: DeleteHookRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.hookName !== "") {
			writer.uint32(18).string(message.hookName);
		}
		if (message.isGlobal !== false) {
			writer.uint32(24).bool(message.isGlobal);
		}
		if (message.workspaceName !== undefined) {
			writer.uint32(34).string(message.workspaceName);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): DeleteHookRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseDeleteHookRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.hookName = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.isGlobal = reader.bool();
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.workspaceName = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): DeleteHookRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata.fromJSON(object.metadata)
				: undefined,
			hookName: isSet(object.hookName)
				? globalThis.String(object.hookName)
				: isSet(object.hook_name)
					? globalThis.String(object.hook_name)
					: "",
			isGlobal: isSet(object.isGlobal)
				? globalThis.Boolean(object.isGlobal)
				: isSet(object.is_global)
					? globalThis.Boolean(object.is_global)
					: false,
			workspaceName: isSet(object.workspaceName)
				? globalThis.String(object.workspaceName)
				: isSet(object.workspace_name)
					? globalThis.String(object.workspace_name)
					: undefined,
		};
	},

	toJSON(message: DeleteHookRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		if (message.hookName !== "") {
			obj.hookName = message.hookName;
		}
		if (message.isGlobal !== false) {
			obj.isGlobal = message.isGlobal;
		}
		if (message.workspaceName !== undefined) {
			obj.workspaceName = message.workspaceName;
		}
		return obj;
	},

	create(base?: DeepPartial<DeleteHookRequest>): DeleteHookRequest {
		return DeleteHookRequest.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<DeleteHookRequest>): DeleteHookRequest {
		const message = createBaseDeleteHookRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata.fromPartial(object.metadata)
				: undefined;
		message.hookName = object.hookName ?? "";
		message.isGlobal = object.isGlobal ?? false;
		message.workspaceName = object.workspaceName ?? undefined;
		return message;
	},
};

function createBaseDeleteHookResponse(): DeleteHookResponse {
	return { hooksToggles: undefined };
}

export const DeleteHookResponse: MessageFns<DeleteHookResponse> = {
	encode(
		message: DeleteHookResponse,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.hooksToggles !== undefined) {
			HooksToggles.encode(
				message.hooksToggles,
				writer.uint32(10).fork(),
			).join();
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): DeleteHookResponse {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseDeleteHookResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.hooksToggles = HooksToggles.decode(reader, reader.uint32());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): DeleteHookResponse {
		return {
			hooksToggles: isSet(object.hooksToggles)
				? HooksToggles.fromJSON(object.hooksToggles)
				: isSet(object.hooks_toggles)
					? HooksToggles.fromJSON(object.hooks_toggles)
					: undefined,
		};
	},

	toJSON(message: DeleteHookResponse): unknown {
		const obj: any = {};
		if (message.hooksToggles !== undefined) {
			obj.hooksToggles = HooksToggles.toJSON(message.hooksToggles);
		}
		return obj;
	},

	create(base?: DeepPartial<DeleteHookResponse>): DeleteHookResponse {
		return DeleteHookResponse.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<DeleteHookResponse>): DeleteHookResponse {
		const message = createBaseDeleteHookResponse();
		message.hooksToggles =
			object.hooksToggles !== undefined && object.hooksToggles !== null
				? HooksToggles.fromPartial(object.hooksToggles)
				: undefined;
		return message;
	},
};

function createBaseSkillInfo(): SkillInfo {
	return { name: "", description: "", path: "", enabled: false };
}

export const SkillInfo: MessageFns<SkillInfo> = {
	encode(
		message: SkillInfo,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.name !== "") {
			writer.uint32(10).string(message.name);
		}
		if (message.description !== "") {
			writer.uint32(18).string(message.description);
		}
		if (message.path !== "") {
			writer.uint32(26).string(message.path);
		}
		if (message.enabled !== false) {
			writer.uint32(32).bool(message.enabled);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SkillInfo {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseSkillInfo();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.name = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.description = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.path = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.enabled = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): SkillInfo {
		return {
			name: isSet(object.name) ? globalThis.String(object.name) : "",
			description: isSet(object.description)
				? globalThis.String(object.description)
				: "",
			path: isSet(object.path) ? globalThis.String(object.path) : "",
			enabled: isSet(object.enabled)
				? globalThis.Boolean(object.enabled)
				: false,
		};
	},

	toJSON(message: SkillInfo): unknown {
		const obj: any = {};
		if (message.name !== "") {
			obj.name = message.name;
		}
		if (message.description !== "") {
			obj.description = message.description;
		}
		if (message.path !== "") {
			obj.path = message.path;
		}
		if (message.enabled !== false) {
			obj.enabled = message.enabled;
		}
		return obj;
	},

	create(base?: DeepPartial<SkillInfo>): SkillInfo {
		return SkillInfo.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<SkillInfo>): SkillInfo {
		const message = createBaseSkillInfo();
		message.name = object.name ?? "";
		message.description = object.description ?? "";
		message.path = object.path ?? "";
		message.enabled = object.enabled ?? false;
		return message;
	},
};

function createBaseRefreshedSkills(): RefreshedSkills {
	return { globalSkills: [], localSkills: [] };
}

export const RefreshedSkills: MessageFns<RefreshedSkills> = {
	encode(
		message: RefreshedSkills,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		for (const v of message.globalSkills) {
			SkillInfo.encode(v!, writer.uint32(10).fork()).join();
		}
		for (const v of message.localSkills) {
			SkillInfo.encode(v!, writer.uint32(18).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RefreshedSkills {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRefreshedSkills();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.globalSkills.push(SkillInfo.decode(reader, reader.uint32()));
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.localSkills.push(SkillInfo.decode(reader, reader.uint32()));
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): RefreshedSkills {
		return {
			globalSkills: globalThis.Array.isArray(object?.globalSkills)
				? object.globalSkills.map((e: any) => SkillInfo.fromJSON(e))
				: globalThis.Array.isArray(object?.global_skills)
					? object.global_skills.map((e: any) => SkillInfo.fromJSON(e))
					: [],
			localSkills: globalThis.Array.isArray(object?.localSkills)
				? object.localSkills.map((e: any) => SkillInfo.fromJSON(e))
				: globalThis.Array.isArray(object?.local_skills)
					? object.local_skills.map((e: any) => SkillInfo.fromJSON(e))
					: [],
		};
	},

	toJSON(message: RefreshedSkills): unknown {
		const obj: any = {};
		if (message.globalSkills?.length) {
			obj.globalSkills = message.globalSkills.map((e) => SkillInfo.toJSON(e));
		}
		if (message.localSkills?.length) {
			obj.localSkills = message.localSkills.map((e) => SkillInfo.toJSON(e));
		}
		return obj;
	},

	create(base?: DeepPartial<RefreshedSkills>): RefreshedSkills {
		return RefreshedSkills.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<RefreshedSkills>): RefreshedSkills {
		const message = createBaseRefreshedSkills();
		message.globalSkills =
			object.globalSkills?.map((e) => SkillInfo.fromPartial(e)) || [];
		message.localSkills =
			object.localSkills?.map((e) => SkillInfo.fromPartial(e)) || [];
		return message;
	},
};

function createBaseSkillsToggles(): SkillsToggles {
	return { globalSkillsToggles: {}, localSkillsToggles: {} };
}

export const SkillsToggles: MessageFns<SkillsToggles> = {
	encode(
		message: SkillsToggles,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		globalThis.Object.entries(message.globalSkillsToggles).forEach(
			([key, value]: [string, boolean]) => {
				SkillsToggles_GlobalSkillsTogglesEntry.encode(
					{ key: key as any, value },
					writer.uint32(10).fork(),
				).join();
			},
		);
		globalThis.Object.entries(message.localSkillsToggles).forEach(
			([key, value]: [string, boolean]) => {
				SkillsToggles_LocalSkillsTogglesEntry.encode(
					{ key: key as any, value },
					writer.uint32(18).fork(),
				).join();
			},
		);
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): SkillsToggles {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseSkillsToggles();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					const entry1 = SkillsToggles_GlobalSkillsTogglesEntry.decode(
						reader,
						reader.uint32(),
					);
					if (entry1.value !== undefined) {
						message.globalSkillsToggles[entry1.key] = entry1.value;
					}
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					const entry2 = SkillsToggles_LocalSkillsTogglesEntry.decode(
						reader,
						reader.uint32(),
					);
					if (entry2.value !== undefined) {
						message.localSkillsToggles[entry2.key] = entry2.value;
					}
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): SkillsToggles {
		return {
			globalSkillsToggles: isObject(object.globalSkillsToggles)
				? (
						globalThis.Object.entries(object.globalSkillsToggles) as [
							string,
							any,
						][]
					).reduce(
						(acc: { [key: string]: boolean }, [key, value]: [string, any]) => {
							acc[key] = globalThis.Boolean(value);
							return acc;
						},
						{},
					)
				: isObject(object.global_skills_toggles)
					? (
							globalThis.Object.entries(object.global_skills_toggles) as [
								string,
								any,
							][]
						).reduce(
							(
								acc: { [key: string]: boolean },
								[key, value]: [string, any],
							) => {
								acc[key] = globalThis.Boolean(value);
								return acc;
							},
							{},
						)
					: {},
			localSkillsToggles: isObject(object.localSkillsToggles)
				? (
						globalThis.Object.entries(object.localSkillsToggles) as [
							string,
							any,
						][]
					).reduce(
						(acc: { [key: string]: boolean }, [key, value]: [string, any]) => {
							acc[key] = globalThis.Boolean(value);
							return acc;
						},
						{},
					)
				: isObject(object.local_skills_toggles)
					? (
							globalThis.Object.entries(object.local_skills_toggles) as [
								string,
								any,
							][]
						).reduce(
							(
								acc: { [key: string]: boolean },
								[key, value]: [string, any],
							) => {
								acc[key] = globalThis.Boolean(value);
								return acc;
							},
							{},
						)
					: {},
		};
	},

	toJSON(message: SkillsToggles): unknown {
		const obj: any = {};
		if (message.globalSkillsToggles) {
			const entries = globalThis.Object.entries(
				message.globalSkillsToggles,
			) as [string, boolean][];
			if (entries.length > 0) {
				obj.globalSkillsToggles = {};
				entries.forEach(([k, v]) => {
					obj.globalSkillsToggles[k] = v;
				});
			}
		}
		if (message.localSkillsToggles) {
			const entries = globalThis.Object.entries(message.localSkillsToggles) as [
				string,
				boolean,
			][];
			if (entries.length > 0) {
				obj.localSkillsToggles = {};
				entries.forEach(([k, v]) => {
					obj.localSkillsToggles[k] = v;
				});
			}
		}
		return obj;
	},

	create(base?: DeepPartial<SkillsToggles>): SkillsToggles {
		return SkillsToggles.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<SkillsToggles>): SkillsToggles {
		const message = createBaseSkillsToggles();
		message.globalSkillsToggles = (
			globalThis.Object.entries(object.globalSkillsToggles ?? {}) as [
				string,
				boolean,
			][]
		).reduce(
			(acc: { [key: string]: boolean }, [key, value]: [string, boolean]) => {
				if (value !== undefined) {
					acc[key] = globalThis.Boolean(value);
				}
				return acc;
			},
			{},
		);
		message.localSkillsToggles = (
			globalThis.Object.entries(object.localSkillsToggles ?? {}) as [
				string,
				boolean,
			][]
		).reduce(
			(acc: { [key: string]: boolean }, [key, value]: [string, boolean]) => {
				if (value !== undefined) {
					acc[key] = globalThis.Boolean(value);
				}
				return acc;
			},
			{},
		);
		return message;
	},
};

function createBaseSkillsToggles_GlobalSkillsTogglesEntry(): SkillsToggles_GlobalSkillsTogglesEntry {
	return { key: "", value: false };
}

export const SkillsToggles_GlobalSkillsTogglesEntry: MessageFns<SkillsToggles_GlobalSkillsTogglesEntry> =
	{
		encode(
			message: SkillsToggles_GlobalSkillsTogglesEntry,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.key !== "") {
				writer.uint32(10).string(message.key);
			}
			if (message.value !== false) {
				writer.uint32(16).bool(message.value);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): SkillsToggles_GlobalSkillsTogglesEntry {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseSkillsToggles_GlobalSkillsTogglesEntry();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.key = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 16) {
							break;
						}

						message.value = reader.bool();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): SkillsToggles_GlobalSkillsTogglesEntry {
			return {
				key: isSet(object.key) ? globalThis.String(object.key) : "",
				value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
			};
		},

		toJSON(message: SkillsToggles_GlobalSkillsTogglesEntry): unknown {
			const obj: any = {};
			if (message.key !== "") {
				obj.key = message.key;
			}
			if (message.value !== false) {
				obj.value = message.value;
			}
			return obj;
		},

		create(
			base?: DeepPartial<SkillsToggles_GlobalSkillsTogglesEntry>,
		): SkillsToggles_GlobalSkillsTogglesEntry {
			return SkillsToggles_GlobalSkillsTogglesEntry.fromPartial(base ?? {});
		},
		fromPartial(
			object: DeepPartial<SkillsToggles_GlobalSkillsTogglesEntry>,
		): SkillsToggles_GlobalSkillsTogglesEntry {
			const message = createBaseSkillsToggles_GlobalSkillsTogglesEntry();
			message.key = object.key ?? "";
			message.value = object.value ?? false;
			return message;
		},
	};

function createBaseSkillsToggles_LocalSkillsTogglesEntry(): SkillsToggles_LocalSkillsTogglesEntry {
	return { key: "", value: false };
}

export const SkillsToggles_LocalSkillsTogglesEntry: MessageFns<SkillsToggles_LocalSkillsTogglesEntry> =
	{
		encode(
			message: SkillsToggles_LocalSkillsTogglesEntry,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.key !== "") {
				writer.uint32(10).string(message.key);
			}
			if (message.value !== false) {
				writer.uint32(16).bool(message.value);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): SkillsToggles_LocalSkillsTogglesEntry {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseSkillsToggles_LocalSkillsTogglesEntry();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.key = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 16) {
							break;
						}

						message.value = reader.bool();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): SkillsToggles_LocalSkillsTogglesEntry {
			return {
				key: isSet(object.key) ? globalThis.String(object.key) : "",
				value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
			};
		},

		toJSON(message: SkillsToggles_LocalSkillsTogglesEntry): unknown {
			const obj: any = {};
			if (message.key !== "") {
				obj.key = message.key;
			}
			if (message.value !== false) {
				obj.value = message.value;
			}
			return obj;
		},

		create(
			base?: DeepPartial<SkillsToggles_LocalSkillsTogglesEntry>,
		): SkillsToggles_LocalSkillsTogglesEntry {
			return SkillsToggles_LocalSkillsTogglesEntry.fromPartial(base ?? {});
		},
		fromPartial(
			object: DeepPartial<SkillsToggles_LocalSkillsTogglesEntry>,
		): SkillsToggles_LocalSkillsTogglesEntry {
			const message = createBaseSkillsToggles_LocalSkillsTogglesEntry();
			message.key = object.key ?? "";
			message.value = object.value ?? false;
			return message;
		},
	};

function createBaseToggleSkillRequest(): ToggleSkillRequest {
	return {
		metadata: undefined,
		skillPath: "",
		isGlobal: false,
		enabled: false,
	};
}

export const ToggleSkillRequest: MessageFns<ToggleSkillRequest> = {
	encode(
		message: ToggleSkillRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.skillPath !== "") {
			writer.uint32(18).string(message.skillPath);
		}
		if (message.isGlobal !== false) {
			writer.uint32(24).bool(message.isGlobal);
		}
		if (message.enabled !== false) {
			writer.uint32(32).bool(message.enabled);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): ToggleSkillRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseToggleSkillRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.skillPath = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.isGlobal = reader.bool();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.enabled = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): ToggleSkillRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata.fromJSON(object.metadata)
				: undefined,
			skillPath: isSet(object.skillPath)
				? globalThis.String(object.skillPath)
				: isSet(object.skill_path)
					? globalThis.String(object.skill_path)
					: "",
			isGlobal: isSet(object.isGlobal)
				? globalThis.Boolean(object.isGlobal)
				: isSet(object.is_global)
					? globalThis.Boolean(object.is_global)
					: false,
			enabled: isSet(object.enabled)
				? globalThis.Boolean(object.enabled)
				: false,
		};
	},

	toJSON(message: ToggleSkillRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		if (message.skillPath !== "") {
			obj.skillPath = message.skillPath;
		}
		if (message.isGlobal !== false) {
			obj.isGlobal = message.isGlobal;
		}
		if (message.enabled !== false) {
			obj.enabled = message.enabled;
		}
		return obj;
	},

	create(base?: DeepPartial<ToggleSkillRequest>): ToggleSkillRequest {
		return ToggleSkillRequest.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<ToggleSkillRequest>): ToggleSkillRequest {
		const message = createBaseToggleSkillRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata.fromPartial(object.metadata)
				: undefined;
		message.skillPath = object.skillPath ?? "";
		message.isGlobal = object.isGlobal ?? false;
		message.enabled = object.enabled ?? false;
		return message;
	},
};

function createBaseCreateSkillRequest(): CreateSkillRequest {
	return { metadata: undefined, skillName: "", isGlobal: false };
}

export const CreateSkillRequest: MessageFns<CreateSkillRequest> = {
	encode(
		message: CreateSkillRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.skillName !== "") {
			writer.uint32(18).string(message.skillName);
		}
		if (message.isGlobal !== false) {
			writer.uint32(24).bool(message.isGlobal);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): CreateSkillRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseCreateSkillRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.skillName = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.isGlobal = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): CreateSkillRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata.fromJSON(object.metadata)
				: undefined,
			skillName: isSet(object.skillName)
				? globalThis.String(object.skillName)
				: isSet(object.skill_name)
					? globalThis.String(object.skill_name)
					: "",
			isGlobal: isSet(object.isGlobal)
				? globalThis.Boolean(object.isGlobal)
				: isSet(object.is_global)
					? globalThis.Boolean(object.is_global)
					: false,
		};
	},

	toJSON(message: CreateSkillRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		if (message.skillName !== "") {
			obj.skillName = message.skillName;
		}
		if (message.isGlobal !== false) {
			obj.isGlobal = message.isGlobal;
		}
		return obj;
	},

	create(base?: DeepPartial<CreateSkillRequest>): CreateSkillRequest {
		return CreateSkillRequest.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<CreateSkillRequest>): CreateSkillRequest {
		const message = createBaseCreateSkillRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata.fromPartial(object.metadata)
				: undefined;
		message.skillName = object.skillName ?? "";
		message.isGlobal = object.isGlobal ?? false;
		return message;
	},
};

function createBaseDeleteSkillRequest(): DeleteSkillRequest {
	return { metadata: undefined, skillPath: "", isGlobal: false };
}

export const DeleteSkillRequest: MessageFns<DeleteSkillRequest> = {
	encode(
		message: DeleteSkillRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.skillPath !== "") {
			writer.uint32(18).string(message.skillPath);
		}
		if (message.isGlobal !== false) {
			writer.uint32(24).bool(message.isGlobal);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): DeleteSkillRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseDeleteSkillRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.skillPath = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.isGlobal = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): DeleteSkillRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata.fromJSON(object.metadata)
				: undefined,
			skillPath: isSet(object.skillPath)
				? globalThis.String(object.skillPath)
				: isSet(object.skill_path)
					? globalThis.String(object.skill_path)
					: "",
			isGlobal: isSet(object.isGlobal)
				? globalThis.Boolean(object.isGlobal)
				: isSet(object.is_global)
					? globalThis.Boolean(object.is_global)
					: false,
		};
	},

	toJSON(message: DeleteSkillRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		if (message.skillPath !== "") {
			obj.skillPath = message.skillPath;
		}
		if (message.isGlobal !== false) {
			obj.isGlobal = message.isGlobal;
		}
		return obj;
	},

	create(base?: DeepPartial<DeleteSkillRequest>): DeleteSkillRequest {
		return DeleteSkillRequest.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<DeleteSkillRequest>): DeleteSkillRequest {
		const message = createBaseDeleteSkillRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata.fromPartial(object.metadata)
				: undefined;
		message.skillPath = object.skillPath ?? "";
		message.isGlobal = object.isGlobal ?? false;
		return message;
	},
};

/** Service for file-related operations */
export type FileServiceDefinition = typeof FileServiceDefinition;
export const FileServiceDefinition = {
	name: "FileService",
	fullName: "cline.FileService",
	methods: {
		/** Copies text to clipboard */
		copyToClipboard: {
			name: "copyToClipboard",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/** Opens a file in the editor */
		openFile: {
			name: "openFile",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/** Opens an image in the system viewer */
		openImage: {
			name: "openImage",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/** Opens a mention (file, path, git commit, problem, terminal, or URL) */
		openMention: {
			name: "openMention",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/** Deletes a rule file from either global or workspace rules directory */
		deleteRuleFile: {
			name: "deleteRuleFile",
			requestType: RuleFileRequest,
			requestStream: false,
			responseType: RuleFile,
			responseStream: false,
			options: {},
		},
		/** Creates a rule file from either global or workspace rules directory */
		createRuleFile: {
			name: "createRuleFile",
			requestType: RuleFileRequest,
			requestStream: false,
			responseType: RuleFile,
			responseStream: false,
			options: {},
		},
		/** Search git commits in the workspace */
		searchCommits: {
			name: "searchCommits",
			requestType: StringRequest,
			requestStream: false,
			responseType: GitCommits,
			responseStream: false,
			options: {},
		},
		/** Select images and other files from the file system and returns as data URLs & paths respectively */
		selectFiles: {
			name: "selectFiles",
			requestType: BooleanRequest,
			requestStream: false,
			responseType: StringArrays,
			responseStream: false,
			options: {},
		},
		/** Convert URIs to workspace-relative paths */
		getRelativePaths: {
			name: "getRelativePaths",
			requestType: RelativePathsRequest,
			requestStream: false,
			responseType: RelativePaths,
			responseStream: false,
			options: {},
		},
		/** Search for files in the workspace with fuzzy matching */
		searchFiles: {
			name: "searchFiles",
			requestType: FileSearchRequest,
			requestStream: false,
			responseType: FileSearchResults,
			responseStream: false,
			options: {},
		},
		/** Toggle a Cline rule (enable or disable) */
		toggleClineRule: {
			name: "toggleClineRule",
			requestType: ToggleClineRuleRequest,
			requestStream: false,
			responseType: ToggleClineRules,
			responseStream: false,
			options: {},
		},
		/** Toggle a Cursor rule (enable or disable) */
		toggleCursorRule: {
			name: "toggleCursorRule",
			requestType: ToggleCursorRuleRequest,
			requestStream: false,
			responseType: ClineRulesToggles,
			responseStream: false,
			options: {},
		},
		/** Toggle a Windsurf rule (enable or disable) */
		toggleWindsurfRule: {
			name: "toggleWindsurfRule",
			requestType: ToggleWindsurfRuleRequest,
			requestStream: false,
			responseType: ClineRulesToggles,
			responseStream: false,
			options: {},
		},
		/** Toggle an Agents rule (enable or disable) */
		toggleAgentsRule: {
			name: "toggleAgentsRule",
			requestType: ToggleAgentsRuleRequest,
			requestStream: false,
			responseType: ClineRulesToggles,
			responseStream: false,
			options: {},
		},
		/** Refreshes all rule toggles (Cline, External, and Workflows) */
		refreshRules: {
			name: "refreshRules",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: RefreshedRules,
			responseStream: false,
			options: {},
		},
		/** Opens a task's conversation history file on disk */
		openDiskConversationHistory: {
			name: "openDiskConversationHistory",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/** Toggles a workflow on or off */
		toggleWorkflow: {
			name: "toggleWorkflow",
			requestType: ToggleWorkflowRequest,
			requestStream: false,
			responseType: ClineRulesToggles,
			responseStream: false,
			options: {},
		},
		/** Check if file exists in the project */
		ifFileExistsRelativePath: {
			name: "ifFileExistsRelativePath",
			requestType: StringRequest,
			requestStream: false,
			responseType: BooleanResponse,
			responseStream: false,
			options: {},
		},
		/** Open a file in editor by a relative path */
		openFileRelativePath: {
			name: "openFileRelativePath",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/** Opens or creates a focus chain checklist markdown file for editing */
		openFocusChainFile: {
			name: "openFocusChainFile",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/** Refreshes all hook toggles (discovers hooks and their enabled state) */
		refreshHooks: {
			name: "refreshHooks",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: HooksToggles,
			responseStream: false,
			options: {},
		},
		/** Toggles a hook on or off via chmod +x/-x */
		toggleHook: {
			name: "toggleHook",
			requestType: ToggleHookRequest,
			requestStream: false,
			responseType: ToggleHookResponse,
			responseStream: false,
			options: {},
		},
		/** Creates a new hook from template */
		createHook: {
			name: "createHook",
			requestType: CreateHookRequest,
			requestStream: false,
			responseType: CreateHookResponse,
			responseStream: false,
			options: {},
		},
		/** Deletes an existing hook file */
		deleteHook: {
			name: "deleteHook",
			requestType: DeleteHookRequest,
			requestStream: false,
			responseType: DeleteHookResponse,
			responseStream: false,
			options: {},
		},
		/** Refreshes all skill toggles (discovers skills and their enabled state) */
		refreshSkills: {
			name: "refreshSkills",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: RefreshedSkills,
			responseStream: false,
			options: {},
		},
		/** Toggles a skill on or off */
		toggleSkill: {
			name: "toggleSkill",
			requestType: ToggleSkillRequest,
			requestStream: false,
			responseType: SkillsToggles,
			responseStream: false,
			options: {},
		},
		/** Creates a new skill from template */
		createSkillFile: {
			name: "createSkillFile",
			requestType: CreateSkillRequest,
			requestStream: false,
			responseType: SkillsToggles,
			responseStream: false,
			options: {},
		},
		/** Deletes an existing skill directory */
		deleteSkillFile: {
			name: "deleteSkillFile",
			requestType: DeleteSkillRequest,
			requestStream: false,
			responseType: SkillsToggles,
			responseStream: false,
			options: {},
		},
	},
} as const;

export interface FileServiceImplementation<CallContextExt = {}> {
	/** Copies text to clipboard */
	copyToClipboard(
		request: StringRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<Empty>>;
	/** Opens a file in the editor */
	openFile(
		request: StringRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<Empty>>;
	/** Opens an image in the system viewer */
	openImage(
		request: StringRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<Empty>>;
	/** Opens a mention (file, path, git commit, problem, terminal, or URL) */
	openMention(
		request: StringRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<Empty>>;
	/** Deletes a rule file from either global or workspace rules directory */
	deleteRuleFile(
		request: RuleFileRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<RuleFile>>;
	/** Creates a rule file from either global or workspace rules directory */
	createRuleFile(
		request: RuleFileRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<RuleFile>>;
	/** Search git commits in the workspace */
	searchCommits(
		request: StringRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<GitCommits>>;
	/** Select images and other files from the file system and returns as data URLs & paths respectively */
	selectFiles(
		request: BooleanRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<StringArrays>>;
	/** Convert URIs to workspace-relative paths */
	getRelativePaths(
		request: RelativePathsRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<RelativePaths>>;
	/** Search for files in the workspace with fuzzy matching */
	searchFiles(
		request: FileSearchRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<FileSearchResults>>;
	/** Toggle a Cline rule (enable or disable) */
	toggleClineRule(
		request: ToggleClineRuleRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<ToggleClineRules>>;
	/** Toggle a Cursor rule (enable or disable) */
	toggleCursorRule(
		request: ToggleCursorRuleRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<ClineRulesToggles>>;
	/** Toggle a Windsurf rule (enable or disable) */
	toggleWindsurfRule(
		request: ToggleWindsurfRuleRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<ClineRulesToggles>>;
	/** Toggle an Agents rule (enable or disable) */
	toggleAgentsRule(
		request: ToggleAgentsRuleRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<ClineRulesToggles>>;
	/** Refreshes all rule toggles (Cline, External, and Workflows) */
	refreshRules(
		request: EmptyRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<RefreshedRules>>;
	/** Opens a task's conversation history file on disk */
	openDiskConversationHistory(
		request: StringRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<Empty>>;
	/** Toggles a workflow on or off */
	toggleWorkflow(
		request: ToggleWorkflowRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<ClineRulesToggles>>;
	/** Check if file exists in the project */
	ifFileExistsRelativePath(
		request: StringRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<BooleanResponse>>;
	/** Open a file in editor by a relative path */
	openFileRelativePath(
		request: StringRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<Empty>>;
	/** Opens or creates a focus chain checklist markdown file for editing */
	openFocusChainFile(
		request: StringRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<Empty>>;
	/** Refreshes all hook toggles (discovers hooks and their enabled state) */
	refreshHooks(
		request: EmptyRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<HooksToggles>>;
	/** Toggles a hook on or off via chmod +x/-x */
	toggleHook(
		request: ToggleHookRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<ToggleHookResponse>>;
	/** Creates a new hook from template */
	createHook(
		request: CreateHookRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<CreateHookResponse>>;
	/** Deletes an existing hook file */
	deleteHook(
		request: DeleteHookRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<DeleteHookResponse>>;
	/** Refreshes all skill toggles (discovers skills and their enabled state) */
	refreshSkills(
		request: EmptyRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<RefreshedSkills>>;
	/** Toggles a skill on or off */
	toggleSkill(
		request: ToggleSkillRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<SkillsToggles>>;
	/** Creates a new skill from template */
	createSkillFile(
		request: CreateSkillRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<SkillsToggles>>;
	/** Deletes an existing skill directory */
	deleteSkillFile(
		request: DeleteSkillRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<SkillsToggles>>;
}

export interface FileServiceClient<CallOptionsExt = {}> {
	/** Copies text to clipboard */
	copyToClipboard(
		request: DeepPartial<StringRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<Empty>;
	/** Opens a file in the editor */
	openFile(
		request: DeepPartial<StringRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<Empty>;
	/** Opens an image in the system viewer */
	openImage(
		request: DeepPartial<StringRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<Empty>;
	/** Opens a mention (file, path, git commit, problem, terminal, or URL) */
	openMention(
		request: DeepPartial<StringRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<Empty>;
	/** Deletes a rule file from either global or workspace rules directory */
	deleteRuleFile(
		request: DeepPartial<RuleFileRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<RuleFile>;
	/** Creates a rule file from either global or workspace rules directory */
	createRuleFile(
		request: DeepPartial<RuleFileRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<RuleFile>;
	/** Search git commits in the workspace */
	searchCommits(
		request: DeepPartial<StringRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<GitCommits>;
	/** Select images and other files from the file system and returns as data URLs & paths respectively */
	selectFiles(
		request: DeepPartial<BooleanRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<StringArrays>;
	/** Convert URIs to workspace-relative paths */
	getRelativePaths(
		request: DeepPartial<RelativePathsRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<RelativePaths>;
	/** Search for files in the workspace with fuzzy matching */
	searchFiles(
		request: DeepPartial<FileSearchRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<FileSearchResults>;
	/** Toggle a Cline rule (enable or disable) */
	toggleClineRule(
		request: DeepPartial<ToggleClineRuleRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<ToggleClineRules>;
	/** Toggle a Cursor rule (enable or disable) */
	toggleCursorRule(
		request: DeepPartial<ToggleCursorRuleRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<ClineRulesToggles>;
	/** Toggle a Windsurf rule (enable or disable) */
	toggleWindsurfRule(
		request: DeepPartial<ToggleWindsurfRuleRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<ClineRulesToggles>;
	/** Toggle an Agents rule (enable or disable) */
	toggleAgentsRule(
		request: DeepPartial<ToggleAgentsRuleRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<ClineRulesToggles>;
	/** Refreshes all rule toggles (Cline, External, and Workflows) */
	refreshRules(
		request: DeepPartial<EmptyRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<RefreshedRules>;
	/** Opens a task's conversation history file on disk */
	openDiskConversationHistory(
		request: DeepPartial<StringRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<Empty>;
	/** Toggles a workflow on or off */
	toggleWorkflow(
		request: DeepPartial<ToggleWorkflowRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<ClineRulesToggles>;
	/** Check if file exists in the project */
	ifFileExistsRelativePath(
		request: DeepPartial<StringRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<BooleanResponse>;
	/** Open a file in editor by a relative path */
	openFileRelativePath(
		request: DeepPartial<StringRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<Empty>;
	/** Opens or creates a focus chain checklist markdown file for editing */
	openFocusChainFile(
		request: DeepPartial<StringRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<Empty>;
	/** Refreshes all hook toggles (discovers hooks and their enabled state) */
	refreshHooks(
		request: DeepPartial<EmptyRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<HooksToggles>;
	/** Toggles a hook on or off via chmod +x/-x */
	toggleHook(
		request: DeepPartial<ToggleHookRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<ToggleHookResponse>;
	/** Creates a new hook from template */
	createHook(
		request: DeepPartial<CreateHookRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<CreateHookResponse>;
	/** Deletes an existing hook file */
	deleteHook(
		request: DeepPartial<DeleteHookRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<DeleteHookResponse>;
	/** Refreshes all skill toggles (discovers skills and their enabled state) */
	refreshSkills(
		request: DeepPartial<EmptyRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<RefreshedSkills>;
	/** Toggles a skill on or off */
	toggleSkill(
		request: DeepPartial<ToggleSkillRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<SkillsToggles>;
	/** Creates a new skill from template */
	createSkillFile(
		request: DeepPartial<CreateSkillRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<SkillsToggles>;
	/** Deletes an existing skill directory */
	deleteSkillFile(
		request: DeepPartial<DeleteSkillRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<SkillsToggles>;
}

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

function isObject(value: any): boolean {
	return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create(base?: DeepPartial<T>): T;
	fromPartial(object: DeepPartial<T>): T;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: cline/dictation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";
import { EmptyRequest } from "./common";

export interface TranscribeAudioRequest {
	audioBase64: string;
	language: string;
}

export interface RecordingResult {
	success: boolean;
	error: string;
}

export interface RecordedAudio {
	success: boolean;
	audioBase64: string;
	error: string;
}

export interface RecordingStatus {
	isRecording: boolean;
	durationSeconds: number;
	error: string;
}

export interface Transcription {
	text: string;
	error: string;
}

function createBaseTranscribeAudioRequest(): TranscribeAudioRequest {
	return { audioBase64: "", language: "" };
}

export const TranscribeAudioRequest: MessageFns<TranscribeAudioRequest> = {
	encode(
		message: TranscribeAudioRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.audioBase64 !== "") {
			writer.uint32(18).string(message.audioBase64);
		}
		if (message.language !== "") {
			writer.uint32(26).string(message.language);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): TranscribeAudioRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseTranscribeAudioRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.audioBase64 = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.language = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): TranscribeAudioRequest {
		return {
			audioBase64: isSet(object.audioBase64)
				? globalThis.String(object.audioBase64)
				: isSet(object.audio_base64)
					? globalThis.String(object.audio_base64)
					: "",
			language: isSet(object.language)
				? globalThis.String(object.language)
				: "",
		};
	},

	toJSON(message: TranscribeAudioRequest): unknown {
		const obj: any = {};
		if (message.audioBase64 !== "") {
			obj.audioBase64 = message.audioBase64;
		}
		if (message.language !== "") {
			obj.language = message.language;
		}
		return obj;
	},

	create(base?: DeepPartial<TranscribeAudioRequest>): TranscribeAudioRequest {
		return TranscribeAudioRequest.fromPartial(base ?? {});
	},
	fromPartial(
		object: DeepPartial<TranscribeAudioRequest>,
	): TranscribeAudioRequest {
		const message = createBaseTranscribeAudioRequest();
		message.audioBase64 = object.audioBase64 ?? "";
		message.language = object.language ?? "";
		return message;
	},
};

function createBaseRecordingResult(): RecordingResult {
	return { success: false, error: "" };
}

export const RecordingResult: MessageFns<RecordingResult> = {
	encode(
		message: RecordingResult,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.success !== false) {
			writer.uint32(8).bool(message.success);
		}
		if (message.error !== "") {
			writer.uint32(18).string(message.error);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RecordingResult {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRecordingResult();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.success = reader.bool();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.error = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): RecordingResult {
		return {
			success: isSet(object.success)
				? globalThis.Boolean(object.success)
				: false,
			error: isSet(object.error) ? globalThis.String(object.error) : "",
		};
	},

	toJSON(message: RecordingResult): unknown {
		const obj: any = {};
		if (message.success !== false) {
			obj.success = message.success;
		}
		if (message.error !== "") {
			obj.error = message.error;
		}
		return obj;
	},

	create(base?: DeepPartial<RecordingResult>): RecordingResult {
		return RecordingResult.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<RecordingResult>): RecordingResult {
		const message = createBaseRecordingResult();
		message.success = object.success ?? false;
		message.error = object.error ?? "";
		return message;
	},
};

function createBaseRecordedAudio(): RecordedAudio {
	return { success: false, audioBase64: "", error: "" };
}

export const RecordedAudio: MessageFns<RecordedAudio> = {
	encode(
		message: RecordedAudio,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.success !== false) {
			writer.uint32(8).bool(message.success);
		}
		if (message.audioBase64 !== "") {
			writer.uint32(18).string(message.audioBase64);
		}
		if (message.error !== "") {
			writer.uint32(26).string(message.error);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RecordedAudio {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRecordedAudio();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.success = reader.bool();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.audioBase64 = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.error = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): RecordedAudio {
		return {
			success: isSet(object.success)
				? globalThis.Boolean(object.success)
				: false,
			audioBase64: isSet(object.audioBase64)
				? globalThis.String(object.audioBase64)
				: isSet(object.audio_base64)
					? globalThis.String(object.audio_base64)
					: "",
			error: isSet(object.error) ? globalThis.String(object.error) : "",
		};
	},

	toJSON(message: RecordedAudio): unknown {
		const obj: any = {};
		if (message.success !== false) {
			obj.success = message.success;
		}
		if (message.audioBase64 !== "") {
			obj.audioBase64 = message.audioBase64;
		}
		if (message.error !== "") {
			obj.error = message.error;
		}
		return obj;
	},

	create(base?: DeepPartial<RecordedAudio>): RecordedAudio {
		return RecordedAudio.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<RecordedAudio>): RecordedAudio {
		const message = createBaseRecordedAudio();
		message.success = object.success ?? false;
		message.audioBase64 = object.audioBase64 ?? "";
		message.error = object.error ?? "";
		return message;
	},
};

function createBaseRecordingStatus(): RecordingStatus {
	return { isRecording: false, durationSeconds: 0, error: "" };
}

export const RecordingStatus: MessageFns<RecordingStatus> = {
	encode(
		message: RecordingStatus,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.isRecording !== false) {
			writer.uint32(8).bool(message.isRecording);
		}
		if (message.durationSeconds !== 0) {
			writer.uint32(17).double(message.durationSeconds);
		}
		if (message.error !== "") {
			writer.uint32(26).string(message.error);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): RecordingStatus {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseRecordingStatus();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.isRecording = reader.bool();
					continue;
				}
				case 2: {
					if (tag !== 17) {
						break;
					}

					message.durationSeconds = reader.double();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.error = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): RecordingStatus {
		return {
			isRecording: isSet(object.isRecording)
				? globalThis.Boolean(object.isRecording)
				: isSet(object.is_recording)
					? globalThis.Boolean(object.is_recording)
					: false,
			durationSeconds: isSet(object.durationSeconds)
				? globalThis.Number(object.durationSeconds)
				: isSet(object.duration_seconds)
					? globalThis.Number(object.duration_seconds)
					: 0,
			error: isSet(object.error) ? globalThis.String(object.error) : "",
		};
	},

	toJSON(message: RecordingStatus): unknown {
		const obj: any = {};
		if (message.isRecording !== false) {
			obj.isRecording = message.isRecording;
		}
		if (message.durationSeconds !== 0) {
			obj.durationSeconds = message.durationSeconds;
		}
		if (message.error !== "") {
			obj.error = message.error;
		}
		return obj;
	},

	create(base?: DeepPartial<RecordingStatus>): RecordingStatus {
		return RecordingStatus.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<RecordingStatus>): RecordingStatus {
		const message = createBaseRecordingStatus();
		message.isRecording = object.isRecording ?? false;
		message.durationSeconds = object.durationSeconds ?? 0;
		message.error = object.error ?? "";
		return message;
	},
};

function createBaseTranscription(): Transcription {
	return { text: "", error: "" };
}

export const Transcription: MessageFns<Transcription> = {
	encode(
		message: Transcription,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.text !== "") {
			writer.uint32(10).string(message.text);
		}
		if (message.error !== "") {
			writer.uint32(18).string(message.error);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Transcription {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseTranscription();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.text = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.error = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Transcription {
		return {
			text: isSet(object.text) ? globalThis.String(object.text) : "",
			error: isSet(object.error) ? globalThis.String(object.error) : "",
		};
	},

	toJSON(message: Transcription): unknown {
		const obj: any = {};
		if (message.text !== "") {
			obj.text = message.text;
		}
		if (message.error !== "") {
			obj.error = message.error;
		}
		return obj;
	},

	create(base?: DeepPartial<Transcription>): Transcription {
		return Transcription.fromPartial(base ?? {});
	},
	fromPartial(object: DeepPartial<Transcription>): Transcription {
		const message = createBaseTranscription();
		message.text = object.text ?? "";
		message.error = object.error ?? "";
		return message;
	},
};

export type DictationServiceDefinition = typeof DictationServiceDefinition;
export const DictationServiceDefinition = {
	name: "DictationService",
	fullName: "cline.DictationService",
	methods: {
		startRecording: {
			name: "startRecording",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: RecordingResult,
			responseStream: false,
			options: {},
		},
		stopRecording: {
			name: "stopRecording",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: RecordedAudio,
			responseStream: false,
			options: {},
		},
		cancelRecording: {
			name: "cancelRecording",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: RecordingResult,
			responseStream: false,
			options: {},
		},
		getRecordingStatus: {
			name: "getRecordingStatus",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: RecordingStatus,
			responseStream: false,
			options: {},
		},
		transcribeAudio: {
			name: "transcribeAudio",
			requestType: TranscribeAudioRequest,
			requestStream: false,
			responseType: Transcription,
			responseStream: false,
			options: {},
		},
	},
} as const;

export interface DictationServiceImplementation<CallContextExt = {}> {
	startRecording(
		request: EmptyRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<RecordingResult>>;
	stopRecording(
		request: EmptyRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<RecordedAudio>>;
	cancelRecording(
		request: EmptyRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<RecordingResult>>;
	getRecordingStatus(
		request: EmptyRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<RecordingStatus>>;
	transcribeAudio(
		request: TranscribeAudioRequest,
		context: CallContext & CallContextExt,
	): Promise<DeepPartial<Transcription>>;
}

export interface DictationServiceClient<CallOptionsExt = {}> {
	startRecording(
		request: DeepPartial<EmptyRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<RecordingResult>;
	stopRecording(
		request: DeepPartial<EmptyRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<RecordedAudio>;
	cancelRecording(
		request: DeepPartial<EmptyRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<RecordingResult>;
	getRecordingStatus(
		request: DeepPartial<EmptyRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<RecordingStatus>;
	transcribeAudio(
		request: DeepPartial<TranscribeAudioRequest>,
		options?: CallOptions & CallOptionsExt,
	): Promise<Transcription>;
}

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create(base?: DeepPartial<T>): T;
	fromPartial(object: DeepPartial<T>): T;
}

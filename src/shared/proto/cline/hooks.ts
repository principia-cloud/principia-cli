// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: cline/hooks.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

/** Input message for all hooks */
export interface HookInput {
	clineVersion: string;
	hookName: string;
	timestamp: string;
	taskId: string;
	workspaceRoots: string[];
	userId: string;
	preToolUse?: PreToolUseData | undefined;
	postToolUse?: PostToolUseData | undefined;
	userPromptSubmit?: UserPromptSubmitData | undefined;
	taskStart?: TaskStartData | undefined;
	taskResume?: TaskResumeData | undefined;
	taskCancel?: TaskCancelData | undefined;
	taskComplete?: TaskCompleteData | undefined;
	preCompact?: PreCompactData | undefined;
}

/** Output message for all hooks */
export interface HookOutput {
	contextModification: string;
	cancel: boolean;
	errorMessage: string;
}

/** Data for PreToolUse hook */
export interface PreToolUseData {
	toolName: string;
	parameters: { [key: string]: string };
}

export interface PreToolUseData_ParametersEntry {
	key: string;
	value: string;
}

/** Data for PostToolUse hook */
export interface PostToolUseData {
	toolName: string;
	parameters: { [key: string]: string };
	result: string;
	success: boolean;
	executionTimeMs: number;
}

export interface PostToolUseData_ParametersEntry {
	key: string;
	value: string;
}

/** Data for UserPromptSubmit hook */
export interface UserPromptSubmitData {
	prompt: string;
	attachments: string[];
}

/** Data for TaskStart hook */
export interface TaskStartData {
	taskMetadata: { [key: string]: string };
}

export interface TaskStartData_TaskMetadataEntry {
	key: string;
	value: string;
}

/** Data for TaskResume hook */
export interface TaskResumeData {
	taskMetadata: { [key: string]: string };
	previousState: { [key: string]: string };
}

export interface TaskResumeData_TaskMetadataEntry {
	key: string;
	value: string;
}

export interface TaskResumeData_PreviousStateEntry {
	key: string;
	value: string;
}

/** Data for TaskCancel hook */
export interface TaskCancelData {
	taskMetadata: { [key: string]: string };
}

export interface TaskCancelData_TaskMetadataEntry {
	key: string;
	value: string;
}

/** Data for TaskComplete hook */
export interface TaskCompleteData {
	taskMetadata: { [key: string]: string };
}

export interface TaskCompleteData_TaskMetadataEntry {
	key: string;
	value: string;
}

/** Data for PreCompact hook */
export interface PreCompactData {
	/** Task identification */
	taskId: string;
	ulid: string;
	/** Context size information */
	contextSize: number;
	/**
	 * Compaction strategy indicating how conversation history is managed:
	 * * auto-condense:                   AI-powered compression using summarize_task tool
	 * * standard-truncation-firstpair:   Keep only the original task (used during auto-condense)
	 * * standard-truncation-lasthalf:    Keep first pair + most recent 50% of conversation
	 * * standard-truncation-lastquarter: Keep first pair + most recent 25% of conversation (aggressive)
	 */
	compactionStrategy: string;
	/** API request tracking */
	previousApiReqIndex: number;
	/** Token usage data from last API request */
	tokensIn: number;
	tokensOut: number;
	tokensInCache: number;
	tokensOutCache: number;
	/** Truncation information (if applicable) */
	deletedRangeStart: number;
	/** End index of deleted conversation range */
	deletedRangeEnd: number;
	/**
	 * Context JSON file path
	 * Path to a temporary JSON file containing the full API conversation history
	 * The file contains an array of message objects with role and content
	 * Hooks can read this file to analyze conversation contents before compaction
	 * This file will be automatically cleaned up after the hook completes
	 */
	contextJsonPath: string;
	/**
	 * Context raw/formatted file path
	 * Path to a temporary text file containing the complete context window sent to the LLM
	 * This includes the system prompt, environment details, conversation history, and all formatting
	 * Represents the actual input the LLM receives (format varies by provider)
	 * Use this to analyze total context size, overhead, and exactly what the model sees
	 * This file will be automatically cleaned up after the hook completes
	 */
	contextRawPath: string;
}

function createBaseHookInput(): HookInput {
	return {
		clineVersion: "",
		hookName: "",
		timestamp: "",
		taskId: "",
		workspaceRoots: [],
		userId: "",
		preToolUse: undefined,
		postToolUse: undefined,
		userPromptSubmit: undefined,
		taskStart: undefined,
		taskResume: undefined,
		taskCancel: undefined,
		taskComplete: undefined,
		preCompact: undefined,
	};
}

export const HookInput: MessageFns<HookInput> = {
	encode(
		message: HookInput,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.clineVersion !== "") {
			writer.uint32(10).string(message.clineVersion);
		}
		if (message.hookName !== "") {
			writer.uint32(18).string(message.hookName);
		}
		if (message.timestamp !== "") {
			writer.uint32(26).string(message.timestamp);
		}
		if (message.taskId !== "") {
			writer.uint32(34).string(message.taskId);
		}
		for (const v of message.workspaceRoots) {
			writer.uint32(42).string(v!);
		}
		if (message.userId !== "") {
			writer.uint32(50).string(message.userId);
		}
		if (message.preToolUse !== undefined) {
			PreToolUseData.encode(
				message.preToolUse,
				writer.uint32(82).fork(),
			).join();
		}
		if (message.postToolUse !== undefined) {
			PostToolUseData.encode(
				message.postToolUse,
				writer.uint32(90).fork(),
			).join();
		}
		if (message.userPromptSubmit !== undefined) {
			UserPromptSubmitData.encode(
				message.userPromptSubmit,
				writer.uint32(98).fork(),
			).join();
		}
		if (message.taskStart !== undefined) {
			TaskStartData.encode(message.taskStart, writer.uint32(106).fork()).join();
		}
		if (message.taskResume !== undefined) {
			TaskResumeData.encode(
				message.taskResume,
				writer.uint32(114).fork(),
			).join();
		}
		if (message.taskCancel !== undefined) {
			TaskCancelData.encode(
				message.taskCancel,
				writer.uint32(122).fork(),
			).join();
		}
		if (message.taskComplete !== undefined) {
			TaskCompleteData.encode(
				message.taskComplete,
				writer.uint32(130).fork(),
			).join();
		}
		if (message.preCompact !== undefined) {
			PreCompactData.encode(
				message.preCompact,
				writer.uint32(138).fork(),
			).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): HookInput {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseHookInput();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.clineVersion = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.hookName = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.timestamp = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.taskId = reader.string();
					continue;
				}
				case 5: {
					if (tag !== 42) {
						break;
					}

					message.workspaceRoots.push(reader.string());
					continue;
				}
				case 6: {
					if (tag !== 50) {
						break;
					}

					message.userId = reader.string();
					continue;
				}
				case 10: {
					if (tag !== 82) {
						break;
					}

					message.preToolUse = PreToolUseData.decode(reader, reader.uint32());
					continue;
				}
				case 11: {
					if (tag !== 90) {
						break;
					}

					message.postToolUse = PostToolUseData.decode(reader, reader.uint32());
					continue;
				}
				case 12: {
					if (tag !== 98) {
						break;
					}

					message.userPromptSubmit = UserPromptSubmitData.decode(
						reader,
						reader.uint32(),
					);
					continue;
				}
				case 13: {
					if (tag !== 106) {
						break;
					}

					message.taskStart = TaskStartData.decode(reader, reader.uint32());
					continue;
				}
				case 14: {
					if (tag !== 114) {
						break;
					}

					message.taskResume = TaskResumeData.decode(reader, reader.uint32());
					continue;
				}
				case 15: {
					if (tag !== 122) {
						break;
					}

					message.taskCancel = TaskCancelData.decode(reader, reader.uint32());
					continue;
				}
				case 16: {
					if (tag !== 130) {
						break;
					}

					message.taskComplete = TaskCompleteData.decode(
						reader,
						reader.uint32(),
					);
					continue;
				}
				case 17: {
					if (tag !== 138) {
						break;
					}

					message.preCompact = PreCompactData.decode(reader, reader.uint32());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): HookInput {
		return {
			clineVersion: isSet(object.clineVersion)
				? globalThis.String(object.clineVersion)
				: isSet(object.cline_version)
					? globalThis.String(object.cline_version)
					: "",
			hookName: isSet(object.hookName)
				? globalThis.String(object.hookName)
				: isSet(object.hook_name)
					? globalThis.String(object.hook_name)
					: "",
			timestamp: isSet(object.timestamp)
				? globalThis.String(object.timestamp)
				: "",
			taskId: isSet(object.taskId)
				? globalThis.String(object.taskId)
				: isSet(object.task_id)
					? globalThis.String(object.task_id)
					: "",
			workspaceRoots: globalThis.Array.isArray(object?.workspaceRoots)
				? object.workspaceRoots.map((e: any) => globalThis.String(e))
				: globalThis.Array.isArray(object?.workspace_roots)
					? object.workspace_roots.map((e: any) => globalThis.String(e))
					: [],
			userId: isSet(object.userId)
				? globalThis.String(object.userId)
				: isSet(object.user_id)
					? globalThis.String(object.user_id)
					: "",
			preToolUse: isSet(object.preToolUse)
				? PreToolUseData.fromJSON(object.preToolUse)
				: isSet(object.pre_tool_use)
					? PreToolUseData.fromJSON(object.pre_tool_use)
					: undefined,
			postToolUse: isSet(object.postToolUse)
				? PostToolUseData.fromJSON(object.postToolUse)
				: isSet(object.post_tool_use)
					? PostToolUseData.fromJSON(object.post_tool_use)
					: undefined,
			userPromptSubmit: isSet(object.userPromptSubmit)
				? UserPromptSubmitData.fromJSON(object.userPromptSubmit)
				: isSet(object.user_prompt_submit)
					? UserPromptSubmitData.fromJSON(object.user_prompt_submit)
					: undefined,
			taskStart: isSet(object.taskStart)
				? TaskStartData.fromJSON(object.taskStart)
				: isSet(object.task_start)
					? TaskStartData.fromJSON(object.task_start)
					: undefined,
			taskResume: isSet(object.taskResume)
				? TaskResumeData.fromJSON(object.taskResume)
				: isSet(object.task_resume)
					? TaskResumeData.fromJSON(object.task_resume)
					: undefined,
			taskCancel: isSet(object.taskCancel)
				? TaskCancelData.fromJSON(object.taskCancel)
				: isSet(object.task_cancel)
					? TaskCancelData.fromJSON(object.task_cancel)
					: undefined,
			taskComplete: isSet(object.taskComplete)
				? TaskCompleteData.fromJSON(object.taskComplete)
				: isSet(object.task_complete)
					? TaskCompleteData.fromJSON(object.task_complete)
					: undefined,
			preCompact: isSet(object.preCompact)
				? PreCompactData.fromJSON(object.preCompact)
				: isSet(object.pre_compact)
					? PreCompactData.fromJSON(object.pre_compact)
					: undefined,
		};
	},

	toJSON(message: HookInput): unknown {
		const obj: any = {};
		if (message.clineVersion !== "") {
			obj.clineVersion = message.clineVersion;
		}
		if (message.hookName !== "") {
			obj.hookName = message.hookName;
		}
		if (message.timestamp !== "") {
			obj.timestamp = message.timestamp;
		}
		if (message.taskId !== "") {
			obj.taskId = message.taskId;
		}
		if (message.workspaceRoots?.length) {
			obj.workspaceRoots = message.workspaceRoots;
		}
		if (message.userId !== "") {
			obj.userId = message.userId;
		}
		if (message.preToolUse !== undefined) {
			obj.preToolUse = PreToolUseData.toJSON(message.preToolUse);
		}
		if (message.postToolUse !== undefined) {
			obj.postToolUse = PostToolUseData.toJSON(message.postToolUse);
		}
		if (message.userPromptSubmit !== undefined) {
			obj.userPromptSubmit = UserPromptSubmitData.toJSON(
				message.userPromptSubmit,
			);
		}
		if (message.taskStart !== undefined) {
			obj.taskStart = TaskStartData.toJSON(message.taskStart);
		}
		if (message.taskResume !== undefined) {
			obj.taskResume = TaskResumeData.toJSON(message.taskResume);
		}
		if (message.taskCancel !== undefined) {
			obj.taskCancel = TaskCancelData.toJSON(message.taskCancel);
		}
		if (message.taskComplete !== undefined) {
			obj.taskComplete = TaskCompleteData.toJSON(message.taskComplete);
		}
		if (message.preCompact !== undefined) {
			obj.preCompact = PreCompactData.toJSON(message.preCompact);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<HookInput>, I>>(base?: I): HookInput {
		return HookInput.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<HookInput>, I>>(
		object: I,
	): HookInput {
		const message = createBaseHookInput();
		message.clineVersion = object.clineVersion ?? "";
		message.hookName = object.hookName ?? "";
		message.timestamp = object.timestamp ?? "";
		message.taskId = object.taskId ?? "";
		message.workspaceRoots = object.workspaceRoots?.map((e) => e) || [];
		message.userId = object.userId ?? "";
		message.preToolUse =
			object.preToolUse !== undefined && object.preToolUse !== null
				? PreToolUseData.fromPartial(object.preToolUse)
				: undefined;
		message.postToolUse =
			object.postToolUse !== undefined && object.postToolUse !== null
				? PostToolUseData.fromPartial(object.postToolUse)
				: undefined;
		message.userPromptSubmit =
			object.userPromptSubmit !== undefined && object.userPromptSubmit !== null
				? UserPromptSubmitData.fromPartial(object.userPromptSubmit)
				: undefined;
		message.taskStart =
			object.taskStart !== undefined && object.taskStart !== null
				? TaskStartData.fromPartial(object.taskStart)
				: undefined;
		message.taskResume =
			object.taskResume !== undefined && object.taskResume !== null
				? TaskResumeData.fromPartial(object.taskResume)
				: undefined;
		message.taskCancel =
			object.taskCancel !== undefined && object.taskCancel !== null
				? TaskCancelData.fromPartial(object.taskCancel)
				: undefined;
		message.taskComplete =
			object.taskComplete !== undefined && object.taskComplete !== null
				? TaskCompleteData.fromPartial(object.taskComplete)
				: undefined;
		message.preCompact =
			object.preCompact !== undefined && object.preCompact !== null
				? PreCompactData.fromPartial(object.preCompact)
				: undefined;
		return message;
	},
};

function createBaseHookOutput(): HookOutput {
	return { contextModification: "", cancel: false, errorMessage: "" };
}

export const HookOutput: MessageFns<HookOutput> = {
	encode(
		message: HookOutput,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.contextModification !== "") {
			writer.uint32(10).string(message.contextModification);
		}
		if (message.cancel !== false) {
			writer.uint32(16).bool(message.cancel);
		}
		if (message.errorMessage !== "") {
			writer.uint32(26).string(message.errorMessage);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): HookOutput {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseHookOutput();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.contextModification = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 16) {
						break;
					}

					message.cancel = reader.bool();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.errorMessage = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): HookOutput {
		return {
			contextModification: isSet(object.contextModification)
				? globalThis.String(object.contextModification)
				: isSet(object.context_modification)
					? globalThis.String(object.context_modification)
					: "",
			cancel: isSet(object.cancel) ? globalThis.Boolean(object.cancel) : false,
			errorMessage: isSet(object.errorMessage)
				? globalThis.String(object.errorMessage)
				: isSet(object.error_message)
					? globalThis.String(object.error_message)
					: "",
		};
	},

	toJSON(message: HookOutput): unknown {
		const obj: any = {};
		if (message.contextModification !== "") {
			obj.contextModification = message.contextModification;
		}
		if (message.cancel !== false) {
			obj.cancel = message.cancel;
		}
		if (message.errorMessage !== "") {
			obj.errorMessage = message.errorMessage;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<HookOutput>, I>>(base?: I): HookOutput {
		return HookOutput.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<HookOutput>, I>>(
		object: I,
	): HookOutput {
		const message = createBaseHookOutput();
		message.contextModification = object.contextModification ?? "";
		message.cancel = object.cancel ?? false;
		message.errorMessage = object.errorMessage ?? "";
		return message;
	},
};

function createBasePreToolUseData(): PreToolUseData {
	return { toolName: "", parameters: {} };
}

export const PreToolUseData: MessageFns<PreToolUseData> = {
	encode(
		message: PreToolUseData,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.toolName !== "") {
			writer.uint32(10).string(message.toolName);
		}
		globalThis.Object.entries(message.parameters).forEach(
			([key, value]: [string, string]) => {
				PreToolUseData_ParametersEntry.encode(
					{ key: key as any, value },
					writer.uint32(18).fork(),
				).join();
			},
		);
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): PreToolUseData {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBasePreToolUseData();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.toolName = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					const entry2 = PreToolUseData_ParametersEntry.decode(
						reader,
						reader.uint32(),
					);
					if (entry2.value !== undefined) {
						message.parameters[entry2.key] = entry2.value;
					}
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): PreToolUseData {
		return {
			toolName: isSet(object.toolName)
				? globalThis.String(object.toolName)
				: isSet(object.tool_name)
					? globalThis.String(object.tool_name)
					: "",
			parameters: isObject(object.parameters)
				? (
						globalThis.Object.entries(object.parameters) as [string, any][]
					).reduce(
						(acc: { [key: string]: string }, [key, value]: [string, any]) => {
							acc[key] = globalThis.String(value);
							return acc;
						},
						{},
					)
				: {},
		};
	},

	toJSON(message: PreToolUseData): unknown {
		const obj: any = {};
		if (message.toolName !== "") {
			obj.toolName = message.toolName;
		}
		if (message.parameters) {
			const entries = globalThis.Object.entries(message.parameters) as [
				string,
				string,
			][];
			if (entries.length > 0) {
				obj.parameters = {};
				entries.forEach(([k, v]) => {
					obj.parameters[k] = v;
				});
			}
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<PreToolUseData>, I>>(
		base?: I,
	): PreToolUseData {
		return PreToolUseData.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<PreToolUseData>, I>>(
		object: I,
	): PreToolUseData {
		const message = createBasePreToolUseData();
		message.toolName = object.toolName ?? "";
		message.parameters = (
			globalThis.Object.entries(object.parameters ?? {}) as [string, string][]
		).reduce(
			(acc: { [key: string]: string }, [key, value]: [string, string]) => {
				if (value !== undefined) {
					acc[key] = globalThis.String(value);
				}
				return acc;
			},
			{},
		);
		return message;
	},
};

function createBasePreToolUseData_ParametersEntry(): PreToolUseData_ParametersEntry {
	return { key: "", value: "" };
}

export const PreToolUseData_ParametersEntry: MessageFns<PreToolUseData_ParametersEntry> =
	{
		encode(
			message: PreToolUseData_ParametersEntry,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.key !== "") {
				writer.uint32(10).string(message.key);
			}
			if (message.value !== "") {
				writer.uint32(18).string(message.value);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): PreToolUseData_ParametersEntry {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBasePreToolUseData_ParametersEntry();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.key = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 18) {
							break;
						}

						message.value = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): PreToolUseData_ParametersEntry {
			return {
				key: isSet(object.key) ? globalThis.String(object.key) : "",
				value: isSet(object.value) ? globalThis.String(object.value) : "",
			};
		},

		toJSON(message: PreToolUseData_ParametersEntry): unknown {
			const obj: any = {};
			if (message.key !== "") {
				obj.key = message.key;
			}
			if (message.value !== "") {
				obj.value = message.value;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<PreToolUseData_ParametersEntry>, I>>(
			base?: I,
		): PreToolUseData_ParametersEntry {
			return PreToolUseData_ParametersEntry.fromPartial(base ?? ({} as any));
		},
		fromPartial<
			I extends Exact<DeepPartial<PreToolUseData_ParametersEntry>, I>,
		>(object: I): PreToolUseData_ParametersEntry {
			const message = createBasePreToolUseData_ParametersEntry();
			message.key = object.key ?? "";
			message.value = object.value ?? "";
			return message;
		},
	};

function createBasePostToolUseData(): PostToolUseData {
	return {
		toolName: "",
		parameters: {},
		result: "",
		success: false,
		executionTimeMs: 0,
	};
}

export const PostToolUseData: MessageFns<PostToolUseData> = {
	encode(
		message: PostToolUseData,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.toolName !== "") {
			writer.uint32(10).string(message.toolName);
		}
		globalThis.Object.entries(message.parameters).forEach(
			([key, value]: [string, string]) => {
				PostToolUseData_ParametersEntry.encode(
					{ key: key as any, value },
					writer.uint32(18).fork(),
				).join();
			},
		);
		if (message.result !== "") {
			writer.uint32(26).string(message.result);
		}
		if (message.success !== false) {
			writer.uint32(32).bool(message.success);
		}
		if (message.executionTimeMs !== 0) {
			writer.uint32(40).int64(message.executionTimeMs);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): PostToolUseData {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBasePostToolUseData();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.toolName = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					const entry2 = PostToolUseData_ParametersEntry.decode(
						reader,
						reader.uint32(),
					);
					if (entry2.value !== undefined) {
						message.parameters[entry2.key] = entry2.value;
					}
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.result = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.success = reader.bool();
					continue;
				}
				case 5: {
					if (tag !== 40) {
						break;
					}

					message.executionTimeMs = longToNumber(reader.int64());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): PostToolUseData {
		return {
			toolName: isSet(object.toolName)
				? globalThis.String(object.toolName)
				: isSet(object.tool_name)
					? globalThis.String(object.tool_name)
					: "",
			parameters: isObject(object.parameters)
				? (
						globalThis.Object.entries(object.parameters) as [string, any][]
					).reduce(
						(acc: { [key: string]: string }, [key, value]: [string, any]) => {
							acc[key] = globalThis.String(value);
							return acc;
						},
						{},
					)
				: {},
			result: isSet(object.result) ? globalThis.String(object.result) : "",
			success: isSet(object.success)
				? globalThis.Boolean(object.success)
				: false,
			executionTimeMs: isSet(object.executionTimeMs)
				? globalThis.Number(object.executionTimeMs)
				: isSet(object.execution_time_ms)
					? globalThis.Number(object.execution_time_ms)
					: 0,
		};
	},

	toJSON(message: PostToolUseData): unknown {
		const obj: any = {};
		if (message.toolName !== "") {
			obj.toolName = message.toolName;
		}
		if (message.parameters) {
			const entries = globalThis.Object.entries(message.parameters) as [
				string,
				string,
			][];
			if (entries.length > 0) {
				obj.parameters = {};
				entries.forEach(([k, v]) => {
					obj.parameters[k] = v;
				});
			}
		}
		if (message.result !== "") {
			obj.result = message.result;
		}
		if (message.success !== false) {
			obj.success = message.success;
		}
		if (message.executionTimeMs !== 0) {
			obj.executionTimeMs = Math.round(message.executionTimeMs);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<PostToolUseData>, I>>(
		base?: I,
	): PostToolUseData {
		return PostToolUseData.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<PostToolUseData>, I>>(
		object: I,
	): PostToolUseData {
		const message = createBasePostToolUseData();
		message.toolName = object.toolName ?? "";
		message.parameters = (
			globalThis.Object.entries(object.parameters ?? {}) as [string, string][]
		).reduce(
			(acc: { [key: string]: string }, [key, value]: [string, string]) => {
				if (value !== undefined) {
					acc[key] = globalThis.String(value);
				}
				return acc;
			},
			{},
		);
		message.result = object.result ?? "";
		message.success = object.success ?? false;
		message.executionTimeMs = object.executionTimeMs ?? 0;
		return message;
	},
};

function createBasePostToolUseData_ParametersEntry(): PostToolUseData_ParametersEntry {
	return { key: "", value: "" };
}

export const PostToolUseData_ParametersEntry: MessageFns<PostToolUseData_ParametersEntry> =
	{
		encode(
			message: PostToolUseData_ParametersEntry,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.key !== "") {
				writer.uint32(10).string(message.key);
			}
			if (message.value !== "") {
				writer.uint32(18).string(message.value);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): PostToolUseData_ParametersEntry {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBasePostToolUseData_ParametersEntry();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.key = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 18) {
							break;
						}

						message.value = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): PostToolUseData_ParametersEntry {
			return {
				key: isSet(object.key) ? globalThis.String(object.key) : "",
				value: isSet(object.value) ? globalThis.String(object.value) : "",
			};
		},

		toJSON(message: PostToolUseData_ParametersEntry): unknown {
			const obj: any = {};
			if (message.key !== "") {
				obj.key = message.key;
			}
			if (message.value !== "") {
				obj.value = message.value;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<PostToolUseData_ParametersEntry>, I>>(
			base?: I,
		): PostToolUseData_ParametersEntry {
			return PostToolUseData_ParametersEntry.fromPartial(base ?? ({} as any));
		},
		fromPartial<
			I extends Exact<DeepPartial<PostToolUseData_ParametersEntry>, I>,
		>(object: I): PostToolUseData_ParametersEntry {
			const message = createBasePostToolUseData_ParametersEntry();
			message.key = object.key ?? "";
			message.value = object.value ?? "";
			return message;
		},
	};

function createBaseUserPromptSubmitData(): UserPromptSubmitData {
	return { prompt: "", attachments: [] };
}

export const UserPromptSubmitData: MessageFns<UserPromptSubmitData> = {
	encode(
		message: UserPromptSubmitData,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.prompt !== "") {
			writer.uint32(10).string(message.prompt);
		}
		for (const v of message.attachments) {
			writer.uint32(18).string(v!);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): UserPromptSubmitData {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseUserPromptSubmitData();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.prompt = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.attachments.push(reader.string());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): UserPromptSubmitData {
		return {
			prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
			attachments: globalThis.Array.isArray(object?.attachments)
				? object.attachments.map((e: any) => globalThis.String(e))
				: [],
		};
	},

	toJSON(message: UserPromptSubmitData): unknown {
		const obj: any = {};
		if (message.prompt !== "") {
			obj.prompt = message.prompt;
		}
		if (message.attachments?.length) {
			obj.attachments = message.attachments;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<UserPromptSubmitData>, I>>(
		base?: I,
	): UserPromptSubmitData {
		return UserPromptSubmitData.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<UserPromptSubmitData>, I>>(
		object: I,
	): UserPromptSubmitData {
		const message = createBaseUserPromptSubmitData();
		message.prompt = object.prompt ?? "";
		message.attachments = object.attachments?.map((e) => e) || [];
		return message;
	},
};

function createBaseTaskStartData(): TaskStartData {
	return { taskMetadata: {} };
}

export const TaskStartData: MessageFns<TaskStartData> = {
	encode(
		message: TaskStartData,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		globalThis.Object.entries(message.taskMetadata).forEach(
			([key, value]: [string, string]) => {
				TaskStartData_TaskMetadataEntry.encode(
					{ key: key as any, value },
					writer.uint32(10).fork(),
				).join();
			},
		);
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): TaskStartData {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseTaskStartData();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					const entry1 = TaskStartData_TaskMetadataEntry.decode(
						reader,
						reader.uint32(),
					);
					if (entry1.value !== undefined) {
						message.taskMetadata[entry1.key] = entry1.value;
					}
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): TaskStartData {
		return {
			taskMetadata: isObject(object.taskMetadata)
				? (
						globalThis.Object.entries(object.taskMetadata) as [string, any][]
					).reduce(
						(acc: { [key: string]: string }, [key, value]: [string, any]) => {
							acc[key] = globalThis.String(value);
							return acc;
						},
						{},
					)
				: isObject(object.task_metadata)
					? (
							globalThis.Object.entries(object.task_metadata) as [string, any][]
						).reduce(
							(acc: { [key: string]: string }, [key, value]: [string, any]) => {
								acc[key] = globalThis.String(value);
								return acc;
							},
							{},
						)
					: {},
		};
	},

	toJSON(message: TaskStartData): unknown {
		const obj: any = {};
		if (message.taskMetadata) {
			const entries = globalThis.Object.entries(message.taskMetadata) as [
				string,
				string,
			][];
			if (entries.length > 0) {
				obj.taskMetadata = {};
				entries.forEach(([k, v]) => {
					obj.taskMetadata[k] = v;
				});
			}
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<TaskStartData>, I>>(
		base?: I,
	): TaskStartData {
		return TaskStartData.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<TaskStartData>, I>>(
		object: I,
	): TaskStartData {
		const message = createBaseTaskStartData();
		message.taskMetadata = (
			globalThis.Object.entries(object.taskMetadata ?? {}) as [string, string][]
		).reduce(
			(acc: { [key: string]: string }, [key, value]: [string, string]) => {
				if (value !== undefined) {
					acc[key] = globalThis.String(value);
				}
				return acc;
			},
			{},
		);
		return message;
	},
};

function createBaseTaskStartData_TaskMetadataEntry(): TaskStartData_TaskMetadataEntry {
	return { key: "", value: "" };
}

export const TaskStartData_TaskMetadataEntry: MessageFns<TaskStartData_TaskMetadataEntry> =
	{
		encode(
			message: TaskStartData_TaskMetadataEntry,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.key !== "") {
				writer.uint32(10).string(message.key);
			}
			if (message.value !== "") {
				writer.uint32(18).string(message.value);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): TaskStartData_TaskMetadataEntry {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseTaskStartData_TaskMetadataEntry();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.key = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 18) {
							break;
						}

						message.value = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): TaskStartData_TaskMetadataEntry {
			return {
				key: isSet(object.key) ? globalThis.String(object.key) : "",
				value: isSet(object.value) ? globalThis.String(object.value) : "",
			};
		},

		toJSON(message: TaskStartData_TaskMetadataEntry): unknown {
			const obj: any = {};
			if (message.key !== "") {
				obj.key = message.key;
			}
			if (message.value !== "") {
				obj.value = message.value;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<TaskStartData_TaskMetadataEntry>, I>>(
			base?: I,
		): TaskStartData_TaskMetadataEntry {
			return TaskStartData_TaskMetadataEntry.fromPartial(base ?? ({} as any));
		},
		fromPartial<
			I extends Exact<DeepPartial<TaskStartData_TaskMetadataEntry>, I>,
		>(object: I): TaskStartData_TaskMetadataEntry {
			const message = createBaseTaskStartData_TaskMetadataEntry();
			message.key = object.key ?? "";
			message.value = object.value ?? "";
			return message;
		},
	};

function createBaseTaskResumeData(): TaskResumeData {
	return { taskMetadata: {}, previousState: {} };
}

export const TaskResumeData: MessageFns<TaskResumeData> = {
	encode(
		message: TaskResumeData,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		globalThis.Object.entries(message.taskMetadata).forEach(
			([key, value]: [string, string]) => {
				TaskResumeData_TaskMetadataEntry.encode(
					{ key: key as any, value },
					writer.uint32(10).fork(),
				).join();
			},
		);
		globalThis.Object.entries(message.previousState).forEach(
			([key, value]: [string, string]) => {
				TaskResumeData_PreviousStateEntry.encode(
					{ key: key as any, value },
					writer.uint32(18).fork(),
				).join();
			},
		);
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): TaskResumeData {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseTaskResumeData();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					const entry1 = TaskResumeData_TaskMetadataEntry.decode(
						reader,
						reader.uint32(),
					);
					if (entry1.value !== undefined) {
						message.taskMetadata[entry1.key] = entry1.value;
					}
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					const entry2 = TaskResumeData_PreviousStateEntry.decode(
						reader,
						reader.uint32(),
					);
					if (entry2.value !== undefined) {
						message.previousState[entry2.key] = entry2.value;
					}
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): TaskResumeData {
		return {
			taskMetadata: isObject(object.taskMetadata)
				? (
						globalThis.Object.entries(object.taskMetadata) as [string, any][]
					).reduce(
						(acc: { [key: string]: string }, [key, value]: [string, any]) => {
							acc[key] = globalThis.String(value);
							return acc;
						},
						{},
					)
				: isObject(object.task_metadata)
					? (
							globalThis.Object.entries(object.task_metadata) as [string, any][]
						).reduce(
							(acc: { [key: string]: string }, [key, value]: [string, any]) => {
								acc[key] = globalThis.String(value);
								return acc;
							},
							{},
						)
					: {},
			previousState: isObject(object.previousState)
				? (
						globalThis.Object.entries(object.previousState) as [string, any][]
					).reduce(
						(acc: { [key: string]: string }, [key, value]: [string, any]) => {
							acc[key] = globalThis.String(value);
							return acc;
						},
						{},
					)
				: isObject(object.previous_state)
					? (
							globalThis.Object.entries(object.previous_state) as [
								string,
								any,
							][]
						).reduce(
							(acc: { [key: string]: string }, [key, value]: [string, any]) => {
								acc[key] = globalThis.String(value);
								return acc;
							},
							{},
						)
					: {},
		};
	},

	toJSON(message: TaskResumeData): unknown {
		const obj: any = {};
		if (message.taskMetadata) {
			const entries = globalThis.Object.entries(message.taskMetadata) as [
				string,
				string,
			][];
			if (entries.length > 0) {
				obj.taskMetadata = {};
				entries.forEach(([k, v]) => {
					obj.taskMetadata[k] = v;
				});
			}
		}
		if (message.previousState) {
			const entries = globalThis.Object.entries(message.previousState) as [
				string,
				string,
			][];
			if (entries.length > 0) {
				obj.previousState = {};
				entries.forEach(([k, v]) => {
					obj.previousState[k] = v;
				});
			}
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<TaskResumeData>, I>>(
		base?: I,
	): TaskResumeData {
		return TaskResumeData.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<TaskResumeData>, I>>(
		object: I,
	): TaskResumeData {
		const message = createBaseTaskResumeData();
		message.taskMetadata = (
			globalThis.Object.entries(object.taskMetadata ?? {}) as [string, string][]
		).reduce(
			(acc: { [key: string]: string }, [key, value]: [string, string]) => {
				if (value !== undefined) {
					acc[key] = globalThis.String(value);
				}
				return acc;
			},
			{},
		);
		message.previousState = (
			globalThis.Object.entries(object.previousState ?? {}) as [
				string,
				string,
			][]
		).reduce(
			(acc: { [key: string]: string }, [key, value]: [string, string]) => {
				if (value !== undefined) {
					acc[key] = globalThis.String(value);
				}
				return acc;
			},
			{},
		);
		return message;
	},
};

function createBaseTaskResumeData_TaskMetadataEntry(): TaskResumeData_TaskMetadataEntry {
	return { key: "", value: "" };
}

export const TaskResumeData_TaskMetadataEntry: MessageFns<TaskResumeData_TaskMetadataEntry> =
	{
		encode(
			message: TaskResumeData_TaskMetadataEntry,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.key !== "") {
				writer.uint32(10).string(message.key);
			}
			if (message.value !== "") {
				writer.uint32(18).string(message.value);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): TaskResumeData_TaskMetadataEntry {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseTaskResumeData_TaskMetadataEntry();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.key = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 18) {
							break;
						}

						message.value = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): TaskResumeData_TaskMetadataEntry {
			return {
				key: isSet(object.key) ? globalThis.String(object.key) : "",
				value: isSet(object.value) ? globalThis.String(object.value) : "",
			};
		},

		toJSON(message: TaskResumeData_TaskMetadataEntry): unknown {
			const obj: any = {};
			if (message.key !== "") {
				obj.key = message.key;
			}
			if (message.value !== "") {
				obj.value = message.value;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<TaskResumeData_TaskMetadataEntry>, I>>(
			base?: I,
		): TaskResumeData_TaskMetadataEntry {
			return TaskResumeData_TaskMetadataEntry.fromPartial(base ?? ({} as any));
		},
		fromPartial<
			I extends Exact<DeepPartial<TaskResumeData_TaskMetadataEntry>, I>,
		>(object: I): TaskResumeData_TaskMetadataEntry {
			const message = createBaseTaskResumeData_TaskMetadataEntry();
			message.key = object.key ?? "";
			message.value = object.value ?? "";
			return message;
		},
	};

function createBaseTaskResumeData_PreviousStateEntry(): TaskResumeData_PreviousStateEntry {
	return { key: "", value: "" };
}

export const TaskResumeData_PreviousStateEntry: MessageFns<TaskResumeData_PreviousStateEntry> =
	{
		encode(
			message: TaskResumeData_PreviousStateEntry,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.key !== "") {
				writer.uint32(10).string(message.key);
			}
			if (message.value !== "") {
				writer.uint32(18).string(message.value);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): TaskResumeData_PreviousStateEntry {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseTaskResumeData_PreviousStateEntry();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.key = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 18) {
							break;
						}

						message.value = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): TaskResumeData_PreviousStateEntry {
			return {
				key: isSet(object.key) ? globalThis.String(object.key) : "",
				value: isSet(object.value) ? globalThis.String(object.value) : "",
			};
		},

		toJSON(message: TaskResumeData_PreviousStateEntry): unknown {
			const obj: any = {};
			if (message.key !== "") {
				obj.key = message.key;
			}
			if (message.value !== "") {
				obj.value = message.value;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<TaskResumeData_PreviousStateEntry>, I>>(
			base?: I,
		): TaskResumeData_PreviousStateEntry {
			return TaskResumeData_PreviousStateEntry.fromPartial(base ?? ({} as any));
		},
		fromPartial<
			I extends Exact<DeepPartial<TaskResumeData_PreviousStateEntry>, I>,
		>(object: I): TaskResumeData_PreviousStateEntry {
			const message = createBaseTaskResumeData_PreviousStateEntry();
			message.key = object.key ?? "";
			message.value = object.value ?? "";
			return message;
		},
	};

function createBaseTaskCancelData(): TaskCancelData {
	return { taskMetadata: {} };
}

export const TaskCancelData: MessageFns<TaskCancelData> = {
	encode(
		message: TaskCancelData,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		globalThis.Object.entries(message.taskMetadata).forEach(
			([key, value]: [string, string]) => {
				TaskCancelData_TaskMetadataEntry.encode(
					{ key: key as any, value },
					writer.uint32(10).fork(),
				).join();
			},
		);
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): TaskCancelData {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseTaskCancelData();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					const entry1 = TaskCancelData_TaskMetadataEntry.decode(
						reader,
						reader.uint32(),
					);
					if (entry1.value !== undefined) {
						message.taskMetadata[entry1.key] = entry1.value;
					}
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): TaskCancelData {
		return {
			taskMetadata: isObject(object.taskMetadata)
				? (
						globalThis.Object.entries(object.taskMetadata) as [string, any][]
					).reduce(
						(acc: { [key: string]: string }, [key, value]: [string, any]) => {
							acc[key] = globalThis.String(value);
							return acc;
						},
						{},
					)
				: isObject(object.task_metadata)
					? (
							globalThis.Object.entries(object.task_metadata) as [string, any][]
						).reduce(
							(acc: { [key: string]: string }, [key, value]: [string, any]) => {
								acc[key] = globalThis.String(value);
								return acc;
							},
							{},
						)
					: {},
		};
	},

	toJSON(message: TaskCancelData): unknown {
		const obj: any = {};
		if (message.taskMetadata) {
			const entries = globalThis.Object.entries(message.taskMetadata) as [
				string,
				string,
			][];
			if (entries.length > 0) {
				obj.taskMetadata = {};
				entries.forEach(([k, v]) => {
					obj.taskMetadata[k] = v;
				});
			}
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<TaskCancelData>, I>>(
		base?: I,
	): TaskCancelData {
		return TaskCancelData.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<TaskCancelData>, I>>(
		object: I,
	): TaskCancelData {
		const message = createBaseTaskCancelData();
		message.taskMetadata = (
			globalThis.Object.entries(object.taskMetadata ?? {}) as [string, string][]
		).reduce(
			(acc: { [key: string]: string }, [key, value]: [string, string]) => {
				if (value !== undefined) {
					acc[key] = globalThis.String(value);
				}
				return acc;
			},
			{},
		);
		return message;
	},
};

function createBaseTaskCancelData_TaskMetadataEntry(): TaskCancelData_TaskMetadataEntry {
	return { key: "", value: "" };
}

export const TaskCancelData_TaskMetadataEntry: MessageFns<TaskCancelData_TaskMetadataEntry> =
	{
		encode(
			message: TaskCancelData_TaskMetadataEntry,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.key !== "") {
				writer.uint32(10).string(message.key);
			}
			if (message.value !== "") {
				writer.uint32(18).string(message.value);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): TaskCancelData_TaskMetadataEntry {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseTaskCancelData_TaskMetadataEntry();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.key = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 18) {
							break;
						}

						message.value = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): TaskCancelData_TaskMetadataEntry {
			return {
				key: isSet(object.key) ? globalThis.String(object.key) : "",
				value: isSet(object.value) ? globalThis.String(object.value) : "",
			};
		},

		toJSON(message: TaskCancelData_TaskMetadataEntry): unknown {
			const obj: any = {};
			if (message.key !== "") {
				obj.key = message.key;
			}
			if (message.value !== "") {
				obj.value = message.value;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<TaskCancelData_TaskMetadataEntry>, I>>(
			base?: I,
		): TaskCancelData_TaskMetadataEntry {
			return TaskCancelData_TaskMetadataEntry.fromPartial(base ?? ({} as any));
		},
		fromPartial<
			I extends Exact<DeepPartial<TaskCancelData_TaskMetadataEntry>, I>,
		>(object: I): TaskCancelData_TaskMetadataEntry {
			const message = createBaseTaskCancelData_TaskMetadataEntry();
			message.key = object.key ?? "";
			message.value = object.value ?? "";
			return message;
		},
	};

function createBaseTaskCompleteData(): TaskCompleteData {
	return { taskMetadata: {} };
}

export const TaskCompleteData: MessageFns<TaskCompleteData> = {
	encode(
		message: TaskCompleteData,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		globalThis.Object.entries(message.taskMetadata).forEach(
			([key, value]: [string, string]) => {
				TaskCompleteData_TaskMetadataEntry.encode(
					{ key: key as any, value },
					writer.uint32(10).fork(),
				).join();
			},
		);
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): TaskCompleteData {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseTaskCompleteData();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					const entry1 = TaskCompleteData_TaskMetadataEntry.decode(
						reader,
						reader.uint32(),
					);
					if (entry1.value !== undefined) {
						message.taskMetadata[entry1.key] = entry1.value;
					}
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): TaskCompleteData {
		return {
			taskMetadata: isObject(object.taskMetadata)
				? (
						globalThis.Object.entries(object.taskMetadata) as [string, any][]
					).reduce(
						(acc: { [key: string]: string }, [key, value]: [string, any]) => {
							acc[key] = globalThis.String(value);
							return acc;
						},
						{},
					)
				: isObject(object.task_metadata)
					? (
							globalThis.Object.entries(object.task_metadata) as [string, any][]
						).reduce(
							(acc: { [key: string]: string }, [key, value]: [string, any]) => {
								acc[key] = globalThis.String(value);
								return acc;
							},
							{},
						)
					: {},
		};
	},

	toJSON(message: TaskCompleteData): unknown {
		const obj: any = {};
		if (message.taskMetadata) {
			const entries = globalThis.Object.entries(message.taskMetadata) as [
				string,
				string,
			][];
			if (entries.length > 0) {
				obj.taskMetadata = {};
				entries.forEach(([k, v]) => {
					obj.taskMetadata[k] = v;
				});
			}
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<TaskCompleteData>, I>>(
		base?: I,
	): TaskCompleteData {
		return TaskCompleteData.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<TaskCompleteData>, I>>(
		object: I,
	): TaskCompleteData {
		const message = createBaseTaskCompleteData();
		message.taskMetadata = (
			globalThis.Object.entries(object.taskMetadata ?? {}) as [string, string][]
		).reduce(
			(acc: { [key: string]: string }, [key, value]: [string, string]) => {
				if (value !== undefined) {
					acc[key] = globalThis.String(value);
				}
				return acc;
			},
			{},
		);
		return message;
	},
};

function createBaseTaskCompleteData_TaskMetadataEntry(): TaskCompleteData_TaskMetadataEntry {
	return { key: "", value: "" };
}

export const TaskCompleteData_TaskMetadataEntry: MessageFns<TaskCompleteData_TaskMetadataEntry> =
	{
		encode(
			message: TaskCompleteData_TaskMetadataEntry,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.key !== "") {
				writer.uint32(10).string(message.key);
			}
			if (message.value !== "") {
				writer.uint32(18).string(message.value);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): TaskCompleteData_TaskMetadataEntry {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseTaskCompleteData_TaskMetadataEntry();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.key = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 18) {
							break;
						}

						message.value = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): TaskCompleteData_TaskMetadataEntry {
			return {
				key: isSet(object.key) ? globalThis.String(object.key) : "",
				value: isSet(object.value) ? globalThis.String(object.value) : "",
			};
		},

		toJSON(message: TaskCompleteData_TaskMetadataEntry): unknown {
			const obj: any = {};
			if (message.key !== "") {
				obj.key = message.key;
			}
			if (message.value !== "") {
				obj.value = message.value;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<TaskCompleteData_TaskMetadataEntry>, I>>(
			base?: I,
		): TaskCompleteData_TaskMetadataEntry {
			return TaskCompleteData_TaskMetadataEntry.fromPartial(
				base ?? ({} as any),
			);
		},
		fromPartial<
			I extends Exact<DeepPartial<TaskCompleteData_TaskMetadataEntry>, I>,
		>(object: I): TaskCompleteData_TaskMetadataEntry {
			const message = createBaseTaskCompleteData_TaskMetadataEntry();
			message.key = object.key ?? "";
			message.value = object.value ?? "";
			return message;
		},
	};

function createBasePreCompactData(): PreCompactData {
	return {
		taskId: "",
		ulid: "",
		contextSize: 0,
		compactionStrategy: "",
		previousApiReqIndex: 0,
		tokensIn: 0,
		tokensOut: 0,
		tokensInCache: 0,
		tokensOutCache: 0,
		deletedRangeStart: 0,
		deletedRangeEnd: 0,
		contextJsonPath: "",
		contextRawPath: "",
	};
}

export const PreCompactData: MessageFns<PreCompactData> = {
	encode(
		message: PreCompactData,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.taskId !== "") {
			writer.uint32(10).string(message.taskId);
		}
		if (message.ulid !== "") {
			writer.uint32(18).string(message.ulid);
		}
		if (message.contextSize !== 0) {
			writer.uint32(24).int64(message.contextSize);
		}
		if (message.compactionStrategy !== "") {
			writer.uint32(34).string(message.compactionStrategy);
		}
		if (message.previousApiReqIndex !== 0) {
			writer.uint32(40).int64(message.previousApiReqIndex);
		}
		if (message.tokensIn !== 0) {
			writer.uint32(48).int64(message.tokensIn);
		}
		if (message.tokensOut !== 0) {
			writer.uint32(56).int64(message.tokensOut);
		}
		if (message.tokensInCache !== 0) {
			writer.uint32(64).int64(message.tokensInCache);
		}
		if (message.tokensOutCache !== 0) {
			writer.uint32(72).int64(message.tokensOutCache);
		}
		if (message.deletedRangeStart !== 0) {
			writer.uint32(80).int32(message.deletedRangeStart);
		}
		if (message.deletedRangeEnd !== 0) {
			writer.uint32(88).int32(message.deletedRangeEnd);
		}
		if (message.contextJsonPath !== "") {
			writer.uint32(98).string(message.contextJsonPath);
		}
		if (message.contextRawPath !== "") {
			writer.uint32(106).string(message.contextRawPath);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): PreCompactData {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBasePreCompactData();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.taskId = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.ulid = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.contextSize = longToNumber(reader.int64());
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.compactionStrategy = reader.string();
					continue;
				}
				case 5: {
					if (tag !== 40) {
						break;
					}

					message.previousApiReqIndex = longToNumber(reader.int64());
					continue;
				}
				case 6: {
					if (tag !== 48) {
						break;
					}

					message.tokensIn = longToNumber(reader.int64());
					continue;
				}
				case 7: {
					if (tag !== 56) {
						break;
					}

					message.tokensOut = longToNumber(reader.int64());
					continue;
				}
				case 8: {
					if (tag !== 64) {
						break;
					}

					message.tokensInCache = longToNumber(reader.int64());
					continue;
				}
				case 9: {
					if (tag !== 72) {
						break;
					}

					message.tokensOutCache = longToNumber(reader.int64());
					continue;
				}
				case 10: {
					if (tag !== 80) {
						break;
					}

					message.deletedRangeStart = reader.int32();
					continue;
				}
				case 11: {
					if (tag !== 88) {
						break;
					}

					message.deletedRangeEnd = reader.int32();
					continue;
				}
				case 12: {
					if (tag !== 98) {
						break;
					}

					message.contextJsonPath = reader.string();
					continue;
				}
				case 13: {
					if (tag !== 106) {
						break;
					}

					message.contextRawPath = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): PreCompactData {
		return {
			taskId: isSet(object.taskId)
				? globalThis.String(object.taskId)
				: isSet(object.task_id)
					? globalThis.String(object.task_id)
					: "",
			ulid: isSet(object.ulid) ? globalThis.String(object.ulid) : "",
			contextSize: isSet(object.contextSize)
				? globalThis.Number(object.contextSize)
				: isSet(object.context_size)
					? globalThis.Number(object.context_size)
					: 0,
			compactionStrategy: isSet(object.compactionStrategy)
				? globalThis.String(object.compactionStrategy)
				: isSet(object.compaction_strategy)
					? globalThis.String(object.compaction_strategy)
					: "",
			previousApiReqIndex: isSet(object.previousApiReqIndex)
				? globalThis.Number(object.previousApiReqIndex)
				: isSet(object.previous_api_req_index)
					? globalThis.Number(object.previous_api_req_index)
					: 0,
			tokensIn: isSet(object.tokensIn)
				? globalThis.Number(object.tokensIn)
				: isSet(object.tokens_in)
					? globalThis.Number(object.tokens_in)
					: 0,
			tokensOut: isSet(object.tokensOut)
				? globalThis.Number(object.tokensOut)
				: isSet(object.tokens_out)
					? globalThis.Number(object.tokens_out)
					: 0,
			tokensInCache: isSet(object.tokensInCache)
				? globalThis.Number(object.tokensInCache)
				: isSet(object.tokens_in_cache)
					? globalThis.Number(object.tokens_in_cache)
					: 0,
			tokensOutCache: isSet(object.tokensOutCache)
				? globalThis.Number(object.tokensOutCache)
				: isSet(object.tokens_out_cache)
					? globalThis.Number(object.tokens_out_cache)
					: 0,
			deletedRangeStart: isSet(object.deletedRangeStart)
				? globalThis.Number(object.deletedRangeStart)
				: isSet(object.deleted_range_start)
					? globalThis.Number(object.deleted_range_start)
					: 0,
			deletedRangeEnd: isSet(object.deletedRangeEnd)
				? globalThis.Number(object.deletedRangeEnd)
				: isSet(object.deleted_range_end)
					? globalThis.Number(object.deleted_range_end)
					: 0,
			contextJsonPath: isSet(object.contextJsonPath)
				? globalThis.String(object.contextJsonPath)
				: isSet(object.context_json_path)
					? globalThis.String(object.context_json_path)
					: "",
			contextRawPath: isSet(object.contextRawPath)
				? globalThis.String(object.contextRawPath)
				: isSet(object.context_raw_path)
					? globalThis.String(object.context_raw_path)
					: "",
		};
	},

	toJSON(message: PreCompactData): unknown {
		const obj: any = {};
		if (message.taskId !== "") {
			obj.taskId = message.taskId;
		}
		if (message.ulid !== "") {
			obj.ulid = message.ulid;
		}
		if (message.contextSize !== 0) {
			obj.contextSize = Math.round(message.contextSize);
		}
		if (message.compactionStrategy !== "") {
			obj.compactionStrategy = message.compactionStrategy;
		}
		if (message.previousApiReqIndex !== 0) {
			obj.previousApiReqIndex = Math.round(message.previousApiReqIndex);
		}
		if (message.tokensIn !== 0) {
			obj.tokensIn = Math.round(message.tokensIn);
		}
		if (message.tokensOut !== 0) {
			obj.tokensOut = Math.round(message.tokensOut);
		}
		if (message.tokensInCache !== 0) {
			obj.tokensInCache = Math.round(message.tokensInCache);
		}
		if (message.tokensOutCache !== 0) {
			obj.tokensOutCache = Math.round(message.tokensOutCache);
		}
		if (message.deletedRangeStart !== 0) {
			obj.deletedRangeStart = Math.round(message.deletedRangeStart);
		}
		if (message.deletedRangeEnd !== 0) {
			obj.deletedRangeEnd = Math.round(message.deletedRangeEnd);
		}
		if (message.contextJsonPath !== "") {
			obj.contextJsonPath = message.contextJsonPath;
		}
		if (message.contextRawPath !== "") {
			obj.contextRawPath = message.contextRawPath;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<PreCompactData>, I>>(
		base?: I,
	): PreCompactData {
		return PreCompactData.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<PreCompactData>, I>>(
		object: I,
	): PreCompactData {
		const message = createBasePreCompactData();
		message.taskId = object.taskId ?? "";
		message.ulid = object.ulid ?? "";
		message.contextSize = object.contextSize ?? 0;
		message.compactionStrategy = object.compactionStrategy ?? "";
		message.previousApiReqIndex = object.previousApiReqIndex ?? 0;
		message.tokensIn = object.tokensIn ?? 0;
		message.tokensOut = object.tokensOut ?? 0;
		message.tokensInCache = object.tokensInCache ?? 0;
		message.tokensOutCache = object.tokensOutCache ?? 0;
		message.deletedRangeStart = object.deletedRangeStart ?? 0;
		message.deletedRangeEnd = object.deletedRangeEnd ?? 0;
		message.contextJsonPath = object.contextJsonPath ?? "";
		message.contextRawPath = object.contextRawPath ?? "";
		return message;
	},
};

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & {
			[K in Exclude<keyof I, KeysOfUnion<P>>]: never;
		};

function longToNumber(int64: { toString(): string }): number {
	const num = globalThis.Number(int64.toString());
	if (num > globalThis.Number.MAX_SAFE_INTEGER) {
		throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
	}
	if (num < globalThis.Number.MIN_SAFE_INTEGER) {
		throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
	}
	return num;
}

function isObject(value: any): boolean {
	return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

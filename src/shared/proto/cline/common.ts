// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: cline/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export enum DiagnosticSeverity {
	DIAGNOSTIC_ERROR = 0,
	DIAGNOSTIC_WARNING = 1,
	DIAGNOSTIC_INFORMATION = 2,
	DIAGNOSTIC_HINT = 3,
	UNRECOGNIZED = -1,
}

export function diagnosticSeverityFromJSON(object: any): DiagnosticSeverity {
	switch (object) {
		case 0:
		case "DIAGNOSTIC_ERROR":
			return DiagnosticSeverity.DIAGNOSTIC_ERROR;
		case 1:
		case "DIAGNOSTIC_WARNING":
			return DiagnosticSeverity.DIAGNOSTIC_WARNING;
		case 2:
		case "DIAGNOSTIC_INFORMATION":
			return DiagnosticSeverity.DIAGNOSTIC_INFORMATION;
		case 3:
		case "DIAGNOSTIC_HINT":
			return DiagnosticSeverity.DIAGNOSTIC_HINT;
		case -1:
		case "UNRECOGNIZED":
		default:
			return DiagnosticSeverity.UNRECOGNIZED;
	}
}

export function diagnosticSeverityToJSON(object: DiagnosticSeverity): string {
	switch (object) {
		case DiagnosticSeverity.DIAGNOSTIC_ERROR:
			return "DIAGNOSTIC_ERROR";
		case DiagnosticSeverity.DIAGNOSTIC_WARNING:
			return "DIAGNOSTIC_WARNING";
		case DiagnosticSeverity.DIAGNOSTIC_INFORMATION:
			return "DIAGNOSTIC_INFORMATION";
		case DiagnosticSeverity.DIAGNOSTIC_HINT:
			return "DIAGNOSTIC_HINT";
		case DiagnosticSeverity.UNRECOGNIZED:
		default:
			return "UNRECOGNIZED";
	}
}

export interface Metadata {}

export interface EmptyRequest {}

export interface Empty {}

export interface StringRequest {
	value: string;
}

export interface StringArrayRequest {
	value: string[];
}

export interface String {
	value: string;
}

export interface Int64Request {
	value: number;
}

export interface Int64 {
	value: number;
}

export interface BytesRequest {
	value: Uint8Array;
}

export interface Bytes {
	value: Uint8Array;
}

export interface BooleanRequest {
	value: boolean;
}

export interface Boolean {
	value: boolean;
}

/** the same as Boolean, but avoiding name conflicts */
export interface BooleanResponse {
	value: boolean;
}

export interface StringArray {
	values: string[];
}

export interface StringArrays {
	values1: string[];
	values2: string[];
}

export interface KeyValuePair {
	key: string;
	value: string;
}

export interface FileDiagnostics {
	filePath: string;
	diagnostics: Diagnostic[];
}

export interface Diagnostic {
	message: string;
	range: DiagnosticRange | undefined;
	severity: DiagnosticSeverity;
	source?: string | undefined;
}

export interface DiagnosticRange {
	start: DiagnosticPosition | undefined;
	end: DiagnosticPosition | undefined;
}

export interface DiagnosticPosition {
	line: number;
	character: number;
}

function createBaseMetadata(): Metadata {
	return {};
}

export const Metadata: MessageFns<Metadata> = {
	encode(_: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseMetadata();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(_: any): Metadata {
		return {};
	},

	toJSON(_: Metadata): unknown {
		const obj: any = {};
		return obj;
	},

	create<I extends Exact<DeepPartial<Metadata>, I>>(base?: I): Metadata {
		return Metadata.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Metadata>, I>>(_: I): Metadata {
		const message = createBaseMetadata();
		return message;
	},
};

function createBaseEmptyRequest(): EmptyRequest {
	return {};
}

export const EmptyRequest: MessageFns<EmptyRequest> = {
	encode(
		_: EmptyRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): EmptyRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseEmptyRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(_: any): EmptyRequest {
		return {};
	},

	toJSON(_: EmptyRequest): unknown {
		const obj: any = {};
		return obj;
	},

	create<I extends Exact<DeepPartial<EmptyRequest>, I>>(
		base?: I,
	): EmptyRequest {
		return EmptyRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<EmptyRequest>, I>>(
		_: I,
	): EmptyRequest {
		const message = createBaseEmptyRequest();
		return message;
	},
};

function createBaseEmpty(): Empty {
	return {};
}

export const Empty: MessageFns<Empty> = {
	encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Empty {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseEmpty();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(_: any): Empty {
		return {};
	},

	toJSON(_: Empty): unknown {
		const obj: any = {};
		return obj;
	},

	create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
		return Empty.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
		const message = createBaseEmpty();
		return message;
	},
};

function createBaseStringRequest(): StringRequest {
	return { value: "" };
}

export const StringRequest: MessageFns<StringRequest> = {
	encode(
		message: StringRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.value !== "") {
			writer.uint32(18).string(message.value);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): StringRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseStringRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.value = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): StringRequest {
		return {
			value: isSet(object.value) ? globalThis.String(object.value) : "",
		};
	},

	toJSON(message: StringRequest): unknown {
		const obj: any = {};
		if (message.value !== "") {
			obj.value = message.value;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<StringRequest>, I>>(
		base?: I,
	): StringRequest {
		return StringRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<StringRequest>, I>>(
		object: I,
	): StringRequest {
		const message = createBaseStringRequest();
		message.value = object.value ?? "";
		return message;
	},
};

function createBaseStringArrayRequest(): StringArrayRequest {
	return { value: [] };
}

export const StringArrayRequest: MessageFns<StringArrayRequest> = {
	encode(
		message: StringArrayRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		for (const v of message.value) {
			writer.uint32(18).string(v!);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): StringArrayRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseStringArrayRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.value.push(reader.string());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): StringArrayRequest {
		return {
			value: globalThis.Array.isArray(object?.value)
				? object.value.map((e: any) => globalThis.String(e))
				: [],
		};
	},

	toJSON(message: StringArrayRequest): unknown {
		const obj: any = {};
		if (message.value?.length) {
			obj.value = message.value;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<StringArrayRequest>, I>>(
		base?: I,
	): StringArrayRequest {
		return StringArrayRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<StringArrayRequest>, I>>(
		object: I,
	): StringArrayRequest {
		const message = createBaseStringArrayRequest();
		message.value = object.value?.map((e) => e) || [];
		return message;
	},
};

function createBaseString(): String {
	return { value: "" };
}

export const String: MessageFns<String> = {
	encode(
		message: String,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.value !== "") {
			writer.uint32(10).string(message.value);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): String {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseString();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.value = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): String {
		return {
			value: isSet(object.value) ? globalThis.String(object.value) : "",
		};
	},

	toJSON(message: String): unknown {
		const obj: any = {};
		if (message.value !== "") {
			obj.value = message.value;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<String>, I>>(base?: I): String {
		return String.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<String>, I>>(object: I): String {
		const message = createBaseString();
		message.value = object.value ?? "";
		return message;
	},
};

function createBaseInt64Request(): Int64Request {
	return { value: 0 };
}

export const Int64Request: MessageFns<Int64Request> = {
	encode(
		message: Int64Request,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.value !== 0) {
			writer.uint32(16).int64(message.value);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Int64Request {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseInt64Request();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 2: {
					if (tag !== 16) {
						break;
					}

					message.value = longToNumber(reader.int64());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Int64Request {
		return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
	},

	toJSON(message: Int64Request): unknown {
		const obj: any = {};
		if (message.value !== 0) {
			obj.value = Math.round(message.value);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Int64Request>, I>>(
		base?: I,
	): Int64Request {
		return Int64Request.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Int64Request>, I>>(
		object: I,
	): Int64Request {
		const message = createBaseInt64Request();
		message.value = object.value ?? 0;
		return message;
	},
};

function createBaseInt64(): Int64 {
	return { value: 0 };
}

export const Int64: MessageFns<Int64> = {
	encode(
		message: Int64,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.value !== 0) {
			writer.uint32(8).int64(message.value);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Int64 {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseInt64();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.value = longToNumber(reader.int64());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Int64 {
		return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
	},

	toJSON(message: Int64): unknown {
		const obj: any = {};
		if (message.value !== 0) {
			obj.value = Math.round(message.value);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Int64>, I>>(base?: I): Int64 {
		return Int64.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Int64>, I>>(object: I): Int64 {
		const message = createBaseInt64();
		message.value = object.value ?? 0;
		return message;
	},
};

function createBaseBytesRequest(): BytesRequest {
	return { value: new Uint8Array(0) };
}

export const BytesRequest: MessageFns<BytesRequest> = {
	encode(
		message: BytesRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.value.length !== 0) {
			writer.uint32(18).bytes(message.value);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): BytesRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseBytesRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.value = reader.bytes();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): BytesRequest {
		return {
			value: isSet(object.value)
				? bytesFromBase64(object.value)
				: new Uint8Array(0),
		};
	},

	toJSON(message: BytesRequest): unknown {
		const obj: any = {};
		if (message.value.length !== 0) {
			obj.value = base64FromBytes(message.value);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<BytesRequest>, I>>(
		base?: I,
	): BytesRequest {
		return BytesRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<BytesRequest>, I>>(
		object: I,
	): BytesRequest {
		const message = createBaseBytesRequest();
		message.value = object.value ?? new Uint8Array(0);
		return message;
	},
};

function createBaseBytes(): Bytes {
	return { value: new Uint8Array(0) };
}

export const Bytes: MessageFns<Bytes> = {
	encode(
		message: Bytes,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.value.length !== 0) {
			writer.uint32(10).bytes(message.value);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Bytes {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseBytes();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.value = reader.bytes();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Bytes {
		return {
			value: isSet(object.value)
				? bytesFromBase64(object.value)
				: new Uint8Array(0),
		};
	},

	toJSON(message: Bytes): unknown {
		const obj: any = {};
		if (message.value.length !== 0) {
			obj.value = base64FromBytes(message.value);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Bytes>, I>>(base?: I): Bytes {
		return Bytes.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Bytes>, I>>(object: I): Bytes {
		const message = createBaseBytes();
		message.value = object.value ?? new Uint8Array(0);
		return message;
	},
};

function createBaseBooleanRequest(): BooleanRequest {
	return { value: false };
}

export const BooleanRequest: MessageFns<BooleanRequest> = {
	encode(
		message: BooleanRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.value !== false) {
			writer.uint32(16).bool(message.value);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): BooleanRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseBooleanRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 2: {
					if (tag !== 16) {
						break;
					}

					message.value = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): BooleanRequest {
		return {
			value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
		};
	},

	toJSON(message: BooleanRequest): unknown {
		const obj: any = {};
		if (message.value !== false) {
			obj.value = message.value;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<BooleanRequest>, I>>(
		base?: I,
	): BooleanRequest {
		return BooleanRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<BooleanRequest>, I>>(
		object: I,
	): BooleanRequest {
		const message = createBaseBooleanRequest();
		message.value = object.value ?? false;
		return message;
	},
};

function createBaseBoolean(): Boolean {
	return { value: false };
}

export const Boolean: MessageFns<Boolean> = {
	encode(
		message: Boolean,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.value !== false) {
			writer.uint32(8).bool(message.value);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Boolean {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseBoolean();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.value = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Boolean {
		return {
			value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
		};
	},

	toJSON(message: Boolean): unknown {
		const obj: any = {};
		if (message.value !== false) {
			obj.value = message.value;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Boolean>, I>>(base?: I): Boolean {
		return Boolean.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Boolean>, I>>(object: I): Boolean {
		const message = createBaseBoolean();
		message.value = object.value ?? false;
		return message;
	},
};

function createBaseBooleanResponse(): BooleanResponse {
	return { value: false };
}

export const BooleanResponse: MessageFns<BooleanResponse> = {
	encode(
		message: BooleanResponse,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.value !== false) {
			writer.uint32(8).bool(message.value);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): BooleanResponse {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseBooleanResponse();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.value = reader.bool();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): BooleanResponse {
		return {
			value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
		};
	},

	toJSON(message: BooleanResponse): unknown {
		const obj: any = {};
		if (message.value !== false) {
			obj.value = message.value;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<BooleanResponse>, I>>(
		base?: I,
	): BooleanResponse {
		return BooleanResponse.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<BooleanResponse>, I>>(
		object: I,
	): BooleanResponse {
		const message = createBaseBooleanResponse();
		message.value = object.value ?? false;
		return message;
	},
};

function createBaseStringArray(): StringArray {
	return { values: [] };
}

export const StringArray: MessageFns<StringArray> = {
	encode(
		message: StringArray,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		for (const v of message.values) {
			writer.uint32(10).string(v!);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): StringArray {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseStringArray();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.values.push(reader.string());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): StringArray {
		return {
			values: globalThis.Array.isArray(object?.values)
				? object.values.map((e: any) => globalThis.String(e))
				: [],
		};
	},

	toJSON(message: StringArray): unknown {
		const obj: any = {};
		if (message.values?.length) {
			obj.values = message.values;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<StringArray>, I>>(base?: I): StringArray {
		return StringArray.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<StringArray>, I>>(
		object: I,
	): StringArray {
		const message = createBaseStringArray();
		message.values = object.values?.map((e) => e) || [];
		return message;
	},
};

function createBaseStringArrays(): StringArrays {
	return { values1: [], values2: [] };
}

export const StringArrays: MessageFns<StringArrays> = {
	encode(
		message: StringArrays,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		for (const v of message.values1) {
			writer.uint32(10).string(v!);
		}
		for (const v of message.values2) {
			writer.uint32(18).string(v!);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): StringArrays {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseStringArrays();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.values1.push(reader.string());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.values2.push(reader.string());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): StringArrays {
		return {
			values1: globalThis.Array.isArray(object?.values1)
				? object.values1.map((e: any) => globalThis.String(e))
				: [],
			values2: globalThis.Array.isArray(object?.values2)
				? object.values2.map((e: any) => globalThis.String(e))
				: [],
		};
	},

	toJSON(message: StringArrays): unknown {
		const obj: any = {};
		if (message.values1?.length) {
			obj.values1 = message.values1;
		}
		if (message.values2?.length) {
			obj.values2 = message.values2;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<StringArrays>, I>>(
		base?: I,
	): StringArrays {
		return StringArrays.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<StringArrays>, I>>(
		object: I,
	): StringArrays {
		const message = createBaseStringArrays();
		message.values1 = object.values1?.map((e) => e) || [];
		message.values2 = object.values2?.map((e) => e) || [];
		return message;
	},
};

function createBaseKeyValuePair(): KeyValuePair {
	return { key: "", value: "" };
}

export const KeyValuePair: MessageFns<KeyValuePair> = {
	encode(
		message: KeyValuePair,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.key !== "") {
			writer.uint32(10).string(message.key);
		}
		if (message.value !== "") {
			writer.uint32(18).string(message.value);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): KeyValuePair {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseKeyValuePair();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.key = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.value = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): KeyValuePair {
		return {
			key: isSet(object.key) ? globalThis.String(object.key) : "",
			value: isSet(object.value) ? globalThis.String(object.value) : "",
		};
	},

	toJSON(message: KeyValuePair): unknown {
		const obj: any = {};
		if (message.key !== "") {
			obj.key = message.key;
		}
		if (message.value !== "") {
			obj.value = message.value;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<KeyValuePair>, I>>(
		base?: I,
	): KeyValuePair {
		return KeyValuePair.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<KeyValuePair>, I>>(
		object: I,
	): KeyValuePair {
		const message = createBaseKeyValuePair();
		message.key = object.key ?? "";
		message.value = object.value ?? "";
		return message;
	},
};

function createBaseFileDiagnostics(): FileDiagnostics {
	return { filePath: "", diagnostics: [] };
}

export const FileDiagnostics: MessageFns<FileDiagnostics> = {
	encode(
		message: FileDiagnostics,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.filePath !== "") {
			writer.uint32(10).string(message.filePath);
		}
		for (const v of message.diagnostics) {
			Diagnostic.encode(v!, writer.uint32(18).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): FileDiagnostics {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseFileDiagnostics();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.filePath = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.diagnostics.push(Diagnostic.decode(reader, reader.uint32()));
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): FileDiagnostics {
		return {
			filePath: isSet(object.filePath)
				? globalThis.String(object.filePath)
				: isSet(object.file_path)
					? globalThis.String(object.file_path)
					: "",
			diagnostics: globalThis.Array.isArray(object?.diagnostics)
				? object.diagnostics.map((e: any) => Diagnostic.fromJSON(e))
				: [],
		};
	},

	toJSON(message: FileDiagnostics): unknown {
		const obj: any = {};
		if (message.filePath !== "") {
			obj.filePath = message.filePath;
		}
		if (message.diagnostics?.length) {
			obj.diagnostics = message.diagnostics.map((e) => Diagnostic.toJSON(e));
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<FileDiagnostics>, I>>(
		base?: I,
	): FileDiagnostics {
		return FileDiagnostics.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<FileDiagnostics>, I>>(
		object: I,
	): FileDiagnostics {
		const message = createBaseFileDiagnostics();
		message.filePath = object.filePath ?? "";
		message.diagnostics =
			object.diagnostics?.map((e) => Diagnostic.fromPartial(e)) || [];
		return message;
	},
};

function createBaseDiagnostic(): Diagnostic {
	return { message: "", range: undefined, severity: 0, source: undefined };
}

export const Diagnostic: MessageFns<Diagnostic> = {
	encode(
		message: Diagnostic,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.message !== "") {
			writer.uint32(10).string(message.message);
		}
		if (message.range !== undefined) {
			DiagnosticRange.encode(message.range, writer.uint32(18).fork()).join();
		}
		if (message.severity !== 0) {
			writer.uint32(24).int32(message.severity);
		}
		if (message.source !== undefined) {
			writer.uint32(34).string(message.source);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): Diagnostic {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseDiagnostic();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.message = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.range = DiagnosticRange.decode(reader, reader.uint32());
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.severity = reader.int32() as any;
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.source = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): Diagnostic {
		return {
			message: isSet(object.message) ? globalThis.String(object.message) : "",
			range: isSet(object.range)
				? DiagnosticRange.fromJSON(object.range)
				: undefined,
			severity: isSet(object.severity)
				? diagnosticSeverityFromJSON(object.severity)
				: 0,
			source: isSet(object.source)
				? globalThis.String(object.source)
				: undefined,
		};
	},

	toJSON(message: Diagnostic): unknown {
		const obj: any = {};
		if (message.message !== "") {
			obj.message = message.message;
		}
		if (message.range !== undefined) {
			obj.range = DiagnosticRange.toJSON(message.range);
		}
		if (message.severity !== 0) {
			obj.severity = diagnosticSeverityToJSON(message.severity);
		}
		if (message.source !== undefined) {
			obj.source = message.source;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<Diagnostic>, I>>(base?: I): Diagnostic {
		return Diagnostic.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<Diagnostic>, I>>(
		object: I,
	): Diagnostic {
		const message = createBaseDiagnostic();
		message.message = object.message ?? "";
		message.range =
			object.range !== undefined && object.range !== null
				? DiagnosticRange.fromPartial(object.range)
				: undefined;
		message.severity = object.severity ?? 0;
		message.source = object.source ?? undefined;
		return message;
	},
};

function createBaseDiagnosticRange(): DiagnosticRange {
	return { start: undefined, end: undefined };
}

export const DiagnosticRange: MessageFns<DiagnosticRange> = {
	encode(
		message: DiagnosticRange,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.start !== undefined) {
			DiagnosticPosition.encode(message.start, writer.uint32(10).fork()).join();
		}
		if (message.end !== undefined) {
			DiagnosticPosition.encode(message.end, writer.uint32(18).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): DiagnosticRange {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseDiagnosticRange();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.start = DiagnosticPosition.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.end = DiagnosticPosition.decode(reader, reader.uint32());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): DiagnosticRange {
		return {
			start: isSet(object.start)
				? DiagnosticPosition.fromJSON(object.start)
				: undefined,
			end: isSet(object.end)
				? DiagnosticPosition.fromJSON(object.end)
				: undefined,
		};
	},

	toJSON(message: DiagnosticRange): unknown {
		const obj: any = {};
		if (message.start !== undefined) {
			obj.start = DiagnosticPosition.toJSON(message.start);
		}
		if (message.end !== undefined) {
			obj.end = DiagnosticPosition.toJSON(message.end);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<DiagnosticRange>, I>>(
		base?: I,
	): DiagnosticRange {
		return DiagnosticRange.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<DiagnosticRange>, I>>(
		object: I,
	): DiagnosticRange {
		const message = createBaseDiagnosticRange();
		message.start =
			object.start !== undefined && object.start !== null
				? DiagnosticPosition.fromPartial(object.start)
				: undefined;
		message.end =
			object.end !== undefined && object.end !== null
				? DiagnosticPosition.fromPartial(object.end)
				: undefined;
		return message;
	},
};

function createBaseDiagnosticPosition(): DiagnosticPosition {
	return { line: 0, character: 0 };
}

export const DiagnosticPosition: MessageFns<DiagnosticPosition> = {
	encode(
		message: DiagnosticPosition,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.line !== 0) {
			writer.uint32(8).int32(message.line);
		}
		if (message.character !== 0) {
			writer.uint32(16).int32(message.character);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): DiagnosticPosition {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseDiagnosticPosition();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.line = reader.int32();
					continue;
				}
				case 2: {
					if (tag !== 16) {
						break;
					}

					message.character = reader.int32();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): DiagnosticPosition {
		return {
			line: isSet(object.line) ? globalThis.Number(object.line) : 0,
			character: isSet(object.character)
				? globalThis.Number(object.character)
				: 0,
		};
	},

	toJSON(message: DiagnosticPosition): unknown {
		const obj: any = {};
		if (message.line !== 0) {
			obj.line = Math.round(message.line);
		}
		if (message.character !== 0) {
			obj.character = Math.round(message.character);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<DiagnosticPosition>, I>>(
		base?: I,
	): DiagnosticPosition {
		return DiagnosticPosition.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<DiagnosticPosition>, I>>(
		object: I,
	): DiagnosticPosition {
		const message = createBaseDiagnosticPosition();
		message.line = object.line ?? 0;
		message.character = object.character ?? 0;
		return message;
	},
};

function bytesFromBase64(b64: string): Uint8Array {
	if ((globalThis as any).Buffer) {
		return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
	} else {
		const bin = globalThis.atob(b64);
		const arr = new Uint8Array(bin.length);
		for (let i = 0; i < bin.length; ++i) {
			arr[i] = bin.charCodeAt(i);
		}
		return arr;
	}
}

function base64FromBytes(arr: Uint8Array): string {
	if ((globalThis as any).Buffer) {
		return globalThis.Buffer.from(arr).toString("base64");
	} else {
		const bin: string[] = [];
		arr.forEach((byte) => {
			bin.push(globalThis.String.fromCharCode(byte));
		});
		return globalThis.btoa(bin.join(""));
	}
}

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & {
			[K in Exclude<keyof I, KeysOfUnion<P>>]: never;
		};

function longToNumber(int64: { toString(): string }): number {
	const num = globalThis.Number(int64.toString());
	if (num > globalThis.Number.MAX_SAFE_INTEGER) {
		throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
	}
	if (num < globalThis.Number.MIN_SAFE_INTEGER) {
		throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
	}
	return num;
}

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}

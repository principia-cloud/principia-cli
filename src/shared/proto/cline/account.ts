// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.2
//   protoc               v3.19.1
// source: cline/account.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty, EmptyRequest, Metadata, String, StringRequest } from "./common";

export interface AuthStateChangedRequest {
	metadata: Metadata | undefined;
	user: UserInfo | undefined;
}

export interface AuthState {
	user?: UserInfo | undefined;
}

/** User's information */
export interface UserInfo {
	uid: string;
	displayName?: string | undefined;
	email?: string | undefined;
	photoUrl?: string | undefined;
	/** Cline app base URL */
	appBaseUrl?: string | undefined;
}

export interface UserOrganization {
	active: boolean;
	memberId: string;
	name: string;
	organizationId: string;
	/** ["admin", "member", "owner"] */
	roles: string[];
}

export interface UserOrganizationsResponse {
	organizations: UserOrganization[];
}

export interface UserOrganizationUpdateRequest {
	organizationId?: string | undefined;
}

export interface UserCreditsData {
	balance: UserCreditsBalance | undefined;
	usageTransactions: UsageTransaction[];
	paymentTransactions: PaymentTransaction[];
}

export interface GetOrganizationCreditsRequest {
	organizationId: string;
}

export interface OrganizationCreditsData {
	balance: UserCreditsBalance | undefined;
	organizationId: string;
	usageTransactions: OrganizationUsageTransaction[];
}

export interface UserCreditsBalance {
	currentBalance: number;
}

export interface UsageTransaction {
	aiInferenceProviderName: string;
	aiModelName: string;
	aiModelTypeName: string;
	completionTokens: number;
	costUsd: number;
	createdAt: string;
	creditsUsed: number;
	generationId: string;
	organizationId: string;
	promptTokens: number;
	totalTokens: number;
	userId: string;
	operation: string;
}

export interface PaymentTransaction {
	paidAt: string;
	creatorId: string;
	amountCents: number;
	credits: number;
}

export interface OrganizationUsageTransaction {
	aiInferenceProviderName: string;
	aiModelName: string;
	aiModelTypeName: string;
	completionTokens: number;
	costUsd: number;
	createdAt: string;
	creditsUsed: number;
	generationId: string;
	organizationId: string;
	promptTokens: number;
	totalTokens: number;
	userId: string;
	operation: string;
}

function createBaseAuthStateChangedRequest(): AuthStateChangedRequest {
	return { metadata: undefined, user: undefined };
}

export const AuthStateChangedRequest: MessageFns<AuthStateChangedRequest> = {
	encode(
		message: AuthStateChangedRequest,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.metadata !== undefined) {
			Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
		}
		if (message.user !== undefined) {
			UserInfo.encode(message.user, writer.uint32(18).fork()).join();
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): AuthStateChangedRequest {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseAuthStateChangedRequest();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.metadata = Metadata.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.user = UserInfo.decode(reader, reader.uint32());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): AuthStateChangedRequest {
		return {
			metadata: isSet(object.metadata)
				? Metadata.fromJSON(object.metadata)
				: undefined,
			user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
		};
	},

	toJSON(message: AuthStateChangedRequest): unknown {
		const obj: any = {};
		if (message.metadata !== undefined) {
			obj.metadata = Metadata.toJSON(message.metadata);
		}
		if (message.user !== undefined) {
			obj.user = UserInfo.toJSON(message.user);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<AuthStateChangedRequest>, I>>(
		base?: I,
	): AuthStateChangedRequest {
		return AuthStateChangedRequest.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<AuthStateChangedRequest>, I>>(
		object: I,
	): AuthStateChangedRequest {
		const message = createBaseAuthStateChangedRequest();
		message.metadata =
			object.metadata !== undefined && object.metadata !== null
				? Metadata.fromPartial(object.metadata)
				: undefined;
		message.user =
			object.user !== undefined && object.user !== null
				? UserInfo.fromPartial(object.user)
				: undefined;
		return message;
	},
};

function createBaseAuthState(): AuthState {
	return { user: undefined };
}

export const AuthState: MessageFns<AuthState> = {
	encode(
		message: AuthState,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.user !== undefined) {
			UserInfo.encode(message.user, writer.uint32(10).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): AuthState {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseAuthState();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.user = UserInfo.decode(reader, reader.uint32());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): AuthState {
		return {
			user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
		};
	},

	toJSON(message: AuthState): unknown {
		const obj: any = {};
		if (message.user !== undefined) {
			obj.user = UserInfo.toJSON(message.user);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<AuthState>, I>>(base?: I): AuthState {
		return AuthState.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<AuthState>, I>>(
		object: I,
	): AuthState {
		const message = createBaseAuthState();
		message.user =
			object.user !== undefined && object.user !== null
				? UserInfo.fromPartial(object.user)
				: undefined;
		return message;
	},
};

function createBaseUserInfo(): UserInfo {
	return {
		uid: "",
		displayName: undefined,
		email: undefined,
		photoUrl: undefined,
		appBaseUrl: undefined,
	};
}

export const UserInfo: MessageFns<UserInfo> = {
	encode(
		message: UserInfo,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.uid !== "") {
			writer.uint32(10).string(message.uid);
		}
		if (message.displayName !== undefined) {
			writer.uint32(18).string(message.displayName);
		}
		if (message.email !== undefined) {
			writer.uint32(26).string(message.email);
		}
		if (message.photoUrl !== undefined) {
			writer.uint32(34).string(message.photoUrl);
		}
		if (message.appBaseUrl !== undefined) {
			writer.uint32(42).string(message.appBaseUrl);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseUserInfo();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.uid = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.displayName = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.email = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.photoUrl = reader.string();
					continue;
				}
				case 5: {
					if (tag !== 42) {
						break;
					}

					message.appBaseUrl = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): UserInfo {
		return {
			uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
			displayName: isSet(object.displayName)
				? globalThis.String(object.displayName)
				: isSet(object.display_name)
					? globalThis.String(object.display_name)
					: undefined,
			email: isSet(object.email) ? globalThis.String(object.email) : undefined,
			photoUrl: isSet(object.photoUrl)
				? globalThis.String(object.photoUrl)
				: isSet(object.photo_url)
					? globalThis.String(object.photo_url)
					: undefined,
			appBaseUrl: isSet(object.appBaseUrl)
				? globalThis.String(object.appBaseUrl)
				: isSet(object.app_base_url)
					? globalThis.String(object.app_base_url)
					: undefined,
		};
	},

	toJSON(message: UserInfo): unknown {
		const obj: any = {};
		if (message.uid !== "") {
			obj.uid = message.uid;
		}
		if (message.displayName !== undefined) {
			obj.displayName = message.displayName;
		}
		if (message.email !== undefined) {
			obj.email = message.email;
		}
		if (message.photoUrl !== undefined) {
			obj.photoUrl = message.photoUrl;
		}
		if (message.appBaseUrl !== undefined) {
			obj.appBaseUrl = message.appBaseUrl;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<UserInfo>, I>>(base?: I): UserInfo {
		return UserInfo.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<UserInfo>, I>>(object: I): UserInfo {
		const message = createBaseUserInfo();
		message.uid = object.uid ?? "";
		message.displayName = object.displayName ?? undefined;
		message.email = object.email ?? undefined;
		message.photoUrl = object.photoUrl ?? undefined;
		message.appBaseUrl = object.appBaseUrl ?? undefined;
		return message;
	},
};

function createBaseUserOrganization(): UserOrganization {
	return {
		active: false,
		memberId: "",
		name: "",
		organizationId: "",
		roles: [],
	};
}

export const UserOrganization: MessageFns<UserOrganization> = {
	encode(
		message: UserOrganization,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.active !== false) {
			writer.uint32(8).bool(message.active);
		}
		if (message.memberId !== "") {
			writer.uint32(18).string(message.memberId);
		}
		if (message.name !== "") {
			writer.uint32(26).string(message.name);
		}
		if (message.organizationId !== "") {
			writer.uint32(34).string(message.organizationId);
		}
		for (const v of message.roles) {
			writer.uint32(42).string(v!);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): UserOrganization {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseUserOrganization();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 8) {
						break;
					}

					message.active = reader.bool();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.memberId = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.name = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 34) {
						break;
					}

					message.organizationId = reader.string();
					continue;
				}
				case 5: {
					if (tag !== 42) {
						break;
					}

					message.roles.push(reader.string());
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): UserOrganization {
		return {
			active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
			memberId: isSet(object.memberId)
				? globalThis.String(object.memberId)
				: isSet(object.member_id)
					? globalThis.String(object.member_id)
					: "",
			name: isSet(object.name) ? globalThis.String(object.name) : "",
			organizationId: isSet(object.organizationId)
				? globalThis.String(object.organizationId)
				: isSet(object.organization_id)
					? globalThis.String(object.organization_id)
					: "",
			roles: globalThis.Array.isArray(object?.roles)
				? object.roles.map((e: any) => globalThis.String(e))
				: [],
		};
	},

	toJSON(message: UserOrganization): unknown {
		const obj: any = {};
		if (message.active !== false) {
			obj.active = message.active;
		}
		if (message.memberId !== "") {
			obj.memberId = message.memberId;
		}
		if (message.name !== "") {
			obj.name = message.name;
		}
		if (message.organizationId !== "") {
			obj.organizationId = message.organizationId;
		}
		if (message.roles?.length) {
			obj.roles = message.roles;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<UserOrganization>, I>>(
		base?: I,
	): UserOrganization {
		return UserOrganization.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<UserOrganization>, I>>(
		object: I,
	): UserOrganization {
		const message = createBaseUserOrganization();
		message.active = object.active ?? false;
		message.memberId = object.memberId ?? "";
		message.name = object.name ?? "";
		message.organizationId = object.organizationId ?? "";
		message.roles = object.roles?.map((e) => e) || [];
		return message;
	},
};

function createBaseUserOrganizationsResponse(): UserOrganizationsResponse {
	return { organizations: [] };
}

export const UserOrganizationsResponse: MessageFns<UserOrganizationsResponse> =
	{
		encode(
			message: UserOrganizationsResponse,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			for (const v of message.organizations) {
				UserOrganization.encode(v!, writer.uint32(10).fork()).join();
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): UserOrganizationsResponse {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseUserOrganizationsResponse();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.organizations.push(
							UserOrganization.decode(reader, reader.uint32()),
						);
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): UserOrganizationsResponse {
			return {
				organizations: globalThis.Array.isArray(object?.organizations)
					? object.organizations.map((e: any) => UserOrganization.fromJSON(e))
					: [],
			};
		},

		toJSON(message: UserOrganizationsResponse): unknown {
			const obj: any = {};
			if (message.organizations?.length) {
				obj.organizations = message.organizations.map((e) =>
					UserOrganization.toJSON(e),
				);
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<UserOrganizationsResponse>, I>>(
			base?: I,
		): UserOrganizationsResponse {
			return UserOrganizationsResponse.fromPartial(base ?? ({} as any));
		},
		fromPartial<I extends Exact<DeepPartial<UserOrganizationsResponse>, I>>(
			object: I,
		): UserOrganizationsResponse {
			const message = createBaseUserOrganizationsResponse();
			message.organizations =
				object.organizations?.map((e) => UserOrganization.fromPartial(e)) || [];
			return message;
		},
	};

function createBaseUserOrganizationUpdateRequest(): UserOrganizationUpdateRequest {
	return { organizationId: undefined };
}

export const UserOrganizationUpdateRequest: MessageFns<UserOrganizationUpdateRequest> =
	{
		encode(
			message: UserOrganizationUpdateRequest,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.organizationId !== undefined) {
				writer.uint32(10).string(message.organizationId);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): UserOrganizationUpdateRequest {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseUserOrganizationUpdateRequest();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.organizationId = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): UserOrganizationUpdateRequest {
			return {
				organizationId: isSet(object.organizationId)
					? globalThis.String(object.organizationId)
					: isSet(object.organization_id)
						? globalThis.String(object.organization_id)
						: undefined,
			};
		},

		toJSON(message: UserOrganizationUpdateRequest): unknown {
			const obj: any = {};
			if (message.organizationId !== undefined) {
				obj.organizationId = message.organizationId;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<UserOrganizationUpdateRequest>, I>>(
			base?: I,
		): UserOrganizationUpdateRequest {
			return UserOrganizationUpdateRequest.fromPartial(base ?? ({} as any));
		},
		fromPartial<I extends Exact<DeepPartial<UserOrganizationUpdateRequest>, I>>(
			object: I,
		): UserOrganizationUpdateRequest {
			const message = createBaseUserOrganizationUpdateRequest();
			message.organizationId = object.organizationId ?? undefined;
			return message;
		},
	};

function createBaseUserCreditsData(): UserCreditsData {
	return { balance: undefined, usageTransactions: [], paymentTransactions: [] };
}

export const UserCreditsData: MessageFns<UserCreditsData> = {
	encode(
		message: UserCreditsData,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.balance !== undefined) {
			UserCreditsBalance.encode(
				message.balance,
				writer.uint32(10).fork(),
			).join();
		}
		for (const v of message.usageTransactions) {
			UsageTransaction.encode(v!, writer.uint32(18).fork()).join();
		}
		for (const v of message.paymentTransactions) {
			PaymentTransaction.encode(v!, writer.uint32(26).fork()).join();
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): UserCreditsData {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseUserCreditsData();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.balance = UserCreditsBalance.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.usageTransactions.push(
						UsageTransaction.decode(reader, reader.uint32()),
					);
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.paymentTransactions.push(
						PaymentTransaction.decode(reader, reader.uint32()),
					);
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): UserCreditsData {
		return {
			balance: isSet(object.balance)
				? UserCreditsBalance.fromJSON(object.balance)
				: undefined,
			usageTransactions: globalThis.Array.isArray(object?.usageTransactions)
				? object.usageTransactions.map((e: any) => UsageTransaction.fromJSON(e))
				: globalThis.Array.isArray(object?.usage_transactions)
					? object.usage_transactions.map((e: any) =>
							UsageTransaction.fromJSON(e),
						)
					: [],
			paymentTransactions: globalThis.Array.isArray(object?.paymentTransactions)
				? object.paymentTransactions.map((e: any) =>
						PaymentTransaction.fromJSON(e),
					)
				: globalThis.Array.isArray(object?.payment_transactions)
					? object.payment_transactions.map((e: any) =>
							PaymentTransaction.fromJSON(e),
						)
					: [],
		};
	},

	toJSON(message: UserCreditsData): unknown {
		const obj: any = {};
		if (message.balance !== undefined) {
			obj.balance = UserCreditsBalance.toJSON(message.balance);
		}
		if (message.usageTransactions?.length) {
			obj.usageTransactions = message.usageTransactions.map((e) =>
				UsageTransaction.toJSON(e),
			);
		}
		if (message.paymentTransactions?.length) {
			obj.paymentTransactions = message.paymentTransactions.map((e) =>
				PaymentTransaction.toJSON(e),
			);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<UserCreditsData>, I>>(
		base?: I,
	): UserCreditsData {
		return UserCreditsData.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<UserCreditsData>, I>>(
		object: I,
	): UserCreditsData {
		const message = createBaseUserCreditsData();
		message.balance =
			object.balance !== undefined && object.balance !== null
				? UserCreditsBalance.fromPartial(object.balance)
				: undefined;
		message.usageTransactions =
			object.usageTransactions?.map((e) => UsageTransaction.fromPartial(e)) ||
			[];
		message.paymentTransactions =
			object.paymentTransactions?.map((e) =>
				PaymentTransaction.fromPartial(e),
			) || [];
		return message;
	},
};

function createBaseGetOrganizationCreditsRequest(): GetOrganizationCreditsRequest {
	return { organizationId: "" };
}

export const GetOrganizationCreditsRequest: MessageFns<GetOrganizationCreditsRequest> =
	{
		encode(
			message: GetOrganizationCreditsRequest,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.organizationId !== "") {
				writer.uint32(10).string(message.organizationId);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): GetOrganizationCreditsRequest {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseGetOrganizationCreditsRequest();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.organizationId = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): GetOrganizationCreditsRequest {
			return {
				organizationId: isSet(object.organizationId)
					? globalThis.String(object.organizationId)
					: isSet(object.organization_id)
						? globalThis.String(object.organization_id)
						: "",
			};
		},

		toJSON(message: GetOrganizationCreditsRequest): unknown {
			const obj: any = {};
			if (message.organizationId !== "") {
				obj.organizationId = message.organizationId;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<GetOrganizationCreditsRequest>, I>>(
			base?: I,
		): GetOrganizationCreditsRequest {
			return GetOrganizationCreditsRequest.fromPartial(base ?? ({} as any));
		},
		fromPartial<I extends Exact<DeepPartial<GetOrganizationCreditsRequest>, I>>(
			object: I,
		): GetOrganizationCreditsRequest {
			const message = createBaseGetOrganizationCreditsRequest();
			message.organizationId = object.organizationId ?? "";
			return message;
		},
	};

function createBaseOrganizationCreditsData(): OrganizationCreditsData {
	return { balance: undefined, organizationId: "", usageTransactions: [] };
}

export const OrganizationCreditsData: MessageFns<OrganizationCreditsData> = {
	encode(
		message: OrganizationCreditsData,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.balance !== undefined) {
			UserCreditsBalance.encode(
				message.balance,
				writer.uint32(10).fork(),
			).join();
		}
		if (message.organizationId !== "") {
			writer.uint32(18).string(message.organizationId);
		}
		for (const v of message.usageTransactions) {
			OrganizationUsageTransaction.encode(v!, writer.uint32(26).fork()).join();
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): OrganizationCreditsData {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseOrganizationCreditsData();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.balance = UserCreditsBalance.decode(reader, reader.uint32());
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.organizationId = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.usageTransactions.push(
						OrganizationUsageTransaction.decode(reader, reader.uint32()),
					);
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): OrganizationCreditsData {
		return {
			balance: isSet(object.balance)
				? UserCreditsBalance.fromJSON(object.balance)
				: undefined,
			organizationId: isSet(object.organizationId)
				? globalThis.String(object.organizationId)
				: isSet(object.organization_id)
					? globalThis.String(object.organization_id)
					: "",
			usageTransactions: globalThis.Array.isArray(object?.usageTransactions)
				? object.usageTransactions.map((e: any) =>
						OrganizationUsageTransaction.fromJSON(e),
					)
				: globalThis.Array.isArray(object?.usage_transactions)
					? object.usage_transactions.map((e: any) =>
							OrganizationUsageTransaction.fromJSON(e),
						)
					: [],
		};
	},

	toJSON(message: OrganizationCreditsData): unknown {
		const obj: any = {};
		if (message.balance !== undefined) {
			obj.balance = UserCreditsBalance.toJSON(message.balance);
		}
		if (message.organizationId !== "") {
			obj.organizationId = message.organizationId;
		}
		if (message.usageTransactions?.length) {
			obj.usageTransactions = message.usageTransactions.map((e) =>
				OrganizationUsageTransaction.toJSON(e),
			);
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<OrganizationCreditsData>, I>>(
		base?: I,
	): OrganizationCreditsData {
		return OrganizationCreditsData.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<OrganizationCreditsData>, I>>(
		object: I,
	): OrganizationCreditsData {
		const message = createBaseOrganizationCreditsData();
		message.balance =
			object.balance !== undefined && object.balance !== null
				? UserCreditsBalance.fromPartial(object.balance)
				: undefined;
		message.organizationId = object.organizationId ?? "";
		message.usageTransactions =
			object.usageTransactions?.map((e) =>
				OrganizationUsageTransaction.fromPartial(e),
			) || [];
		return message;
	},
};

function createBaseUserCreditsBalance(): UserCreditsBalance {
	return { currentBalance: 0 };
}

export const UserCreditsBalance: MessageFns<UserCreditsBalance> = {
	encode(
		message: UserCreditsBalance,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.currentBalance !== 0) {
			writer.uint32(9).double(message.currentBalance);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): UserCreditsBalance {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseUserCreditsBalance();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 9) {
						break;
					}

					message.currentBalance = reader.double();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): UserCreditsBalance {
		return {
			currentBalance: isSet(object.currentBalance)
				? globalThis.Number(object.currentBalance)
				: isSet(object.current_balance)
					? globalThis.Number(object.current_balance)
					: 0,
		};
	},

	toJSON(message: UserCreditsBalance): unknown {
		const obj: any = {};
		if (message.currentBalance !== 0) {
			obj.currentBalance = message.currentBalance;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<UserCreditsBalance>, I>>(
		base?: I,
	): UserCreditsBalance {
		return UserCreditsBalance.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<UserCreditsBalance>, I>>(
		object: I,
	): UserCreditsBalance {
		const message = createBaseUserCreditsBalance();
		message.currentBalance = object.currentBalance ?? 0;
		return message;
	},
};

function createBaseUsageTransaction(): UsageTransaction {
	return {
		aiInferenceProviderName: "",
		aiModelName: "",
		aiModelTypeName: "",
		completionTokens: 0,
		costUsd: 0,
		createdAt: "",
		creditsUsed: 0,
		generationId: "",
		organizationId: "",
		promptTokens: 0,
		totalTokens: 0,
		userId: "",
		operation: "",
	};
}

export const UsageTransaction: MessageFns<UsageTransaction> = {
	encode(
		message: UsageTransaction,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.aiInferenceProviderName !== "") {
			writer.uint32(10).string(message.aiInferenceProviderName);
		}
		if (message.aiModelName !== "") {
			writer.uint32(18).string(message.aiModelName);
		}
		if (message.aiModelTypeName !== "") {
			writer.uint32(26).string(message.aiModelTypeName);
		}
		if (message.completionTokens !== 0) {
			writer.uint32(32).int32(message.completionTokens);
		}
		if (message.costUsd !== 0) {
			writer.uint32(41).double(message.costUsd);
		}
		if (message.createdAt !== "") {
			writer.uint32(50).string(message.createdAt);
		}
		if (message.creditsUsed !== 0) {
			writer.uint32(57).double(message.creditsUsed);
		}
		if (message.generationId !== "") {
			writer.uint32(66).string(message.generationId);
		}
		if (message.organizationId !== "") {
			writer.uint32(74).string(message.organizationId);
		}
		if (message.promptTokens !== 0) {
			writer.uint32(80).int32(message.promptTokens);
		}
		if (message.totalTokens !== 0) {
			writer.uint32(88).int32(message.totalTokens);
		}
		if (message.userId !== "") {
			writer.uint32(98).string(message.userId);
		}
		if (message.operation !== "") {
			writer.uint32(106).string(message.operation);
		}
		return writer;
	},

	decode(input: BinaryReader | Uint8Array, length?: number): UsageTransaction {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBaseUsageTransaction();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.aiInferenceProviderName = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.aiModelName = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 26) {
						break;
					}

					message.aiModelTypeName = reader.string();
					continue;
				}
				case 4: {
					if (tag !== 32) {
						break;
					}

					message.completionTokens = reader.int32();
					continue;
				}
				case 5: {
					if (tag !== 41) {
						break;
					}

					message.costUsd = reader.double();
					continue;
				}
				case 6: {
					if (tag !== 50) {
						break;
					}

					message.createdAt = reader.string();
					continue;
				}
				case 7: {
					if (tag !== 57) {
						break;
					}

					message.creditsUsed = reader.double();
					continue;
				}
				case 8: {
					if (tag !== 66) {
						break;
					}

					message.generationId = reader.string();
					continue;
				}
				case 9: {
					if (tag !== 74) {
						break;
					}

					message.organizationId = reader.string();
					continue;
				}
				case 10: {
					if (tag !== 80) {
						break;
					}

					message.promptTokens = reader.int32();
					continue;
				}
				case 11: {
					if (tag !== 88) {
						break;
					}

					message.totalTokens = reader.int32();
					continue;
				}
				case 12: {
					if (tag !== 98) {
						break;
					}

					message.userId = reader.string();
					continue;
				}
				case 13: {
					if (tag !== 106) {
						break;
					}

					message.operation = reader.string();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): UsageTransaction {
		return {
			aiInferenceProviderName: isSet(object.aiInferenceProviderName)
				? globalThis.String(object.aiInferenceProviderName)
				: isSet(object.ai_inference_provider_name)
					? globalThis.String(object.ai_inference_provider_name)
					: "",
			aiModelName: isSet(object.aiModelName)
				? globalThis.String(object.aiModelName)
				: isSet(object.ai_model_name)
					? globalThis.String(object.ai_model_name)
					: "",
			aiModelTypeName: isSet(object.aiModelTypeName)
				? globalThis.String(object.aiModelTypeName)
				: isSet(object.ai_model_type_name)
					? globalThis.String(object.ai_model_type_name)
					: "",
			completionTokens: isSet(object.completionTokens)
				? globalThis.Number(object.completionTokens)
				: isSet(object.completion_tokens)
					? globalThis.Number(object.completion_tokens)
					: 0,
			costUsd: isSet(object.costUsd)
				? globalThis.Number(object.costUsd)
				: isSet(object.cost_usd)
					? globalThis.Number(object.cost_usd)
					: 0,
			createdAt: isSet(object.createdAt)
				? globalThis.String(object.createdAt)
				: isSet(object.created_at)
					? globalThis.String(object.created_at)
					: "",
			creditsUsed: isSet(object.creditsUsed)
				? globalThis.Number(object.creditsUsed)
				: isSet(object.credits_used)
					? globalThis.Number(object.credits_used)
					: 0,
			generationId: isSet(object.generationId)
				? globalThis.String(object.generationId)
				: isSet(object.generation_id)
					? globalThis.String(object.generation_id)
					: "",
			organizationId: isSet(object.organizationId)
				? globalThis.String(object.organizationId)
				: isSet(object.organization_id)
					? globalThis.String(object.organization_id)
					: "",
			promptTokens: isSet(object.promptTokens)
				? globalThis.Number(object.promptTokens)
				: isSet(object.prompt_tokens)
					? globalThis.Number(object.prompt_tokens)
					: 0,
			totalTokens: isSet(object.totalTokens)
				? globalThis.Number(object.totalTokens)
				: isSet(object.total_tokens)
					? globalThis.Number(object.total_tokens)
					: 0,
			userId: isSet(object.userId)
				? globalThis.String(object.userId)
				: isSet(object.user_id)
					? globalThis.String(object.user_id)
					: "",
			operation: isSet(object.operation)
				? globalThis.String(object.operation)
				: "",
		};
	},

	toJSON(message: UsageTransaction): unknown {
		const obj: any = {};
		if (message.aiInferenceProviderName !== "") {
			obj.aiInferenceProviderName = message.aiInferenceProviderName;
		}
		if (message.aiModelName !== "") {
			obj.aiModelName = message.aiModelName;
		}
		if (message.aiModelTypeName !== "") {
			obj.aiModelTypeName = message.aiModelTypeName;
		}
		if (message.completionTokens !== 0) {
			obj.completionTokens = Math.round(message.completionTokens);
		}
		if (message.costUsd !== 0) {
			obj.costUsd = message.costUsd;
		}
		if (message.createdAt !== "") {
			obj.createdAt = message.createdAt;
		}
		if (message.creditsUsed !== 0) {
			obj.creditsUsed = message.creditsUsed;
		}
		if (message.generationId !== "") {
			obj.generationId = message.generationId;
		}
		if (message.organizationId !== "") {
			obj.organizationId = message.organizationId;
		}
		if (message.promptTokens !== 0) {
			obj.promptTokens = Math.round(message.promptTokens);
		}
		if (message.totalTokens !== 0) {
			obj.totalTokens = Math.round(message.totalTokens);
		}
		if (message.userId !== "") {
			obj.userId = message.userId;
		}
		if (message.operation !== "") {
			obj.operation = message.operation;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<UsageTransaction>, I>>(
		base?: I,
	): UsageTransaction {
		return UsageTransaction.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<UsageTransaction>, I>>(
		object: I,
	): UsageTransaction {
		const message = createBaseUsageTransaction();
		message.aiInferenceProviderName = object.aiInferenceProviderName ?? "";
		message.aiModelName = object.aiModelName ?? "";
		message.aiModelTypeName = object.aiModelTypeName ?? "";
		message.completionTokens = object.completionTokens ?? 0;
		message.costUsd = object.costUsd ?? 0;
		message.createdAt = object.createdAt ?? "";
		message.creditsUsed = object.creditsUsed ?? 0;
		message.generationId = object.generationId ?? "";
		message.organizationId = object.organizationId ?? "";
		message.promptTokens = object.promptTokens ?? 0;
		message.totalTokens = object.totalTokens ?? 0;
		message.userId = object.userId ?? "";
		message.operation = object.operation ?? "";
		return message;
	},
};

function createBasePaymentTransaction(): PaymentTransaction {
	return { paidAt: "", creatorId: "", amountCents: 0, credits: 0 };
}

export const PaymentTransaction: MessageFns<PaymentTransaction> = {
	encode(
		message: PaymentTransaction,
		writer: BinaryWriter = new BinaryWriter(),
	): BinaryWriter {
		if (message.paidAt !== "") {
			writer.uint32(10).string(message.paidAt);
		}
		if (message.creatorId !== "") {
			writer.uint32(18).string(message.creatorId);
		}
		if (message.amountCents !== 0) {
			writer.uint32(24).int32(message.amountCents);
		}
		if (message.credits !== 0) {
			writer.uint32(33).double(message.credits);
		}
		return writer;
	},

	decode(
		input: BinaryReader | Uint8Array,
		length?: number,
	): PaymentTransaction {
		const reader =
			input instanceof BinaryReader ? input : new BinaryReader(input);
		const end = length === undefined ? reader.len : reader.pos + length;
		const message = createBasePaymentTransaction();
		while (reader.pos < end) {
			const tag = reader.uint32();
			switch (tag >>> 3) {
				case 1: {
					if (tag !== 10) {
						break;
					}

					message.paidAt = reader.string();
					continue;
				}
				case 2: {
					if (tag !== 18) {
						break;
					}

					message.creatorId = reader.string();
					continue;
				}
				case 3: {
					if (tag !== 24) {
						break;
					}

					message.amountCents = reader.int32();
					continue;
				}
				case 4: {
					if (tag !== 33) {
						break;
					}

					message.credits = reader.double();
					continue;
				}
			}
			if ((tag & 7) === 4 || tag === 0) {
				break;
			}
			reader.skip(tag & 7);
		}
		return message;
	},

	fromJSON(object: any): PaymentTransaction {
		return {
			paidAt: isSet(object.paidAt)
				? globalThis.String(object.paidAt)
				: isSet(object.paid_at)
					? globalThis.String(object.paid_at)
					: "",
			creatorId: isSet(object.creatorId)
				? globalThis.String(object.creatorId)
				: isSet(object.creator_id)
					? globalThis.String(object.creator_id)
					: "",
			amountCents: isSet(object.amountCents)
				? globalThis.Number(object.amountCents)
				: isSet(object.amount_cents)
					? globalThis.Number(object.amount_cents)
					: 0,
			credits: isSet(object.credits) ? globalThis.Number(object.credits) : 0,
		};
	},

	toJSON(message: PaymentTransaction): unknown {
		const obj: any = {};
		if (message.paidAt !== "") {
			obj.paidAt = message.paidAt;
		}
		if (message.creatorId !== "") {
			obj.creatorId = message.creatorId;
		}
		if (message.amountCents !== 0) {
			obj.amountCents = Math.round(message.amountCents);
		}
		if (message.credits !== 0) {
			obj.credits = message.credits;
		}
		return obj;
	},

	create<I extends Exact<DeepPartial<PaymentTransaction>, I>>(
		base?: I,
	): PaymentTransaction {
		return PaymentTransaction.fromPartial(base ?? ({} as any));
	},
	fromPartial<I extends Exact<DeepPartial<PaymentTransaction>, I>>(
		object: I,
	): PaymentTransaction {
		const message = createBasePaymentTransaction();
		message.paidAt = object.paidAt ?? "";
		message.creatorId = object.creatorId ?? "";
		message.amountCents = object.amountCents ?? 0;
		message.credits = object.credits ?? 0;
		return message;
	},
};

function createBaseOrganizationUsageTransaction(): OrganizationUsageTransaction {
	return {
		aiInferenceProviderName: "",
		aiModelName: "",
		aiModelTypeName: "",
		completionTokens: 0,
		costUsd: 0,
		createdAt: "",
		creditsUsed: 0,
		generationId: "",
		organizationId: "",
		promptTokens: 0,
		totalTokens: 0,
		userId: "",
		operation: "",
	};
}

export const OrganizationUsageTransaction: MessageFns<OrganizationUsageTransaction> =
	{
		encode(
			message: OrganizationUsageTransaction,
			writer: BinaryWriter = new BinaryWriter(),
		): BinaryWriter {
			if (message.aiInferenceProviderName !== "") {
				writer.uint32(10).string(message.aiInferenceProviderName);
			}
			if (message.aiModelName !== "") {
				writer.uint32(18).string(message.aiModelName);
			}
			if (message.aiModelTypeName !== "") {
				writer.uint32(26).string(message.aiModelTypeName);
			}
			if (message.completionTokens !== 0) {
				writer.uint32(32).int32(message.completionTokens);
			}
			if (message.costUsd !== 0) {
				writer.uint32(41).double(message.costUsd);
			}
			if (message.createdAt !== "") {
				writer.uint32(50).string(message.createdAt);
			}
			if (message.creditsUsed !== 0) {
				writer.uint32(57).double(message.creditsUsed);
			}
			if (message.generationId !== "") {
				writer.uint32(66).string(message.generationId);
			}
			if (message.organizationId !== "") {
				writer.uint32(74).string(message.organizationId);
			}
			if (message.promptTokens !== 0) {
				writer.uint32(80).int32(message.promptTokens);
			}
			if (message.totalTokens !== 0) {
				writer.uint32(88).int32(message.totalTokens);
			}
			if (message.userId !== "") {
				writer.uint32(98).string(message.userId);
			}
			if (message.operation !== "") {
				writer.uint32(106).string(message.operation);
			}
			return writer;
		},

		decode(
			input: BinaryReader | Uint8Array,
			length?: number,
		): OrganizationUsageTransaction {
			const reader =
				input instanceof BinaryReader ? input : new BinaryReader(input);
			const end = length === undefined ? reader.len : reader.pos + length;
			const message = createBaseOrganizationUsageTransaction();
			while (reader.pos < end) {
				const tag = reader.uint32();
				switch (tag >>> 3) {
					case 1: {
						if (tag !== 10) {
							break;
						}

						message.aiInferenceProviderName = reader.string();
						continue;
					}
					case 2: {
						if (tag !== 18) {
							break;
						}

						message.aiModelName = reader.string();
						continue;
					}
					case 3: {
						if (tag !== 26) {
							break;
						}

						message.aiModelTypeName = reader.string();
						continue;
					}
					case 4: {
						if (tag !== 32) {
							break;
						}

						message.completionTokens = reader.int32();
						continue;
					}
					case 5: {
						if (tag !== 41) {
							break;
						}

						message.costUsd = reader.double();
						continue;
					}
					case 6: {
						if (tag !== 50) {
							break;
						}

						message.createdAt = reader.string();
						continue;
					}
					case 7: {
						if (tag !== 57) {
							break;
						}

						message.creditsUsed = reader.double();
						continue;
					}
					case 8: {
						if (tag !== 66) {
							break;
						}

						message.generationId = reader.string();
						continue;
					}
					case 9: {
						if (tag !== 74) {
							break;
						}

						message.organizationId = reader.string();
						continue;
					}
					case 10: {
						if (tag !== 80) {
							break;
						}

						message.promptTokens = reader.int32();
						continue;
					}
					case 11: {
						if (tag !== 88) {
							break;
						}

						message.totalTokens = reader.int32();
						continue;
					}
					case 12: {
						if (tag !== 98) {
							break;
						}

						message.userId = reader.string();
						continue;
					}
					case 13: {
						if (tag !== 106) {
							break;
						}

						message.operation = reader.string();
						continue;
					}
				}
				if ((tag & 7) === 4 || tag === 0) {
					break;
				}
				reader.skip(tag & 7);
			}
			return message;
		},

		fromJSON(object: any): OrganizationUsageTransaction {
			return {
				aiInferenceProviderName: isSet(object.aiInferenceProviderName)
					? globalThis.String(object.aiInferenceProviderName)
					: isSet(object.ai_inference_provider_name)
						? globalThis.String(object.ai_inference_provider_name)
						: "",
				aiModelName: isSet(object.aiModelName)
					? globalThis.String(object.aiModelName)
					: isSet(object.ai_model_name)
						? globalThis.String(object.ai_model_name)
						: "",
				aiModelTypeName: isSet(object.aiModelTypeName)
					? globalThis.String(object.aiModelTypeName)
					: isSet(object.ai_model_type_name)
						? globalThis.String(object.ai_model_type_name)
						: "",
				completionTokens: isSet(object.completionTokens)
					? globalThis.Number(object.completionTokens)
					: isSet(object.completion_tokens)
						? globalThis.Number(object.completion_tokens)
						: 0,
				costUsd: isSet(object.costUsd)
					? globalThis.Number(object.costUsd)
					: isSet(object.cost_usd)
						? globalThis.Number(object.cost_usd)
						: 0,
				createdAt: isSet(object.createdAt)
					? globalThis.String(object.createdAt)
					: isSet(object.created_at)
						? globalThis.String(object.created_at)
						: "",
				creditsUsed: isSet(object.creditsUsed)
					? globalThis.Number(object.creditsUsed)
					: isSet(object.credits_used)
						? globalThis.Number(object.credits_used)
						: 0,
				generationId: isSet(object.generationId)
					? globalThis.String(object.generationId)
					: isSet(object.generation_id)
						? globalThis.String(object.generation_id)
						: "",
				organizationId: isSet(object.organizationId)
					? globalThis.String(object.organizationId)
					: isSet(object.organization_id)
						? globalThis.String(object.organization_id)
						: "",
				promptTokens: isSet(object.promptTokens)
					? globalThis.Number(object.promptTokens)
					: isSet(object.prompt_tokens)
						? globalThis.Number(object.prompt_tokens)
						: 0,
				totalTokens: isSet(object.totalTokens)
					? globalThis.Number(object.totalTokens)
					: isSet(object.total_tokens)
						? globalThis.Number(object.total_tokens)
						: 0,
				userId: isSet(object.userId)
					? globalThis.String(object.userId)
					: isSet(object.user_id)
						? globalThis.String(object.user_id)
						: "",
				operation: isSet(object.operation)
					? globalThis.String(object.operation)
					: "",
			};
		},

		toJSON(message: OrganizationUsageTransaction): unknown {
			const obj: any = {};
			if (message.aiInferenceProviderName !== "") {
				obj.aiInferenceProviderName = message.aiInferenceProviderName;
			}
			if (message.aiModelName !== "") {
				obj.aiModelName = message.aiModelName;
			}
			if (message.aiModelTypeName !== "") {
				obj.aiModelTypeName = message.aiModelTypeName;
			}
			if (message.completionTokens !== 0) {
				obj.completionTokens = Math.round(message.completionTokens);
			}
			if (message.costUsd !== 0) {
				obj.costUsd = message.costUsd;
			}
			if (message.createdAt !== "") {
				obj.createdAt = message.createdAt;
			}
			if (message.creditsUsed !== 0) {
				obj.creditsUsed = message.creditsUsed;
			}
			if (message.generationId !== "") {
				obj.generationId = message.generationId;
			}
			if (message.organizationId !== "") {
				obj.organizationId = message.organizationId;
			}
			if (message.promptTokens !== 0) {
				obj.promptTokens = Math.round(message.promptTokens);
			}
			if (message.totalTokens !== 0) {
				obj.totalTokens = Math.round(message.totalTokens);
			}
			if (message.userId !== "") {
				obj.userId = message.userId;
			}
			if (message.operation !== "") {
				obj.operation = message.operation;
			}
			return obj;
		},

		create<I extends Exact<DeepPartial<OrganizationUsageTransaction>, I>>(
			base?: I,
		): OrganizationUsageTransaction {
			return OrganizationUsageTransaction.fromPartial(base ?? ({} as any));
		},
		fromPartial<I extends Exact<DeepPartial<OrganizationUsageTransaction>, I>>(
			object: I,
		): OrganizationUsageTransaction {
			const message = createBaseOrganizationUsageTransaction();
			message.aiInferenceProviderName = object.aiInferenceProviderName ?? "";
			message.aiModelName = object.aiModelName ?? "";
			message.aiModelTypeName = object.aiModelTypeName ?? "";
			message.completionTokens = object.completionTokens ?? 0;
			message.costUsd = object.costUsd ?? 0;
			message.createdAt = object.createdAt ?? "";
			message.creditsUsed = object.creditsUsed ?? 0;
			message.generationId = object.generationId ?? "";
			message.organizationId = object.organizationId ?? "";
			message.promptTokens = object.promptTokens ?? 0;
			message.totalTokens = object.totalTokens ?? 0;
			message.userId = object.userId ?? "";
			message.operation = object.operation ?? "";
			return message;
		},
	};

/** Service for account-related operations */
export type AccountServiceDefinition = typeof AccountServiceDefinition;
export const AccountServiceDefinition = {
	name: "AccountService",
	fullName: "cline.AccountService",
	methods: {
		/**
		 * Handles the user clicking the login link in the UI.
		 * Generates a secure nonce for state validation, stores it in secrets,
		 * and opens the authentication URL in the external browser.
		 */
		accountLoginClicked: {
			name: "accountLoginClicked",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: String,
			responseStream: false,
			options: {},
		},
		/**
		 * Handles the user clicking the logout button in the UI.
		 * Clears API keys and user state.
		 */
		accountLogoutClicked: {
			name: "accountLogoutClicked",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/** Subscribe to auth status update events (when authentication state changes) */
		subscribeToAuthStatusUpdate: {
			name: "subscribeToAuthStatusUpdate",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: AuthState,
			responseStream: true,
			options: {},
		},
		/**
		 * Handles authentication state changes from the Firebase context.
		 * Updates the user info in global state and returns the updated value.
		 */
		authStateChanged: {
			name: "authStateChanged",
			requestType: AuthStateChangedRequest,
			requestStream: false,
			responseType: AuthState,
			responseStream: false,
			options: {},
		},
		/**
		 * Fetches all user credits data
		 * (balance, usage transactions, payment transactions)
		 */
		getUserCredits: {
			name: "getUserCredits",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: UserCreditsData,
			responseStream: false,
			options: {},
		},
		getOrganizationCredits: {
			name: "getOrganizationCredits",
			requestType: GetOrganizationCreditsRequest,
			requestStream: false,
			responseType: OrganizationCreditsData,
			responseStream: false,
			options: {},
		},
		/**
		 * Fetches all user organizations data
		 * Returns a list of UserOrganization objects
		 */
		getUserOrganizations: {
			name: "getUserOrganizations",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: UserOrganizationsResponse,
			responseStream: false,
			options: {},
		},
		setUserOrganization: {
			name: "setUserOrganization",
			requestType: UserOrganizationUpdateRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		openrouterAuthClicked: {
			name: "openrouterAuthClicked",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		requestyAuthClicked: {
			name: "requestyAuthClicked",
			requestType: StringRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		hicapAuthClicked: {
			name: "hicapAuthClicked",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/** Returns a link the webview can use to redirect back to the user's IDE. */
		getRedirectUrl: {
			name: "getRedirectUrl",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: String,
			responseStream: false,
			options: {},
		},
		/**
		 * OpenAI Codex OAuth authentication
		 * Starts the OAuth flow and opens browser for user to sign in with ChatGPT Plus/Pro
		 */
		openAiCodexSignIn: {
			name: "openAiCodexSignIn",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
		/** Signs out of OpenAI Codex and clears stored credentials */
		openAiCodexSignOut: {
			name: "openAiCodexSignOut",
			requestType: EmptyRequest,
			requestStream: false,
			responseType: Empty,
			responseStream: false,
			options: {},
		},
	},
} as const;

type Builtin =
	| Date
	| Function
	| Uint8Array
	| string
	| number
	| boolean
	| undefined;

type DeepPartial<T> = T extends Builtin
	? T
	: T extends globalThis.Array<infer U>
		? globalThis.Array<DeepPartial<U>>
		: T extends ReadonlyArray<infer U>
			? ReadonlyArray<DeepPartial<U>>
			: T extends {}
				? { [K in keyof T]?: DeepPartial<T[K]> }
				: Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin
	? P
	: P & { [K in keyof P]: Exact<P[K], I[K]> } & {
			[K in Exclude<keyof I, KeysOfUnion<P>>]: never;
		};

function isSet(value: any): boolean {
	return value !== null && value !== undefined;
}

interface MessageFns<T> {
	encode(message: T, writer?: BinaryWriter): BinaryWriter;
	decode(input: BinaryReader | Uint8Array, length?: number): T;
	fromJSON(object: any): T;
	toJSON(message: T): unknown;
	create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
	fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
